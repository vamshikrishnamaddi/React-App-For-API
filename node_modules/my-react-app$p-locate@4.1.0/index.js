'use strict';

Liferay.Loader.define('my-react-app$p-locate@4.1.0/index', ['module', 'exports', 'require', 'my-react-app$p-limit'], function (module, exports, require) {
	var define = undefined;
	var global = window;
	{
		var _extends = Object.assign || function (target) {
			for (var i = 1; i < arguments.length; i++) {
				var source = arguments[i];

				for (var key in source) {
					if (Object.prototype.hasOwnProperty.call(source, key)) {
						target[key] = source[key];
					}
				}
			}

			return target;
		};

		const pLimit = require('my-react-app$p-limit');

		class EndError extends Error {
			constructor(value) {
				super();
				this.value = value;
			}
		}

		// The input can also be a promise, so we await it
		const testElement = async (element, tester) => tester((await element));

		// The input can also be a promise, so we `Promise.all()` them both
		const finder = async element => {
			const values = await Promise.all(element);
			if (values[1] === true) {
				throw new EndError(values[0]);
			}

			return false;
		};

		const pLocate = async (iterable, tester, options) => {
			options = _extends({
				concurrency: Infinity,
				preserveOrder: true
			}, options);

			const limit = pLimit(options.concurrency);

			// Start all the promises concurrently with optional limit
			const items = [...iterable].map(element => [element, limit(testElement, element, tester)]);

			// Check the promises either serially or concurrently
			const checkLimit = pLimit(options.preserveOrder ? 1 : Infinity);

			try {
				await Promise.all(items.map(element => checkLimit(finder, element)));
			} catch (error) {
				if (error instanceof EndError) {
					return error.value;
				}

				throw error;
			}
		};

		module.exports = pLocate;
		// TODO: Remove this for the next major release
		module.exports.default = pLocate;
	}
});
//# sourceMappingURL=index.js.map