{"version":3,"sources":["index.js"],"names":["pLimit","require","EndError","Error","constructor","value","testElement","element","tester","finder","values","Promise","all","pLocate","iterable","options","concurrency","Infinity","preserveOrder","limit","items","map","checkLimit","error","module","exports","default"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;AACA,QAAMA,SAASC,QAAQ,sBAAR,CAAf;;AAEA,QAAMC,QAAN,SAAuBC,KAAvB,CAA6B;AAC5BC,eAAYC,KAAZ,EAAmB;AAClB;AACA,SAAKA,KAAL,GAAaA,KAAb;AACA;AAJ2B;;AAO7B;AACA,QAAMC,cAAc,OAAOC,OAAP,EAAgBC,MAAhB,KAA2BA,QAAO,MAAMD,OAAb,EAA/C;;AAEA;AACA,QAAME,SAAS,MAAMF,OAAN,IAAiB;AAC/B,SAAMG,SAAS,MAAMC,QAAQC,GAAR,CAAYL,OAAZ,CAArB;AACA,OAAIG,OAAO,CAAP,MAAc,IAAlB,EAAwB;AACvB,UAAM,IAAIR,QAAJ,CAAaQ,OAAO,CAAP,CAAb,CAAN;AACA;;AAED,UAAO,KAAP;AACA,GAPD;;AASA,QAAMG,UAAU,OAAOC,QAAP,EAAiBN,MAAjB,EAAyBO,OAAzB,KAAqC;AACpDA;AACCC,iBAAaC,QADd;AAECC,mBAAe;AAFhB,MAGIH,OAHJ;;AAMA,SAAMI,QAAQnB,OAAOe,QAAQC,WAAf,CAAd;;AAEA;AACA,SAAMI,QAAQ,CAAC,GAAGN,QAAJ,EAAcO,GAAd,CAAkBd,WAAW,CAACA,OAAD,EAAUY,MAAMb,WAAN,EAAmBC,OAAnB,EAA4BC,MAA5B,CAAV,CAA7B,CAAd;;AAEA;AACA,SAAMc,aAAatB,OAAOe,QAAQG,aAAR,GAAwB,CAAxB,GAA4BD,QAAnC,CAAnB;;AAEA,OAAI;AACH,UAAMN,QAAQC,GAAR,CAAYQ,MAAMC,GAAN,CAAUd,WAAWe,WAAWb,MAAX,EAAmBF,OAAnB,CAArB,CAAZ,CAAN;AACA,IAFD,CAEE,OAAOgB,KAAP,EAAc;AACf,QAAIA,iBAAiBrB,QAArB,EAA+B;AAC9B,YAAOqB,MAAMlB,KAAb;AACA;;AAED,UAAMkB,KAAN;AACA;AACD,GAxBD;;AA0BAC,SAAOC,OAAP,GAAiBZ,OAAjB;AACA;AACAW,SAAOC,OAAP,CAAeC,OAAf,GAAyBb,OAAzB","file":"index.js","sourcesContent":["'use strict';\nconst pLimit = require('p-limit');\n\nclass EndError extends Error {\n\tconstructor(value) {\n\t\tsuper();\n\t\tthis.value = value;\n\t}\n}\n\n// The input can also be a promise, so we await it\nconst testElement = async (element, tester) => tester(await element);\n\n// The input can also be a promise, so we `Promise.all()` them both\nconst finder = async element => {\n\tconst values = await Promise.all(element);\n\tif (values[1] === true) {\n\t\tthrow new EndError(values[0]);\n\t}\n\n\treturn false;\n};\n\nconst pLocate = async (iterable, tester, options) => {\n\toptions = {\n\t\tconcurrency: Infinity,\n\t\tpreserveOrder: true,\n\t\t...options\n\t};\n\n\tconst limit = pLimit(options.concurrency);\n\n\t// Start all the promises concurrently with optional limit\n\tconst items = [...iterable].map(element => [element, limit(testElement, element, tester)]);\n\n\t// Check the promises either serially or concurrently\n\tconst checkLimit = pLimit(options.preserveOrder ? 1 : Infinity);\n\n\ttry {\n\t\tawait Promise.all(items.map(element => checkLimit(finder, element)));\n\t} catch (error) {\n\t\tif (error instanceof EndError) {\n\t\t\treturn error.value;\n\t\t}\n\n\t\tthrow error;\n\t}\n};\n\nmodule.exports = pLocate;\n// TODO: Remove this for the next major release\nmodule.exports.default = pLocate;\n"]}