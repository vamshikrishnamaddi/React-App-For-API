/**
 * react-virtual
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Liferay.Loader.define('@my-react-app$tanstack/react-virtual@3.0.0-beta.18/build/cjs/virtual-core/build/esm/index', ['module', 'exports', 'require'], function (module, exports, require) {
  var define = undefined;
  var global = window;
  {
    function _objectWithoutProperties(obj, keys) {
      var target = {};

      for (var i in obj) {
        if (keys.indexOf(i) >= 0) continue;
        if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
        target[i] = obj[i];
      }

      return target;
    }

    var _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    Object.defineProperty(exports, '__esModule', { value: true });

    /**
     * virtual-core
     *
     * Copyright (c) TanStack
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     */
    function memo(getDeps, fn, opts) {
      let deps = [];
      let result;
      return () => {
        let depTime;
        if (opts.key && opts.debug != null && opts.debug()) depTime = Date.now();
        const newDeps = getDeps();
        const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => deps[index] !== dep);

        if (!depsChanged) {
          return result;
        }

        deps = newDeps;
        let resultTime;
        if (opts.key && opts.debug != null && opts.debug()) resultTime = Date.now();
        result = fn(...newDeps);
        opts == null ? void 0 : opts.onChange == null ? void 0 : opts.onChange(result);

        if (opts.key && opts.debug != null && opts.debug()) {
          const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;
          const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;


          const pad = (str, num) => {
            str = String(str);

            while (str.length < num) {
              str = ' ' + str;
            }

            return str;
          };

          console.info("%c\u23F1 " + pad(resultEndTime, 5) + " /" + pad(depEndTime, 5) + " ms", "\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(" + Math.max(0, Math.min(120 - 120 * (resultEndTime / 16), 120)) + "deg 100% 31%);", opts == null ? void 0 : opts.key);
        }

        return result;
      };
    }

    //
    const defaultKeyExtractor = index => index;
    const defaultRangeExtractor = range => {
      const start = Math.max(range.startIndex - range.overscan, 0);
      const end = Math.min(range.endIndex + range.overscan, range.count - 1);
      const arr = [];

      for (let i = start; i <= end; i++) {
        arr.push(i);
      }

      return arr;
    };

    const memoRectCallback = (instance, cb) => {
      let prev = {
        height: -1,
        width: -1
      };
      return rect => {
        if (instance.options.horizontal ? rect.width !== prev.width : rect.height !== prev.height) {
          cb(rect);
        }

        prev = rect;
      };
    };

    const observeElementRect = (instance, cb) => {
      const observer = new ResizeObserver(entries => {
        var _entries$, _entries$2;

        cb({
          width: (_entries$ = entries[0]) == null ? void 0 : _entries$.contentRect.width,
          height: (_entries$2 = entries[0]) == null ? void 0 : _entries$2.contentRect.height
        });
      });

      if (!instance.scrollElement) {
        return;
      }

      cb(instance.scrollElement.getBoundingClientRect());
      observer.observe(instance.scrollElement);
      return () => {
        observer.unobserve(instance.scrollElement);
      };
    };
    const observeWindowRect = (instance, cb) => {
      const memoizedCallback = memoRectCallback(instance, cb);

      const onResize = () => memoizedCallback({
        width: instance.scrollElement.innerWidth,
        height: instance.scrollElement.innerHeight
      });

      if (!instance.scrollElement) {
        return;
      }

      onResize();
      instance.scrollElement.addEventListener('resize', onResize, {
        capture: false,
        passive: true
      });
      return () => {
        instance.scrollElement.removeEventListener('resize', onResize);
      };
    };
    const scrollProps = {
      element: ['scrollLeft', 'scrollTop'],
      window: ['scrollX', 'scrollY']
    };

    const createOffsetObserver = mode => {
      return (instance, cb) => {
        if (!instance.scrollElement) {
          return;
        }

        const propX = scrollProps[mode][0];
        const propY = scrollProps[mode][1];
        let prevX = instance.scrollElement[propX];
        let prevY = instance.scrollElement[propY];

        const scroll = () => {
          cb(instance.scrollElement[instance.options.horizontal ? propX : propY]);
        };

        scroll();

        const onScroll = e => {
          const target = e.currentTarget;
          const scrollX = target[propX];
          const scrollY = target[propY];

          if (instance.options.horizontal ? prevX - scrollX : prevY - scrollY) {
            scroll();
          }

          prevX = scrollX;
          prevY = scrollY;
        };

        instance.scrollElement.addEventListener('scroll', onScroll, {
          capture: false,
          passive: true
        });
        return () => {
          instance.scrollElement.removeEventListener('scroll', onScroll);
        };
      };
    };

    const observeElementOffset = createOffsetObserver('element');
    const observeWindowOffset = createOffsetObserver('window');
    const measureElement = (element, instance) => {
      return element.getBoundingClientRect()[instance.options.horizontal ? 'width' : 'height'];
    };
    const windowScroll = (offset, canSmooth, instance) => {
      var _instance$scrollEleme;
      (_instance$scrollEleme = instance.scrollElement) == null ? void 0 : _instance$scrollEleme.scrollTo == null ? void 0 : _instance$scrollEleme.scrollTo({
        [instance.options.horizontal ? 'left' : 'top']: offset,
        behavior: canSmooth ? 'smooth' : undefined
      });
    };
    const elementScroll = (offset, canSmooth, instance) => {
      var _instance$scrollEleme2;
      (_instance$scrollEleme2 = instance.scrollElement) == null ? void 0 : _instance$scrollEleme2.scrollTo == null ? void 0 : _instance$scrollEleme2.scrollTo({
        [instance.options.horizontal ? 'left' : 'top']: offset,
        behavior: canSmooth ? 'smooth' : undefined
      });
    };
    class Virtualizer {
      constructor(_opts) {
        var _this = this;

        this.unsubs = [];
        this.scrollElement = null;
        this.measurementsCache = [];
        this.itemMeasurementsCache = {};
        this.pendingMeasuredCacheIndexes = [];
        this.measureElementCache = {};
        this.range = {
          startIndex: 0,
          endIndex: 0
        };

        this.setOptions = opts => {
          Object.entries(opts).forEach(_ref => {
            let [key, value] = _ref;
            if (typeof value === 'undefined') delete opts[key];
          });
          this.options = _extends({
            debug: false,
            initialOffset: 0,
            overscan: 1,
            paddingStart: 0,
            paddingEnd: 0,
            scrollPaddingStart: 0,
            scrollPaddingEnd: 0,
            horizontal: false,
            getItemKey: defaultKeyExtractor,
            rangeExtractor: defaultRangeExtractor,
            enableSmoothScroll: true,
            onChange: () => {},
            measureElement,
            initialRect: {
              width: 0,
              height: 0
            }
          }, opts);
        };

        this.notify = () => {
          var _this$options$onChang, _this$options;

          (_this$options$onChang = (_this$options = this.options).onChange) == null ? void 0 : _this$options$onChang.call(_this$options, this);
        };

        this.cleanup = () => {
          this.unsubs.filter(Boolean).forEach(d => d());
          this.unsubs = [];
          this.scrollElement = null;
        };

        this._didMount = () => {
          return () => {
            this.cleanup();
          };
        };

        this._willUpdate = () => {
          const scrollElement = this.options.getScrollElement();

          if (this.scrollElement !== scrollElement) {
            this.cleanup();
            this.scrollElement = scrollElement;

            this._scrollToOffset(this.scrollOffset, false);

            this.unsubs.push(this.options.observeElementRect(this, rect => {
              this.scrollRect = rect;
              this.calculateRange();
            }));
            this.unsubs.push(this.options.observeElementOffset(this, offset => {
              this.scrollOffset = offset;
              this.calculateRange();
            }));
          }
        };

        this.getSize = () => {
          return this.scrollRect[this.options.horizontal ? 'width' : 'height'];
        };

        this.getMeasurements = memo(() => [this.options.count, this.options.paddingStart, this.options.getItemKey, this.itemMeasurementsCache], (count, paddingStart, getItemKey, measurementsCache) => {
          const min = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;
          this.pendingMeasuredCacheIndexes = [];
          const measurements = this.measurementsCache.slice(0, min);

          for (let i = min; i < count; i++) {
            const key = getItemKey(i);
            const measuredSize = measurementsCache[key];
            const start = measurements[i - 1] ? measurements[i - 1].end : paddingStart;
            const size = typeof measuredSize === 'number' ? measuredSize : this.options.estimateSize(i);

            measurements[i] = {
              index: i,
              start,
              size,
              end: start + size,
              key
            };
          }

          this.measurementsCache = measurements;
          return measurements;
        }, {
          key: true && 'getMeasurements',
          debug: () => this.options.debug
        });
        this.calculateRange = memo(() => [this.getMeasurements(), this.getSize(), this.scrollOffset], (measurements, outerSize, scrollOffset) => {
          const range = calculateRange({
            measurements,
            outerSize,
            scrollOffset
          });

          if (range.startIndex !== this.range.startIndex || range.endIndex !== this.range.endIndex) {
            this.range = range;
            this.notify();
          }

          return this.range;
        }, {
          key: true && 'calculateRange',
          debug: () => this.options.debug
        });
        this.getIndexes = memo(() => [this.options.rangeExtractor, this.range, this.options.overscan, this.options.count], (rangeExtractor, range, overscan, count) => {
          return rangeExtractor(_extends({}, range, {
            overscan,
            count: count
          }));
        }, {
          key: true && 'getIndexes',
          debug: () => this.options.debug
        });
        this.getVirtualItems = memo(() => [this.getIndexes(), this.getMeasurements(), this.options.measureElement], (indexes, measurements, measureElement) => {
          const makeMeasureElement = index => measurableItem => {
            var _this$itemMeasurement;

            const item = this.measurementsCache[index];

            if (!measurableItem) {
              return;
            }

            const measuredItemSize = measureElement(measurableItem, this);
            const itemSize = (_this$itemMeasurement = this.itemMeasurementsCache[item.key]) != null ? _this$itemMeasurement : item.size;

            if (measuredItemSize !== itemSize) {
              if (item.start < this.scrollOffset) {
                if (true && this.options.debug) {
                  console.info('correction', measuredItemSize - itemSize);
                }

                if (!this.destinationOffset) {
                  this._scrollToOffset(this.scrollOffset + (measuredItemSize - itemSize), false);
                }
              }

              this.pendingMeasuredCacheIndexes.push(index);
              this.itemMeasurementsCache = _extends({}, this.itemMeasurementsCache, {
                [item.key]: measuredItemSize
              });
              this.notify();
            }
          };

          const virtualItems = [];
          const currentMeasureElements = {};

          for (let k = 0, len = indexes.length; k < len; k++) {
            var _this$measureElementC;

            const i = indexes[k];
            const measurement = measurements[i];
            const item = _extends({}, measurement, {
              measureElement: currentMeasureElements[i] = (_this$measureElementC = this.measureElementCache[i]) != null ? _this$measureElementC : makeMeasureElement(i)
            });
            virtualItems.push(item);
          }

          this.measureElementCache = currentMeasureElements;
          return virtualItems;
        }, {
          key: true && 'getIndexes',
          debug: () => this.options.debug
        });

        this.scrollToOffset = function (toOffset, _temp) {
          let {
            align = 'start',
            smoothScroll = _this.options.enableSmoothScroll
          } = _temp === void 0 ? {} : _temp;
          const offset = _this.scrollOffset;

          const size = _this.getSize();

          if (align === 'auto') {
            if (toOffset <= offset) {
              align = 'start';
            } else if (toOffset >= offset + size) {
              align = 'end';
            } else {
              align = 'start';
            }
          }

          if (align === 'start') {
            _this._scrollToOffset(toOffset, smoothScroll);
          } else if (align === 'end') {
            _this._scrollToOffset(toOffset - size, smoothScroll);
          } else if (align === 'center') {
            _this._scrollToOffset(toOffset - size / 2, smoothScroll);
          }
        };

        this.scrollToIndex = function (index, _temp2) {
          let _ref3 = _temp2 === void 0 ? {} : _temp2,
              {
            align = 'auto',
            smoothScroll = _this.options.enableSmoothScroll
          } = _ref3,
              rest = _objectWithoutProperties(_ref3, ['align', 'smoothScroll']);

          const measurements = _this.getMeasurements();

          const offset = _this.scrollOffset;

          const size = _this.getSize();

          const {
            count
          } = _this.options;
          const measurement = measurements[Math.max(0, Math.min(index, count - 1))];

          if (!measurement) {
            return;
          }

          if (align === 'auto') {
            if (measurement.end >= offset + size - _this.options.scrollPaddingEnd) {
              align = 'end';
            } else if (measurement.start <= offset + _this.options.scrollPaddingStart) {
              align = 'start';
            } else {
              return;
            }
          }

          const toOffset = align === 'end' ? measurement.end + _this.options.scrollPaddingEnd : measurement.start - _this.options.scrollPaddingStart;

          _this.scrollToOffset(toOffset, _extends({
            align,
            smoothScroll
          }, rest));
        };

        this.getTotalSize = () => {
          var _this$getMeasurements;

          return (((_this$getMeasurements = this.getMeasurements()[this.options.count - 1]) == null ? void 0 : _this$getMeasurements.end) || this.options.paddingStart) + this.options.paddingEnd;
        };

        this._scrollToOffset = (offset, canSmooth) => {
          clearTimeout(this.scrollCheckFrame);
          this.destinationOffset = offset;
          this.options.scrollToFn(offset, canSmooth, this);
          let scrollCheckFrame;

          const check = () => {
            let lastOffset = this.scrollOffset;
            this.scrollCheckFrame = scrollCheckFrame = setTimeout(() => {
              if (this.scrollCheckFrame !== scrollCheckFrame) {
                return;
              }

              if (this.scrollOffset === lastOffset) {
                this.destinationOffset = undefined;
                return;
              }

              lastOffset = this.scrollOffset;
              check();
            }, 100);
          };

          check();
        };

        this.measure = () => {
          this.itemMeasurementsCache = {};
          this.notify();
        };

        this.setOptions(_opts);
        this.scrollRect = this.options.initialRect;
        this.scrollOffset = this.options.initialOffset;
        this.calculateRange();
      }

    }

    const findNearestBinarySearch = (low, high, getCurrentValue, value) => {
      while (low <= high) {
        const middle = (low + high) / 2 | 0;
        const currentValue = getCurrentValue(middle);

        if (currentValue < value) {
          low = middle + 1;
        } else if (currentValue > value) {
          high = middle - 1;
        } else {
          return middle;
        }
      }

      if (low > 0) {
        return low - 1;
      } else {
        return 0;
      }
    };

    function calculateRange(_ref2) {
      let {
        measurements,
        outerSize,
        scrollOffset
      } = _ref2;
      const count = measurements.length - 1;

      const startIndex = findNearestBinarySearch(0, count, index => measurements[index].start, scrollOffset);
      let endIndex = startIndex;

      while (endIndex < count && measurements[endIndex].end < scrollOffset + outerSize) {
        endIndex++;
      }

      return {
        startIndex,
        endIndex
      };
    }

    exports.Virtualizer = Virtualizer;
    exports.defaultKeyExtractor = defaultKeyExtractor;
    exports.defaultRangeExtractor = defaultRangeExtractor;
    exports.elementScroll = elementScroll;
    exports.measureElement = measureElement;
    exports.memo = memo;
    exports.observeElementOffset = observeElementOffset;
    exports.observeElementRect = observeElementRect;
    exports.observeWindowOffset = observeWindowOffset;
    exports.observeWindowRect = observeWindowRect;
    exports.windowScroll = windowScroll;
    //# sourceMappingURL=index.js.map
  }
});
//# sourceMappingURL=index.js.map