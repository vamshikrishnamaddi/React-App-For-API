Liferay.Loader.define("@my-react-app$tanstack/react-virtual@3.0.0-beta.18/build/umd/index.production", ['module', 'exports', 'require', 'my-react-app$react'], function (module, exports, require) {
  var define = undefined;
  var global = window;
  {
    function _objectWithoutProperties(obj, keys) {
      var target = {};

      for (var i in obj) {
        if (keys.indexOf(i) >= 0) continue;
        if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
        target[i] = obj[i];
      }

      return target;
    }

    var _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    /**
     * react-virtual
     *
     * Copyright (c) TanStack
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     */
    !function (e, t) {
      "object" == typeof exports && "undefined" != typeof module ? t(exports, require("my-react-app$react")) : "function" == typeof define && define.amd ? define(["exports", "react"], t) : t((e = "undefined" != typeof globalThis ? globalThis : e || self).ReactVirtual = {}, e.React);
    }(this, function (e, t) {
      "use strict";
      var n = function s(e) {
        if (e && e.__esModule) return e;var t = Object.create(null);return e && Object.keys(e).forEach(function (s) {
          if ("default" !== s) {
            var n = Object.getOwnPropertyDescriptor(e, s);Object.defineProperty(t, s, n.get ? n : { enumerable: !0, get: function () {
                return e[s];
              } });
          }
        }), t.default = e, Object.freeze(t);
      }(t);
      /**
         * virtual-core
         *
         * Copyright (c) TanStack
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE.md file in the root directory of this source tree.
         *
         * @license MIT
         */function o(e, t, s) {
        let n,
            o = [];return () => {
          let i;s.key && null != s.debug && s.debug() && (i = Date.now());const l = e();if (!(l.length !== o.length || l.some((e, t) => o[t] !== e))) return n;let r;if (o = l, s.key && null != s.debug && s.debug() && (r = Date.now()), n = t(...l), null == s || null == s.onChange || s.onChange(n), s.key && null != s.debug && s.debug()) {
            const e = Math.round(100 * (Date.now() - i)) / 100,
                  t = Math.round(100 * (Date.now() - r)) / 100,
                  o = (e, t) => {
              for (e = String(e); e.length < t;) e = " " + e;return e;
            };console.info("%c⏱ " + o(t, 5) + " /" + o(e, 5) + " ms", "\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(" + Math.max(0, Math.min(120 - 120 * (t / 16), 120)) + "deg 100% 31%);", null == s ? void 0 : s.key);
          }return n;
        };
      }const i = e => e,
            l = e => {
        const t = Math.max(e.startIndex - e.overscan, 0),
              s = Math.min(e.endIndex + e.overscan, e.count - 1),
              n = [];for (let e = t; e <= s; e++) n.push(e);return n;
      },
            r = (e, t) => {
        const s = new ResizeObserver(e => {
          var s, n;t({ width: null == (s = e[0]) ? void 0 : s.contentRect.width, height: null == (n = e[0]) ? void 0 : n.contentRect.height });
        });if (e.scrollElement) return t(e.scrollElement.getBoundingClientRect()), s.observe(e.scrollElement), () => {
          s.unobserve(e.scrollElement);
        };
      },
            c = (e, t) => {
        const s = ((e, t) => {
          let s = { height: -1, width: -1 };return n => {
            (e.options.horizontal ? n.width !== s.width : n.height !== s.height) && t(n), s = n;
          };
        })(e, t),
              n = () => s({ width: e.scrollElement.innerWidth, height: e.scrollElement.innerHeight });if (e.scrollElement) return n(), e.scrollElement.addEventListener("resize", n, { capture: !1, passive: !0 }), () => {
          e.scrollElement.removeEventListener("resize", n);
        };
      },
            a = { element: ["scrollLeft", "scrollTop"], window: ["scrollX", "scrollY"] },
            h = e => (t, s) => {
        if (!t.scrollElement) return;const n = a[e][0],
              o = a[e][1];let i = t.scrollElement[n],
            l = t.scrollElement[o];const r = () => {
          s(t.scrollElement[t.options.horizontal ? n : o]);
        };r();const c = e => {
          const s = e.currentTarget,
                c = s[n],
                a = s[o];(t.options.horizontal ? i - c : l - a) && r(), i = c, l = a;
        };return t.scrollElement.addEventListener("scroll", c, { capture: !1, passive: !0 }), () => {
          t.scrollElement.removeEventListener("scroll", c);
        };
      },
            u = h("element"),
            d = h("window"),
            f = (e, t) => e.getBoundingClientRect()[t.options.horizontal ? "width" : "height"],
            m = (e, t, s) => {
        var n;null == (n = s.scrollElement) || null == n.scrollTo || n.scrollTo({ [s.options.horizontal ? "left" : "top"]: e, behavior: t ? "smooth" : void 0 });
      },
            g = (e, t, s) => {
        var n;null == (n = s.scrollElement) || null == n.scrollTo || n.scrollTo({ [s.options.horizontal ? "left" : "top"]: e, behavior: t ? "smooth" : void 0 });
      };class p {
        constructor(e) {
          var t = this;this.unsubs = [], this.scrollElement = null, this.measurementsCache = [], this.itemMeasurementsCache = {}, this.pendingMeasuredCacheIndexes = [], this.measureElementCache = {}, this.range = { startIndex: 0, endIndex: 0 }, this.setOptions = e => {
            Object.entries(e).forEach(t => {
              let [s, n] = t;void 0 === n && delete e[s];
            }), this.options = _extends({ debug: !1, initialOffset: 0, overscan: 1, paddingStart: 0, paddingEnd: 0, scrollPaddingStart: 0, scrollPaddingEnd: 0, horizontal: !1, getItemKey: i, rangeExtractor: l, enableSmoothScroll: !0, onChange: () => {}, measureElement: f, initialRect: { width: 0, height: 0 } }, e);
          }, this.notify = () => {
            var e, t;null == (e = (t = this.options).onChange) || e.call(t, this);
          }, this.cleanup = () => {
            this.unsubs.filter(Boolean).forEach(e => e()), this.unsubs = [], this.scrollElement = null;
          }, this._didMount = () => () => {
            this.cleanup();
          }, this._willUpdate = () => {
            const e = this.options.getScrollElement();this.scrollElement !== e && (this.cleanup(), this.scrollElement = e, this._scrollToOffset(this.scrollOffset, !1), this.unsubs.push(this.options.observeElementRect(this, e => {
              this.scrollRect = e, this.calculateRange();
            })), this.unsubs.push(this.options.observeElementOffset(this, e => {
              this.scrollOffset = e, this.calculateRange();
            })));
          }, this.getSize = () => this.scrollRect[this.options.horizontal ? "width" : "height"], this.getMeasurements = o(() => [this.options.count, this.options.paddingStart, this.options.getItemKey, this.itemMeasurementsCache], (e, t, s, n) => {
            const o = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;this.pendingMeasuredCacheIndexes = [];const i = this.measurementsCache.slice(0, o);for (let l = o; l < e; l++) {
              const e = s(l),
                    o = n[e],
                    r = i[l - 1] ? i[l - 1].end : t,
                    c = "number" == typeof o ? o : this.options.estimateSize(l);i[l] = { index: l, start: r, size: c, end: r + c, key: e };
            }return this.measurementsCache = i, i;
          }, { key: !1, debug: () => this.options.debug }), this.calculateRange = o(() => [this.getMeasurements(), this.getSize(), this.scrollOffset], (e, t, s) => {
            const n = function (e) {
              let { measurements: t, outerSize: s, scrollOffset: n } = e;const o = t.length - 1,
                    i = ((e, t, s, n) => {
                for (; e <= t;) {
                  const o = (e + t) / 2 | 0,
                        i = s(o);if (i < n) e = o + 1;else {
                    if (!(i > n)) return o;t = o - 1;
                  }
                }return e > 0 ? e - 1 : 0;
              })(0, o, e => t[e].start, n);let l = i;for (; l < o && t[l].end < n + s;) l++;return { startIndex: i, endIndex: l };
            }({ measurements: e, outerSize: t, scrollOffset: s });return n.startIndex === this.range.startIndex && n.endIndex === this.range.endIndex || (this.range = n, this.notify()), this.range;
          }, { key: !1, debug: () => this.options.debug }), this.getIndexes = o(() => [this.options.rangeExtractor, this.range, this.options.overscan, this.options.count], (e, t, s, n) => e(_extends({}, t, { overscan: s, count: n })), { key: !1, debug: () => this.options.debug }), this.getVirtualItems = o(() => [this.getIndexes(), this.getMeasurements(), this.options.measureElement], (e, t, s) => {
            const n = e => t => {
              var n;const o = this.measurementsCache[e];if (!t) return;const i = s(t, this),
                    l = null != (n = this.itemMeasurementsCache[o.key]) ? n : o.size;i !== l && (o.start < this.scrollOffset && (this.destinationOffset || this._scrollToOffset(this.scrollOffset + (i - l), !1)), this.pendingMeasuredCacheIndexes.push(e), this.itemMeasurementsCache = _extends({}, this.itemMeasurementsCache, { [o.key]: i }), this.notify());
            },
                  o = [],
                  i = {};for (let s = 0, r = e.length; s < r; s++) {
              var l;const r = e[s],
                    c = _extends({}, t[r], { measureElement: i[r] = null != (l = this.measureElementCache[r]) ? l : n(r) });o.push(c);
            }return this.measureElementCache = i, o;
          }, { key: !1, debug: () => this.options.debug }), this.scrollToOffset = function (e, s) {
            let { align: n = "start", smoothScroll: o = t.options.enableSmoothScroll } = void 0 === s ? {} : s;const i = t.scrollOffset,
                  l = t.getSize();"auto" === n && (n = e <= i ? "start" : e >= i + l ? "end" : "start"), "start" === n ? t._scrollToOffset(e, o) : "end" === n ? t._scrollToOffset(e - l, o) : "center" === n && t._scrollToOffset(e - l / 2, o);
          }, this.scrollToIndex = function (e, s) {
            let _ref = void 0 === s ? {} : s,
                { align: n = "auto", smoothScroll: o = t.options.enableSmoothScroll } = _ref,
                i = _objectWithoutProperties(_ref, ["align", "smoothScroll"]);const l = t.getMeasurements(),
                  r = t.scrollOffset,
                  c = t.getSize(),
                  { count: a } = t.options,
                  h = l[Math.max(0, Math.min(e, a - 1))];if (!h) return;if ("auto" === n) if (h.end >= r + c - t.options.scrollPaddingEnd) n = "end";else {
              if (!(h.start <= r + t.options.scrollPaddingStart)) return;n = "start";
            }const u = "end" === n ? h.end + t.options.scrollPaddingEnd : h.start - t.options.scrollPaddingStart;t.scrollToOffset(u, _extends({ align: n, smoothScroll: o }, i));
          }, this.getTotalSize = () => {
            var e;return ((null == (e = this.getMeasurements()[this.options.count - 1]) ? void 0 : e.end) || this.options.paddingStart) + this.options.paddingEnd;
          }, this._scrollToOffset = (e, t) => {
            let s;clearTimeout(this.scrollCheckFrame), this.destinationOffset = e, this.options.scrollToFn(e, t, this);const n = () => {
              let e = this.scrollOffset;this.scrollCheckFrame = s = setTimeout(() => {
                this.scrollCheckFrame === s && (this.scrollOffset !== e ? (e = this.scrollOffset, n()) : this.destinationOffset = void 0);
              }, 100);
            };n();
          }, this.measure = () => {
            this.itemMeasurementsCache = {}, this.notify();
          }, this.setOptions(e), this.scrollRect = this.options.initialRect, this.scrollOffset = this.options.initialOffset, this.calculateRange();
        }
      }const E = "undefined" != typeof window ? n.useLayoutEffect : n.useEffect;function b(e) {
        const t = n.useReducer(() => ({}), {})[1],
              s = _extends({}, e, { onChange: s => {
            t(), null == e.onChange || e.onChange(s);
          } }),
              [o] = n.useState(() => new p(s));return o.setOptions(s), n.useEffect(() => o._didMount(), []), E(() => o._willUpdate()), o;
      }e.Virtualizer = p, e.defaultKeyExtractor = i, e.defaultRangeExtractor = l, e.elementScroll = g, e.measureElement = f, e.memo = o, e.observeElementOffset = u, e.observeElementRect = r, e.observeWindowOffset = d, e.observeWindowRect = c, e.useVirtualizer = function (e) {
        return b(_extends({ observeElementRect: r, observeElementOffset: u, scrollToFn: g }, e));
      }, e.useWindowVirtualizer = function (e) {
        return b(_extends({ getScrollElement: () => "undefined" != typeof window ? window : null, observeElementRect: c, observeElementOffset: d, scrollToFn: m }, e));
      }, e.windowScroll = m, Object.defineProperty(e, "__esModule", { value: !0 });
    });
    //# sourceMappingURL=index.production.js.map
  }
});
//# sourceMappingURL=index.production.js.map