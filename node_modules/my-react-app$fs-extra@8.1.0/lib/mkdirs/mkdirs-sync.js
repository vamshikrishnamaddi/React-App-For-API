'use strict';

Liferay.Loader.define('my-react-app$fs-extra@8.1.0/lib/mkdirs/mkdirs-sync', ['module', 'exports', 'require', 'my-react-app$graceful-fs', 'my-react-app$path', './win32'], function (module, exports, require) {
  var define = undefined;
  var global = window;
  {
    const fs = require('my-react-app$graceful-fs');
    const path = require('my-react-app$path');
    const invalidWin32Path = require('./win32').invalidWin32Path;

    const o777 = parseInt('0777', 8);

    function mkdirsSync(p, opts, made) {
      if (!opts || typeof opts !== 'object') {
        opts = { mode: opts };
      }

      let mode = opts.mode;
      const xfs = opts.fs || fs;

      if (process.platform === 'win32' && invalidWin32Path(p)) {
        const errInval = new Error(p + ' contains invalid WIN32 path characters.');
        errInval.code = 'EINVAL';
        throw errInval;
      }

      if (mode === undefined) {
        mode = o777 & ~process.umask();
      }
      if (!made) made = null;

      p = path.resolve(p);

      try {
        xfs.mkdirSync(p, mode);
        made = made || p;
      } catch (err0) {
        if (err0.code === 'ENOENT') {
          if (path.dirname(p) === p) throw err0;
          made = mkdirsSync(path.dirname(p), opts, made);
          mkdirsSync(p, opts, made);
        } else {
          // In the case of any other error, just see if there's a dir there
          // already. If so, then hooray!  If not, then something is borked.
          let stat;
          try {
            stat = xfs.statSync(p);
          } catch (err1) {
            throw err0;
          }
          if (!stat.isDirectory()) throw err0;
        }
      }

      return made;
    }

    module.exports = mkdirsSync;
  }
});
//# sourceMappingURL=mkdirs-sync.js.map