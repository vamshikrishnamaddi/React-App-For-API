{"version":3,"sources":["rimraf.js"],"names":["fs","require","path","assert","isWindows","process","platform","defaults","options","forEach","m","maxBusyTries","rimraf","p","cb","busyTries","strictEqual","rimraf_","CB","er","code","time","setTimeout","lstat","st","fixWinEPERM","isDirectory","rmdir","unlink","Error","chmod","er2","stat","er3","stats","fixWinEPERMSync","chmodSync","statSync","rmdirSync","unlinkSync","originalEr","rmkids","readdir","files","n","length","errState","f","join","rimrafSync","lstatSync","rmkidsSync","readdirSync","startTime","Date","now","ret","module","exports","sync"],"mappings":"AAAA;;;;;;AAEA,UAAMA,KAAKC,QAAQ,0BAAR,CAAX;AACA,UAAMC,OAAOD,QAAQ,mBAAR,CAAb;AACA,UAAME,SAASF,QAAQ,qBAAR,CAAf;;AAEA,UAAMG,YAAaC,QAAQC,QAAR,KAAqB,OAAxC;;AAEA,aAASC,QAAT,CAAmBC,OAAnB,EAA4B;AACV,OACd,QADc,EAEd,OAFc,EAGd,MAHc,EAId,OAJc,EAKd,OALc,EAMd,SANc,CAQhB,CAAQC,OAAR,CAAgBC,KAAK;AACnBF,gBAAQE,CAAR,IAAaF,QAAQE,CAAR,KAAcV,GAAGU,CAAH,CAA3B;AACAA,YAAIA,IAAI,MAAR;AACAF,gBAAQE,CAAR,IAAaF,QAAQE,CAAR,KAAcV,GAAGU,CAAH,CAA3B;AACD,OAJD;;AAMAF,cAAQG,YAAR,GAAuBH,QAAQG,YAAR,IAAwB,CAA/C;AACD;;AAED,aAASC,MAAT,CAAiBC,CAAjB,EAAoBL,OAApB,EAA6BM,EAA7B,EAAiC;AAC/B,UAAIC,YAAY,CAAhB;;AAEA,UAAI,OAAOP,OAAP,KAAmB,UAAvB,EAAmC;AACjCM,aAAKN,OAAL;AACAA,kBAAU,EAAV;AACD;;AAEDL,aAAOU,CAAP,EAAU,sBAAV;AACAV,aAAOa,WAAP,CAAmB,OAAOH,CAA1B,EAA6B,QAA7B,EAAuC,iCAAvC;AACAV,aAAOa,WAAP,CAAmB,OAAOF,EAA1B,EAA8B,UAA9B,EAA0C,oCAA1C;AACAX,aAAOK,OAAP,EAAgB,2CAAhB;AACAL,aAAOa,WAAP,CAAmB,OAAOR,OAA1B,EAAmC,QAAnC,EAA6C,kCAA7C;;AAEAD,eAASC,OAAT;;AAEAS,cAAQJ,CAAR,EAAWL,OAAX,EAAoB,SAASU,EAAT,CAAaC,EAAb,EAAiB;AACnC,YAAIA,EAAJ,EAAQ;AACN,cAAI,CAACA,GAAGC,IAAH,KAAY,OAAZ,IAAuBD,GAAGC,IAAH,KAAY,WAAnC,IAAkDD,GAAGC,IAAH,KAAY,OAA/D,KACAL,YAAYP,QAAQG,YADxB,EACsC;AACpCI;AACA,kBAAMM,OAAON,YAAY,GAAzB;AACA;AACA,mBAAOO,WAAW,MAAML,QAAQJ,CAAR,EAAWL,OAAX,EAAoBU,EAApB,CAAjB,EAA0CG,IAA1C,CAAP;AACD;;AAED;AACA,cAAIF,GAAGC,IAAH,KAAY,QAAhB,EAA0BD,KAAK,IAAL;AAC3B;;AAEDL,WAAGK,EAAH;AACD,OAfD;AAgBD;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAASF,OAAT,CAAkBJ,CAAlB,EAAqBL,OAArB,EAA8BM,EAA9B,EAAkC;AAChCX,aAAOU,CAAP;AACAV,aAAOK,OAAP;AACAL,aAAO,OAAOW,EAAP,KAAc,UAArB;;AAEA;AACA;AACAN,cAAQe,KAAR,CAAcV,CAAd,EAAiB,CAACM,EAAD,EAAKK,EAAL,KAAY;AAC3B,YAAIL,MAAMA,GAAGC,IAAH,KAAY,QAAtB,EAAgC;AAC9B,iBAAON,GAAG,IAAH,CAAP;AACD;;AAED;AACA,YAAIK,MAAMA,GAAGC,IAAH,KAAY,OAAlB,IAA6BhB,SAAjC,EAA4C;AAC1C,iBAAOqB,YAAYZ,CAAZ,EAAeL,OAAf,EAAwBW,EAAxB,EAA4BL,EAA5B,CAAP;AACD;;AAED,YAAIU,MAAMA,GAAGE,WAAH,EAAV,EAA4B;AAC1B,iBAAOC,MAAMd,CAAN,EAASL,OAAT,EAAkBW,EAAlB,EAAsBL,EAAtB,CAAP;AACD;;AAEDN,gBAAQoB,MAAR,CAAef,CAAf,EAAkBM,MAAM;AACtB,cAAIA,EAAJ,EAAQ;AACN,gBAAIA,GAAGC,IAAH,KAAY,QAAhB,EAA0B;AACxB,qBAAON,GAAG,IAAH,CAAP;AACD;AACD,gBAAIK,GAAGC,IAAH,KAAY,OAAhB,EAAyB;AACvB,qBAAQhB,SAAD,GACHqB,YAAYZ,CAAZ,EAAeL,OAAf,EAAwBW,EAAxB,EAA4BL,EAA5B,CADG,GAEHa,MAAMd,CAAN,EAASL,OAAT,EAAkBW,EAAlB,EAAsBL,EAAtB,CAFJ;AAGD;AACD,gBAAIK,GAAGC,IAAH,KAAY,QAAhB,EAA0B;AACxB,qBAAOO,MAAMd,CAAN,EAASL,OAAT,EAAkBW,EAAlB,EAAsBL,EAAtB,CAAP;AACD;AACF;AACD,iBAAOA,GAAGK,EAAH,CAAP;AACD,SAfD;AAgBD,OA9BD;AA+BD;;AAED,aAASM,WAAT,CAAsBZ,CAAtB,EAAyBL,OAAzB,EAAkCW,EAAlC,EAAsCL,EAAtC,EAA0C;AACxCX,aAAOU,CAAP;AACAV,aAAOK,OAAP;AACAL,aAAO,OAAOW,EAAP,KAAc,UAArB;AACA,UAAIK,EAAJ,EAAQ;AACNhB,eAAOgB,cAAcU,KAArB;AACD;;AAEDrB,cAAQsB,KAAR,CAAcjB,CAAd,EAAiB,KAAjB,EAAwBkB,OAAO;AAC7B,YAAIA,GAAJ,EAAS;AACPjB,aAAGiB,IAAIX,IAAJ,KAAa,QAAb,GAAwB,IAAxB,GAA+BD,EAAlC;AACD,SAFD,MAEO;AACLX,kBAAQwB,IAAR,CAAanB,CAAb,EAAgB,CAACoB,GAAD,EAAMC,KAAN,KAAgB;AAC9B,gBAAID,GAAJ,EAAS;AACPnB,iBAAGmB,IAAIb,IAAJ,KAAa,QAAb,GAAwB,IAAxB,GAA+BD,EAAlC;AACD,aAFD,MAEO,IAAIe,MAAMR,WAAN,EAAJ,EAAyB;AAC9BC,oBAAMd,CAAN,EAASL,OAAT,EAAkBW,EAAlB,EAAsBL,EAAtB;AACD,aAFM,MAEA;AACLN,sBAAQoB,MAAR,CAAef,CAAf,EAAkBC,EAAlB;AACD;AACF,WARD;AASD;AACF,OAdD;AAeD;;AAED,aAASqB,eAAT,CAA0BtB,CAA1B,EAA6BL,OAA7B,EAAsCW,EAAtC,EAA0C;AACxC,UAAIe,KAAJ;;AAEA/B,aAAOU,CAAP;AACAV,aAAOK,OAAP;AACA,UAAIW,EAAJ,EAAQ;AACNhB,eAAOgB,cAAcU,KAArB;AACD;;AAED,UAAI;AACFrB,gBAAQ4B,SAAR,CAAkBvB,CAAlB,EAAqB,KAArB;AACD,OAFD,CAEE,OAAOkB,GAAP,EAAY;AACZ,YAAIA,IAAIX,IAAJ,KAAa,QAAjB,EAA2B;AACzB;AACD,SAFD,MAEO;AACL,gBAAMD,EAAN;AACD;AACF;;AAED,UAAI;AACFe,gBAAQ1B,QAAQ6B,QAAR,CAAiBxB,CAAjB,CAAR;AACD,OAFD,CAEE,OAAOoB,GAAP,EAAY;AACZ,YAAIA,IAAIb,IAAJ,KAAa,QAAjB,EAA2B;AACzB;AACD,SAFD,MAEO;AACL,gBAAMD,EAAN;AACD;AACF;;AAED,UAAIe,MAAMR,WAAN,EAAJ,EAAyB;AACvBY,kBAAUzB,CAAV,EAAaL,OAAb,EAAsBW,EAAtB;AACD,OAFD,MAEO;AACLX,gBAAQ+B,UAAR,CAAmB1B,CAAnB;AACD;AACF;;AAED,aAASc,KAAT,CAAgBd,CAAhB,EAAmBL,OAAnB,EAA4BgC,UAA5B,EAAwC1B,EAAxC,EAA4C;AAC1CX,aAAOU,CAAP;AACAV,aAAOK,OAAP;AACA,UAAIgC,UAAJ,EAAgB;AACdrC,eAAOqC,sBAAsBX,KAA7B;AACD;AACD1B,aAAO,OAAOW,EAAP,KAAc,UAArB;;AAEA;AACA;AACA;AACAN,cAAQmB,KAAR,CAAcd,CAAd,EAAiBM,MAAM;AACrB,YAAIA,OAAOA,GAAGC,IAAH,KAAY,WAAZ,IAA2BD,GAAGC,IAAH,KAAY,QAAvC,IAAmDD,GAAGC,IAAH,KAAY,OAAtE,CAAJ,EAAoF;AAClFqB,iBAAO5B,CAAP,EAAUL,OAAV,EAAmBM,EAAnB;AACD,SAFD,MAEO,IAAIK,MAAMA,GAAGC,IAAH,KAAY,SAAtB,EAAiC;AACtCN,aAAG0B,UAAH;AACD,SAFM,MAEA;AACL1B,aAAGK,EAAH;AACD;AACF,OARD;AASD;;AAED,aAASsB,MAAT,CAAiB5B,CAAjB,EAAoBL,OAApB,EAA6BM,EAA7B,EAAiC;AAC/BX,aAAOU,CAAP;AACAV,aAAOK,OAAP;AACAL,aAAO,OAAOW,EAAP,KAAc,UAArB;;AAEAN,cAAQkC,OAAR,CAAgB7B,CAAhB,EAAmB,CAACM,EAAD,EAAKwB,KAAL,KAAe;AAChC,YAAIxB,EAAJ,EAAQ,OAAOL,GAAGK,EAAH,CAAP;;AAER,YAAIyB,IAAID,MAAME,MAAd;AACA,YAAIC,QAAJ;;AAEA,YAAIF,MAAM,CAAV,EAAa,OAAOpC,QAAQmB,KAAR,CAAcd,CAAd,EAAiBC,EAAjB,CAAP;;AAEb6B,cAAMlC,OAAN,CAAcsC,KAAK;AACjBnC,iBAAOV,KAAK8C,IAAL,CAAUnC,CAAV,EAAakC,CAAb,CAAP,EAAwBvC,OAAxB,EAAiCW,MAAM;AACrC,gBAAI2B,QAAJ,EAAc;AACZ;AACD;AACD,gBAAI3B,EAAJ,EAAQ,OAAOL,GAAGgC,WAAW3B,EAAd,CAAP;AACR,gBAAI,EAAEyB,CAAF,KAAQ,CAAZ,EAAe;AACbpC,sBAAQmB,KAAR,CAAcd,CAAd,EAAiBC,EAAjB;AACD;AACF,WARD;AASD,SAVD;AAWD,OAnBD;AAoBD;;AAED;AACA;AACA;AACA,aAASmC,UAAT,CAAqBpC,CAArB,EAAwBL,OAAxB,EAAiC;AAC/B,UAAIgB,EAAJ;;AAEAhB,gBAAUA,WAAW,EAArB;AACAD,eAASC,OAAT;;AAEAL,aAAOU,CAAP,EAAU,sBAAV;AACAV,aAAOa,WAAP,CAAmB,OAAOH,CAA1B,EAA6B,QAA7B,EAAuC,iCAAvC;AACAV,aAAOK,OAAP,EAAgB,yBAAhB;AACAL,aAAOa,WAAP,CAAmB,OAAOR,OAA1B,EAAmC,QAAnC,EAA6C,kCAA7C;;AAEA,UAAI;AACFgB,aAAKhB,QAAQ0C,SAAR,CAAkBrC,CAAlB,CAAL;AACD,OAFD,CAEE,OAAOM,EAAP,EAAW;AACX,YAAIA,GAAGC,IAAH,KAAY,QAAhB,EAA0B;AACxB;AACD;;AAED;AACA,YAAID,GAAGC,IAAH,KAAY,OAAZ,IAAuBhB,SAA3B,EAAsC;AACpC+B,0BAAgBtB,CAAhB,EAAmBL,OAAnB,EAA4BW,EAA5B;AACD;AACF;;AAED,UAAI;AACF;AACA,YAAIK,MAAMA,GAAGE,WAAH,EAAV,EAA4B;AAC1BY,oBAAUzB,CAAV,EAAaL,OAAb,EAAsB,IAAtB;AACD,SAFD,MAEO;AACLA,kBAAQ+B,UAAR,CAAmB1B,CAAnB;AACD;AACF,OAPD,CAOE,OAAOM,EAAP,EAAW;AACX,YAAIA,GAAGC,IAAH,KAAY,QAAhB,EAA0B;AACxB;AACD,SAFD,MAEO,IAAID,GAAGC,IAAH,KAAY,OAAhB,EAAyB;AAC9B,iBAAOhB,YAAY+B,gBAAgBtB,CAAhB,EAAmBL,OAAnB,EAA4BW,EAA5B,CAAZ,GAA8CmB,UAAUzB,CAAV,EAAaL,OAAb,EAAsBW,EAAtB,CAArD;AACD,SAFM,MAEA,IAAIA,GAAGC,IAAH,KAAY,QAAhB,EAA0B;AAC/B,gBAAMD,EAAN;AACD;AACDmB,kBAAUzB,CAAV,EAAaL,OAAb,EAAsBW,EAAtB;AACD;AACF;;AAED,aAASmB,SAAT,CAAoBzB,CAApB,EAAuBL,OAAvB,EAAgCgC,UAAhC,EAA4C;AAC1CrC,aAAOU,CAAP;AACAV,aAAOK,OAAP;AACA,UAAIgC,UAAJ,EAAgB;AACdrC,eAAOqC,sBAAsBX,KAA7B;AACD;;AAED,UAAI;AACFrB,gBAAQ8B,SAAR,CAAkBzB,CAAlB;AACD,OAFD,CAEE,OAAOM,EAAP,EAAW;AACX,YAAIA,GAAGC,IAAH,KAAY,SAAhB,EAA2B;AACzB,gBAAMoB,UAAN;AACD,SAFD,MAEO,IAAIrB,GAAGC,IAAH,KAAY,WAAZ,IAA2BD,GAAGC,IAAH,KAAY,QAAvC,IAAmDD,GAAGC,IAAH,KAAY,OAAnE,EAA4E;AACjF+B,qBAAWtC,CAAX,EAAcL,OAAd;AACD,SAFM,MAEA,IAAIW,GAAGC,IAAH,KAAY,QAAhB,EAA0B;AAC/B,gBAAMD,EAAN;AACD;AACF;AACF;;AAED,aAASgC,UAAT,CAAqBtC,CAArB,EAAwBL,OAAxB,EAAiC;AAC/BL,aAAOU,CAAP;AACAV,aAAOK,OAAP;AACAA,cAAQ4C,WAAR,CAAoBvC,CAApB,EAAuBJ,OAAvB,CAA+BsC,KAAKE,WAAW/C,KAAK8C,IAAL,CAAUnC,CAAV,EAAakC,CAAb,CAAX,EAA4BvC,OAA5B,CAApC;;AAEA,UAAIJ,SAAJ,EAAe;AACb;AACA;AACA;AACA;AACA;AACA;AACA,cAAMiD,YAAYC,KAAKC,GAAL,EAAlB;AACA,WAAG;AACD,cAAI;AACF,kBAAMC,MAAMhD,QAAQ8B,SAAR,CAAkBzB,CAAlB,EAAqBL,OAArB,CAAZ;AACA,mBAAOgD,GAAP;AACD,WAHD,CAGE,OAAOrC,EAAP,EAAW,CAAG;AACjB,SALD,QAKSmC,KAAKC,GAAL,KAAaF,SAAb,GAAyB,GALlC,EARa,CAa0B;AACxC,OAdD,MAcO;AACL,cAAMG,MAAMhD,QAAQ8B,SAAR,CAAkBzB,CAAlB,EAAqBL,OAArB,CAAZ;AACA,eAAOgD,GAAP;AACD;AACF;;AAEDC,WAAOC,OAAP,GAAiB9C,MAAjB;AACAA,WAAO+C,IAAP,GAAcV,UAAd","file":"rimraf.js","sourcesContent":["'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst assert = require('assert')\n\nconst isWindows = (process.platform === 'win32')\n\nfunction defaults (options) {\n  const methods = [\n    'unlink',\n    'chmod',\n    'stat',\n    'lstat',\n    'rmdir',\n    'readdir'\n  ]\n  methods.forEach(m => {\n    options[m] = options[m] || fs[m]\n    m = m + 'Sync'\n    options[m] = options[m] || fs[m]\n  })\n\n  options.maxBusyTries = options.maxBusyTries || 3\n}\n\nfunction rimraf (p, options, cb) {\n  let busyTries = 0\n\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  assert(p, 'rimraf: missing path')\n  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')\n  assert.strictEqual(typeof cb, 'function', 'rimraf: callback function required')\n  assert(options, 'rimraf: invalid options argument provided')\n  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')\n\n  defaults(options)\n\n  rimraf_(p, options, function CB (er) {\n    if (er) {\n      if ((er.code === 'EBUSY' || er.code === 'ENOTEMPTY' || er.code === 'EPERM') &&\n          busyTries < options.maxBusyTries) {\n        busyTries++\n        const time = busyTries * 100\n        // try again, with the same exact callback as this one.\n        return setTimeout(() => rimraf_(p, options, CB), time)\n      }\n\n      // already gone\n      if (er.code === 'ENOENT') er = null\n    }\n\n    cb(er)\n  })\n}\n\n// Two possible strategies.\n// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR\n// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR\n//\n// Both result in an extra syscall when you guess wrong.  However, there\n// are likely far more normal files in the world than directories.  This\n// is based on the assumption that a the average number of files per\n// directory is >= 1.\n//\n// If anyone ever complains about this, then I guess the strategy could\n// be made configurable somehow.  But until then, YAGNI.\nfunction rimraf_ (p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  // sunos lets the root user unlink directories, which is... weird.\n  // so we have to lstat here and make sure it's not a dir.\n  options.lstat(p, (er, st) => {\n    if (er && er.code === 'ENOENT') {\n      return cb(null)\n    }\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er && er.code === 'EPERM' && isWindows) {\n      return fixWinEPERM(p, options, er, cb)\n    }\n\n    if (st && st.isDirectory()) {\n      return rmdir(p, options, er, cb)\n    }\n\n    options.unlink(p, er => {\n      if (er) {\n        if (er.code === 'ENOENT') {\n          return cb(null)\n        }\n        if (er.code === 'EPERM') {\n          return (isWindows)\n            ? fixWinEPERM(p, options, er, cb)\n            : rmdir(p, options, er, cb)\n        }\n        if (er.code === 'EISDIR') {\n          return rmdir(p, options, er, cb)\n        }\n      }\n      return cb(er)\n    })\n  })\n}\n\nfunction fixWinEPERM (p, options, er, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n  if (er) {\n    assert(er instanceof Error)\n  }\n\n  options.chmod(p, 0o666, er2 => {\n    if (er2) {\n      cb(er2.code === 'ENOENT' ? null : er)\n    } else {\n      options.stat(p, (er3, stats) => {\n        if (er3) {\n          cb(er3.code === 'ENOENT' ? null : er)\n        } else if (stats.isDirectory()) {\n          rmdir(p, options, er, cb)\n        } else {\n          options.unlink(p, cb)\n        }\n      })\n    }\n  })\n}\n\nfunction fixWinEPERMSync (p, options, er) {\n  let stats\n\n  assert(p)\n  assert(options)\n  if (er) {\n    assert(er instanceof Error)\n  }\n\n  try {\n    options.chmodSync(p, 0o666)\n  } catch (er2) {\n    if (er2.code === 'ENOENT') {\n      return\n    } else {\n      throw er\n    }\n  }\n\n  try {\n    stats = options.statSync(p)\n  } catch (er3) {\n    if (er3.code === 'ENOENT') {\n      return\n    } else {\n      throw er\n    }\n  }\n\n  if (stats.isDirectory()) {\n    rmdirSync(p, options, er)\n  } else {\n    options.unlinkSync(p)\n  }\n}\n\nfunction rmdir (p, options, originalEr, cb) {\n  assert(p)\n  assert(options)\n  if (originalEr) {\n    assert(originalEr instanceof Error)\n  }\n  assert(typeof cb === 'function')\n\n  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)\n  // if we guessed wrong, and it's not a directory, then\n  // raise the original error.\n  options.rmdir(p, er => {\n    if (er && (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM')) {\n      rmkids(p, options, cb)\n    } else if (er && er.code === 'ENOTDIR') {\n      cb(originalEr)\n    } else {\n      cb(er)\n    }\n  })\n}\n\nfunction rmkids (p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  options.readdir(p, (er, files) => {\n    if (er) return cb(er)\n\n    let n = files.length\n    let errState\n\n    if (n === 0) return options.rmdir(p, cb)\n\n    files.forEach(f => {\n      rimraf(path.join(p, f), options, er => {\n        if (errState) {\n          return\n        }\n        if (er) return cb(errState = er)\n        if (--n === 0) {\n          options.rmdir(p, cb)\n        }\n      })\n    })\n  })\n}\n\n// this looks simpler, and is strictly *faster*, but will\n// tie up the JavaScript thread and fail on excessively\n// deep directory trees.\nfunction rimrafSync (p, options) {\n  let st\n\n  options = options || {}\n  defaults(options)\n\n  assert(p, 'rimraf: missing path')\n  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')\n  assert(options, 'rimraf: missing options')\n  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')\n\n  try {\n    st = options.lstatSync(p)\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      return\n    }\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er.code === 'EPERM' && isWindows) {\n      fixWinEPERMSync(p, options, er)\n    }\n  }\n\n  try {\n    // sunos lets the root user unlink directories, which is... weird.\n    if (st && st.isDirectory()) {\n      rmdirSync(p, options, null)\n    } else {\n      options.unlinkSync(p)\n    }\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      return\n    } else if (er.code === 'EPERM') {\n      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)\n    } else if (er.code !== 'EISDIR') {\n      throw er\n    }\n    rmdirSync(p, options, er)\n  }\n}\n\nfunction rmdirSync (p, options, originalEr) {\n  assert(p)\n  assert(options)\n  if (originalEr) {\n    assert(originalEr instanceof Error)\n  }\n\n  try {\n    options.rmdirSync(p)\n  } catch (er) {\n    if (er.code === 'ENOTDIR') {\n      throw originalEr\n    } else if (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM') {\n      rmkidsSync(p, options)\n    } else if (er.code !== 'ENOENT') {\n      throw er\n    }\n  }\n}\n\nfunction rmkidsSync (p, options) {\n  assert(p)\n  assert(options)\n  options.readdirSync(p).forEach(f => rimrafSync(path.join(p, f), options))\n\n  if (isWindows) {\n    // We only end up here once we got ENOTEMPTY at least once, and\n    // at this point, we are guaranteed to have removed all the kids.\n    // So, we know that it won't be ENOENT or ENOTDIR or anything else.\n    // try really hard to delete stuff on windows, because it has a\n    // PROFOUNDLY annoying habit of not closing handles promptly when\n    // files are deleted, resulting in spurious ENOTEMPTY errors.\n    const startTime = Date.now()\n    do {\n      try {\n        const ret = options.rmdirSync(p, options)\n        return ret\n      } catch (er) { }\n    } while (Date.now() - startTime < 500) // give up after 500ms\n  } else {\n    const ret = options.rmdirSync(p, options)\n    return ret\n  }\n}\n\nmodule.exports = rimraf\nrimraf.sync = rimrafSync\n"]}