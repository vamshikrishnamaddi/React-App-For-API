{"version":3,"sources":["auto.js"],"names":["Object","defineProperty","exports","value","default","auto","_once","require","_once2","_interopRequireDefault","_onlyOnce","_onlyOnce2","_wrapAsync","_wrapAsync2","_promiseCallback","obj","__esModule","tasks","concurrency","callback","promiseCallback","numTasks","keys","length","results","runningTasks","canceled","hasError","listeners","create","readyTasks","readyToCheck","uncheckedDependencies","forEach","key","task","Array","isArray","enqueueTask","push","dependencies","slice","remainingDependencies","dependencyName","Error","join","addListener","checkForDeadlocks","currentTask","counter","pop","getDependents","dependent","processQueue","runTask","run","shift","taskName","fn","taskListeners","taskComplete","taskCallback","err","result","safeResults","rkey","taskFn","indexOf","PROMISE_SYMBOL","module"],"mappings":"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","file":"auto.js","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = auto;\n\nvar _once = require('./internal/once.js');\n\nvar _once2 = _interopRequireDefault(_once);\n\nvar _onlyOnce = require('./internal/onlyOnce.js');\n\nvar _onlyOnce2 = _interopRequireDefault(_onlyOnce);\n\nvar _wrapAsync = require('./internal/wrapAsync.js');\n\nvar _wrapAsync2 = _interopRequireDefault(_wrapAsync);\n\nvar _promiseCallback = require('./internal/promiseCallback.js');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Determines the best order for running the {@link AsyncFunction}s in `tasks`, based on\n * their requirements. Each function can optionally depend on other functions\n * being completed first, and each function is run as soon as its requirements\n * are satisfied.\n *\n * If any of the {@link AsyncFunction}s pass an error to their callback, the `auto` sequence\n * will stop. Further tasks will not execute (so any other functions depending\n * on it will not run), and the main `callback` is immediately called with the\n * error.\n *\n * {@link AsyncFunction}s also receive an object containing the results of functions which\n * have completed so far as the first argument, if they have dependencies. If a\n * task function has no dependencies, it will only be passed a callback.\n *\n * @name auto\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Object} tasks - An object. Each of its properties is either a\n * function or an array of requirements, with the {@link AsyncFunction} itself the last item\n * in the array. The object's key of a property serves as the name of the task\n * defined by that property, i.e. can be used when specifying requirements for\n * other tasks. The function receives one or two arguments:\n * * a `results` object, containing the results of the previously executed\n *   functions, only passed if the task has any dependencies,\n * * a `callback(err, result)` function, which must be called when finished,\n *   passing an `error` (which can be `null`) and the result of the function's\n *   execution.\n * @param {number} [concurrency=Infinity] - An optional `integer` for\n * determining the maximum number of tasks that can be run in parallel. By\n * default, as many as possible.\n * @param {Function} [callback] - An optional callback which is called when all\n * the tasks have been completed. It receives the `err` argument if any `tasks`\n * pass an error to their callback. Results are always returned; however, if an\n * error occurs, no further `tasks` will be performed, and the results object\n * will only contain partial results. Invoked with (err, results).\n * @returns {Promise} a promise, if a callback is not passed\n * @example\n *\n * //Using Callbacks\n * async.auto({\n *     get_data: function(callback) {\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: ['get_data', 'make_folder', function(results, callback) {\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(results, callback) {\n *         // once the file is written let's email a link to it...\n *         callback(null, {'file':results.write_file, 'email':'user@example.com'});\n *     }]\n * }, function(err, results) {\n *     if (err) {\n *         console.log('err = ', err);\n *     }\n *     console.log('results = ', results);\n *     // results = {\n *     //     get_data: ['data', 'converted to array']\n *     //     make_folder; 'folder',\n *     //     write_file: 'filename'\n *     //     email_link: { file: 'filename', email: 'user@example.com' }\n *     // }\n * });\n *\n * //Using Promises\n * async.auto({\n *     get_data: function(callback) {\n *         console.log('in get_data');\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         console.log('in make_folder');\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: ['get_data', 'make_folder', function(results, callback) {\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(results, callback) {\n *         // once the file is written let's email a link to it...\n *         callback(null, {'file':results.write_file, 'email':'user@example.com'});\n *     }]\n * }).then(results => {\n *     console.log('results = ', results);\n *     // results = {\n *     //     get_data: ['data', 'converted to array']\n *     //     make_folder; 'folder',\n *     //     write_file: 'filename'\n *     //     email_link: { file: 'filename', email: 'user@example.com' }\n *     // }\n * }).catch(err => {\n *     console.log('err = ', err);\n * });\n *\n * //Using async/await\n * async () => {\n *     try {\n *         let results = await async.auto({\n *             get_data: function(callback) {\n *                 // async code to get some data\n *                 callback(null, 'data', 'converted to array');\n *             },\n *             make_folder: function(callback) {\n *                 // async code to create a directory to store a file in\n *                 // this is run at the same time as getting the data\n *                 callback(null, 'folder');\n *             },\n *             write_file: ['get_data', 'make_folder', function(results, callback) {\n *                 // once there is some data and the directory exists,\n *                 // write the data to a file in the directory\n *                 callback(null, 'filename');\n *             }],\n *             email_link: ['write_file', function(results, callback) {\n *                 // once the file is written let's email a link to it...\n *                 callback(null, {'file':results.write_file, 'email':'user@example.com'});\n *             }]\n *         });\n *         console.log('results = ', results);\n *         // results = {\n *         //     get_data: ['data', 'converted to array']\n *         //     make_folder; 'folder',\n *         //     write_file: 'filename'\n *         //     email_link: { file: 'filename', email: 'user@example.com' }\n *         // }\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n */\nfunction auto(tasks, concurrency, callback) {\n    if (typeof concurrency !== 'number') {\n        // concurrency is optional, shift the args.\n        callback = concurrency;\n        concurrency = null;\n    }\n    callback = (0, _once2.default)(callback || (0, _promiseCallback.promiseCallback)());\n    var numTasks = Object.keys(tasks).length;\n    if (!numTasks) {\n        return callback(null);\n    }\n    if (!concurrency) {\n        concurrency = numTasks;\n    }\n\n    var results = {};\n    var runningTasks = 0;\n    var canceled = false;\n    var hasError = false;\n\n    var listeners = Object.create(null);\n\n    var readyTasks = [];\n\n    // for cycle detection:\n    var readyToCheck = []; // tasks that have been identified as reachable\n    // without the possibility of returning to an ancestor task\n    var uncheckedDependencies = {};\n\n    Object.keys(tasks).forEach(key => {\n        var task = tasks[key];\n        if (!Array.isArray(task)) {\n            // no dependencies\n            enqueueTask(key, [task]);\n            readyToCheck.push(key);\n            return;\n        }\n\n        var dependencies = task.slice(0, task.length - 1);\n        var remainingDependencies = dependencies.length;\n        if (remainingDependencies === 0) {\n            enqueueTask(key, task);\n            readyToCheck.push(key);\n            return;\n        }\n        uncheckedDependencies[key] = remainingDependencies;\n\n        dependencies.forEach(dependencyName => {\n            if (!tasks[dependencyName]) {\n                throw new Error('async.auto task `' + key + '` has a non-existent dependency `' + dependencyName + '` in ' + dependencies.join(', '));\n            }\n            addListener(dependencyName, () => {\n                remainingDependencies--;\n                if (remainingDependencies === 0) {\n                    enqueueTask(key, task);\n                }\n            });\n        });\n    });\n\n    checkForDeadlocks();\n    processQueue();\n\n    function enqueueTask(key, task) {\n        readyTasks.push(() => runTask(key, task));\n    }\n\n    function processQueue() {\n        if (canceled) return;\n        if (readyTasks.length === 0 && runningTasks === 0) {\n            return callback(null, results);\n        }\n        while (readyTasks.length && runningTasks < concurrency) {\n            var run = readyTasks.shift();\n            run();\n        }\n    }\n\n    function addListener(taskName, fn) {\n        var taskListeners = listeners[taskName];\n        if (!taskListeners) {\n            taskListeners = listeners[taskName] = [];\n        }\n\n        taskListeners.push(fn);\n    }\n\n    function taskComplete(taskName) {\n        var taskListeners = listeners[taskName] || [];\n        taskListeners.forEach(fn => fn());\n        processQueue();\n    }\n\n    function runTask(key, task) {\n        if (hasError) return;\n\n        var taskCallback = (0, _onlyOnce2.default)((err, ...result) => {\n            runningTasks--;\n            if (err === false) {\n                canceled = true;\n                return;\n            }\n            if (result.length < 2) {\n                [result] = result;\n            }\n            if (err) {\n                var safeResults = {};\n                Object.keys(results).forEach(rkey => {\n                    safeResults[rkey] = results[rkey];\n                });\n                safeResults[key] = result;\n                hasError = true;\n                listeners = Object.create(null);\n                if (canceled) return;\n                callback(err, safeResults);\n            } else {\n                results[key] = result;\n                taskComplete(key);\n            }\n        });\n\n        runningTasks++;\n        var taskFn = (0, _wrapAsync2.default)(task[task.length - 1]);\n        if (task.length > 1) {\n            taskFn(results, taskCallback);\n        } else {\n            taskFn(taskCallback);\n        }\n    }\n\n    function checkForDeadlocks() {\n        // Kahn's algorithm\n        // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm\n        // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html\n        var currentTask;\n        var counter = 0;\n        while (readyToCheck.length) {\n            currentTask = readyToCheck.pop();\n            counter++;\n            getDependents(currentTask).forEach(dependent => {\n                if (--uncheckedDependencies[dependent] === 0) {\n                    readyToCheck.push(dependent);\n                }\n            });\n        }\n\n        if (counter !== numTasks) {\n            throw new Error('async.auto cannot execute tasks due to a recursive dependency');\n        }\n    }\n\n    function getDependents(taskName) {\n        var result = [];\n        Object.keys(tasks).forEach(key => {\n            const task = tasks[key];\n            if (Array.isArray(task) && task.indexOf(taskName) >= 0) {\n                result.push(key);\n            }\n        });\n        return result;\n    }\n\n    return callback[_promiseCallback.PROMISE_SYMBOL];\n}\nmodule.exports = exports['default'];"]}