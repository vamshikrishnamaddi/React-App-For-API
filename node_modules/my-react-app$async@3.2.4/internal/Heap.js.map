{"version":3,"sources":["Heap.js"],"names":["Object","defineProperty","exports","value","Heap","constructor","heap","pushCount","Number","MIN_SAFE_INTEGER","length","empty","percUp","index","p","smaller","parent","t","percDown","l","leftChi","push","node","unshift","shift","top","pop","toArray","Symbol","iterator","i","data","remove","testFn","j","splice","default","x","y","priority","module"],"mappings":"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","file":"Heap.js","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n// Binary min-heap implementation used for priority queue.\n// Implementation is stable, i.e. push time is considered for equal priorities\nclass Heap {\n    constructor() {\n        this.heap = [];\n        this.pushCount = Number.MIN_SAFE_INTEGER;\n    }\n\n    get length() {\n        return this.heap.length;\n    }\n\n    empty() {\n        this.heap = [];\n        return this;\n    }\n\n    percUp(index) {\n        let p;\n\n        while (index > 0 && smaller(this.heap[index], this.heap[p = parent(index)])) {\n            let t = this.heap[index];\n            this.heap[index] = this.heap[p];\n            this.heap[p] = t;\n\n            index = p;\n        }\n    }\n\n    percDown(index) {\n        let l;\n\n        while ((l = leftChi(index)) < this.heap.length) {\n            if (l + 1 < this.heap.length && smaller(this.heap[l + 1], this.heap[l])) {\n                l = l + 1;\n            }\n\n            if (smaller(this.heap[index], this.heap[l])) {\n                break;\n            }\n\n            let t = this.heap[index];\n            this.heap[index] = this.heap[l];\n            this.heap[l] = t;\n\n            index = l;\n        }\n    }\n\n    push(node) {\n        node.pushCount = ++this.pushCount;\n        this.heap.push(node);\n        this.percUp(this.heap.length - 1);\n    }\n\n    unshift(node) {\n        return this.heap.push(node);\n    }\n\n    shift() {\n        let [top] = this.heap;\n\n        this.heap[0] = this.heap[this.heap.length - 1];\n        this.heap.pop();\n        this.percDown(0);\n\n        return top;\n    }\n\n    toArray() {\n        return [...this];\n    }\n\n    *[Symbol.iterator]() {\n        for (let i = 0; i < this.heap.length; i++) {\n            yield this.heap[i].data;\n        }\n    }\n\n    remove(testFn) {\n        let j = 0;\n        for (let i = 0; i < this.heap.length; i++) {\n            if (!testFn(this.heap[i])) {\n                this.heap[j] = this.heap[i];\n                j++;\n            }\n        }\n\n        this.heap.splice(j);\n\n        for (let i = parent(this.heap.length - 1); i >= 0; i--) {\n            this.percDown(i);\n        }\n\n        return this;\n    }\n}\n\nexports.default = Heap;\nfunction leftChi(i) {\n    return (i << 1) + 1;\n}\n\nfunction parent(i) {\n    return (i + 1 >> 1) - 1;\n}\n\nfunction smaller(x, y) {\n    if (x.priority !== y.priority) {\n        return x.priority < y.priority;\n    } else {\n        return x.pushCount < y.pushCount;\n    }\n}\nmodule.exports = exports[\"default\"];"]}