{"version":3,"sources":["async.js"],"names":["global","factory","exports","module","define","amd","async","apply","fn","args","callArgs","initialParams","callback","pop","call","hasQueueMicrotask","queueMicrotask","hasSetImmediate","setImmediate","hasNextTick","process","nextTick","fallback","setTimeout","wrap","defer","_defer","setImmediate$1","asyncify","func","isAsync","promise","handlePromise","result","e","then","value","invokeCallback","err","message","Error","error","Symbol","toStringTag","isAsyncGenerator","isAsyncIterable","obj","asyncIterator","wrapAsync","asyncFn","awaitify","arity","length","awaitable","Promise","resolve","reject","cbArgs","applyEach","eachfn","fns","go","that","cb","concat","_asyncMap","arr","iteratee","results","counter","_iteratee","_","iterCb","index","v","isArrayLike","breakLoop","once","wrapper","callFn","Object","assign","getIterator","coll","iterator","createArrayIterator","i","len","next","key","createES2015Iterator","item","done","createObjectIterator","okeys","keys","createIterator","onlyOnce","asyncEachOfLimit","generator","limit","canceled","awaiting","running","idx","replenish","iterDone","iterateeCallback","catch","handleError","eachOfLimit","RangeError","nextElem","looping","elem","eachOfLimit$2","eachOfLimit$1","eachOfArrayLike","completed","iteratorCallback","eachOfGeneric","Infinity","eachOf$1","eachOf","eachOfImplementation","map$1","map","applyEach$1","eachOfSeries$1","eachOfSeries","mapSeries$1","mapSeries","applyEachSeries","PROMISE_SYMBOL","promiseCallback","res","rej","auto","tasks","concurrency","numTasks","runningTasks","hasError","listeners","create","readyTasks","readyToCheck","uncheckedDependencies","forEach","task","Array","isArray","enqueueTask","push","dependencies","slice","remainingDependencies","dependencyName","join","addListener","checkForDeadlocks","currentTask","getDependents","dependent","processQueue","runTask","run","shift","taskName","taskListeners","taskComplete","taskCallback","safeResults","rkey","taskFn","indexOf","FN_ARGS","ARROW_FN_ARGS","FN_ARG_SPLIT","FN_ARG","stripComments","string","stripped","endBlockComment","endIndex","parseParams","src","toString","match","replace","split","arg","trim","autoInject","newTasks","params","fnIsAsync","hasNoDeps","newTask","taskCb","newArgs","name","DLL","constructor","head","tail","removeLink","node","prev","empty","insertAfter","newNode","insertBefore","unshift","setInitial","toArray","cur","data","remove","testFn","curr","dll","queue","worker","payload","_worker","numRunning","workersList","events","drain","saturated","unsaturated","on","event","handler","handleAndRemove","off","ev","filter","trigger","processingScheduled","_insert","insertAtFront","rejectOnError","q","started","_createTaskItem","_tasks","_createCB","l","splice","buffer","idle","_maybeDrain","eventMethod","isProcessing","paused","datum","pushAsync","kill","unshiftAsync","Math","min","pause","resume","defineProperties","writable","cargo","cargo$1","reduce$1","reduce","memo","x","seq","functions","_functions","newargs","nextargs","compose","reverse","mapLimit$1","mapLimit","concatLimit$1","concatLimit","val","mapResults","concat$1","concatSeries$1","concatSeries","constant","ignoredArgs","_createTester","check","getResult","testPassed","testResult","detect$1","detect","bool","detectLimit$1","detectLimit","detectSeries$1","detectSeries","consoleFunc","resultArgs","console","dir","doWhilst$1","doWhilst","test","_fn","_test","truth","doUntil","_withoutIndex","each","eachLimit","eachLimit$2","eachLimit$1","eachSeries$1","eachSeries","ensureAsync","sync","innerArgs","every$1","every","everyLimit$1","everyLimit","everySeries$1","everySeries","filterArray","truthValues","filterGeneric","sort","a","b","_filter","filter$1","filterLimit$1","filterLimit","filterSeries$1","filterSeries","forever$1","forever","errback","groupByLimit$1","groupByLimit","hasOwnProperty","prototype","groupBy","groupBySeries","log","mapValuesLimit$1","mapValuesLimit","newObj","mapValues","mapValuesSeries","memoize","hasher","queues","memoized","unmemoized","_defer$1","parallel","parallel$1","parallelLimit","queue$1","items","Heap","heap","pushCount","Number","MIN_SAFE_INTEGER","percUp","p","smaller","parent","t","percDown","leftChi","top","j","y","priority","priorityQueue","createDataItems","race$1","race","TypeError","reduceRight","array","reversed","reflect","reflectOn","reflectCallback","retVal","reflectAll","reject$2","reject$1","rejectLimit$1","rejectLimit","rejectSeries$1","rejectSeries","constant$1","DEFAULT_TIMES","DEFAULT_INTERVAL","retry","opts","options","times","intervalFunc","arguments","parseTimes","_task","attempt","retryAttempt","errorFilter","acc","interval","retryable","series","some$1","some","Boolean","someLimit$1","someLimit","someSeries$1","someSeries","sortBy$1","sortBy","criteria","comparator","left","right","timeout","milliseconds","info","timedOut","timer","clearTimeout","timeoutCallback","code","range","size","timesLimit","count","n","timesSeries","transform","accumulator","k","tryEach$1","tryEach","unmemoize","whilst$1","whilst","rest","until","waterfall$1","waterfall","taskIndex","nextTask","default","cargoQueue","all","allLimit","allSeries","any","anyLimit","anySeries","find","findLimit","findSeries","flatMap","flatMapLimit","flatMapSeries","forEachSeries","forEachLimit","forEachOf","forEachOfSeries","forEachOfLimit","inject","foldl","foldr","select","selectLimit","selectSeries","wrapSync","during","doDuring","defineProperty"],"mappings":"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","file":"async.js","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (factory((global.async = {})));\n}(this, (function (exports) { 'use strict';\n\n    /**\n     * Creates a continuation function with some arguments already applied.\n     *\n     * Useful as a shorthand when combined with other control flow functions. Any\n     * arguments passed to the returned function are added to the arguments\n     * originally passed to apply.\n     *\n     * @name apply\n     * @static\n     * @memberOf module:Utils\n     * @method\n     * @category Util\n     * @param {Function} fn - The function you want to eventually apply all\n     * arguments to. Invokes with (arguments...).\n     * @param {...*} arguments... - Any number of arguments to automatically apply\n     * when the continuation is called.\n     * @returns {Function} the partially-applied function\n     * @example\n     *\n     * // using apply\n     * async.parallel([\n     *     async.apply(fs.writeFile, 'testfile1', 'test1'),\n     *     async.apply(fs.writeFile, 'testfile2', 'test2')\n     * ]);\n     *\n     *\n     * // the same process without using apply\n     * async.parallel([\n     *     function(callback) {\n     *         fs.writeFile('testfile1', 'test1', callback);\n     *     },\n     *     function(callback) {\n     *         fs.writeFile('testfile2', 'test2', callback);\n     *     }\n     * ]);\n     *\n     * // It's possible to pass any number of additional arguments when calling the\n     * // continuation:\n     *\n     * node> var fn = async.apply(sys.puts, 'one');\n     * node> fn('two', 'three');\n     * one\n     * two\n     * three\n     */\n    function apply(fn, ...args) {\n        return (...callArgs) => fn(...args,...callArgs);\n    }\n\n    function initialParams (fn) {\n        return function (...args/*, callback*/) {\n            var callback = args.pop();\n            return fn.call(this, args, callback);\n        };\n    }\n\n    /* istanbul ignore file */\n\n    var hasQueueMicrotask = typeof queueMicrotask === 'function' && queueMicrotask;\n    var hasSetImmediate = typeof setImmediate === 'function' && setImmediate;\n    var hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';\n\n    function fallback(fn) {\n        setTimeout(fn, 0);\n    }\n\n    function wrap(defer) {\n        return (fn, ...args) => defer(() => fn(...args));\n    }\n\n    var _defer;\n\n    if (hasQueueMicrotask) {\n        _defer = queueMicrotask;\n    } else if (hasSetImmediate) {\n        _defer = setImmediate;\n    } else if (hasNextTick) {\n        _defer = process.nextTick;\n    } else {\n        _defer = fallback;\n    }\n\n    var setImmediate$1 = wrap(_defer);\n\n    /**\n     * Take a sync function and make it async, passing its return value to a\n     * callback. This is useful for plugging sync functions into a waterfall,\n     * series, or other async functions. Any arguments passed to the generated\n     * function will be passed to the wrapped function (except for the final\n     * callback argument). Errors thrown will be passed to the callback.\n     *\n     * If the function passed to `asyncify` returns a Promise, that promises's\n     * resolved/rejected state will be used to call the callback, rather than simply\n     * the synchronous return value.\n     *\n     * This also means you can asyncify ES2017 `async` functions.\n     *\n     * @name asyncify\n     * @static\n     * @memberOf module:Utils\n     * @method\n     * @alias wrapSync\n     * @category Util\n     * @param {Function} func - The synchronous function, or Promise-returning\n     * function to convert to an {@link AsyncFunction}.\n     * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be\n     * invoked with `(args..., callback)`.\n     * @example\n     *\n     * // passing a regular synchronous function\n     * async.waterfall([\n     *     async.apply(fs.readFile, filename, \"utf8\"),\n     *     async.asyncify(JSON.parse),\n     *     function (data, next) {\n     *         // data is the result of parsing the text.\n     *         // If there was a parsing error, it would have been caught.\n     *     }\n     * ], callback);\n     *\n     * // passing a function returning a promise\n     * async.waterfall([\n     *     async.apply(fs.readFile, filename, \"utf8\"),\n     *     async.asyncify(function (contents) {\n     *         return db.model.create(contents);\n     *     }),\n     *     function (model, next) {\n     *         // `model` is the instantiated model object.\n     *         // If there was an error, this function would be skipped.\n     *     }\n     * ], callback);\n     *\n     * // es2017 example, though `asyncify` is not needed if your JS environment\n     * // supports async functions out of the box\n     * var q = async.queue(async.asyncify(async function(file) {\n     *     var intermediateStep = await processFile(file);\n     *     return await somePromise(intermediateStep)\n     * }));\n     *\n     * q.push(files);\n     */\n    function asyncify(func) {\n        if (isAsync(func)) {\n            return function (...args/*, callback*/) {\n                const callback = args.pop();\n                const promise = func.apply(this, args);\n                return handlePromise(promise, callback)\n            }\n        }\n\n        return initialParams(function (args, callback) {\n            var result;\n            try {\n                result = func.apply(this, args);\n            } catch (e) {\n                return callback(e);\n            }\n            // if result is Promise object\n            if (result && typeof result.then === 'function') {\n                return handlePromise(result, callback)\n            } else {\n                callback(null, result);\n            }\n        });\n    }\n\n    function handlePromise(promise, callback) {\n        return promise.then(value => {\n            invokeCallback(callback, null, value);\n        }, err => {\n            invokeCallback(callback, err && err.message ? err : new Error(err));\n        });\n    }\n\n    function invokeCallback(callback, error, value) {\n        try {\n            callback(error, value);\n        } catch (err) {\n            setImmediate$1(e => { throw e }, err);\n        }\n    }\n\n    function isAsync(fn) {\n        return fn[Symbol.toStringTag] === 'AsyncFunction';\n    }\n\n    function isAsyncGenerator(fn) {\n        return fn[Symbol.toStringTag] === 'AsyncGenerator';\n    }\n\n    function isAsyncIterable(obj) {\n        return typeof obj[Symbol.asyncIterator] === 'function';\n    }\n\n    function wrapAsync(asyncFn) {\n        if (typeof asyncFn !== 'function') throw new Error('expected a function')\n        return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;\n    }\n\n    // conditionally promisify a function.\n    // only return a promise if a callback is omitted\n    function awaitify (asyncFn, arity = asyncFn.length) {\n        if (!arity) throw new Error('arity is undefined')\n        function awaitable (...args) {\n            if (typeof args[arity - 1] === 'function') {\n                return asyncFn.apply(this, args)\n            }\n\n            return new Promise((resolve, reject) => {\n                args[arity - 1] = (err, ...cbArgs) => {\n                    if (err) return reject(err)\n                    resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);\n                };\n                asyncFn.apply(this, args);\n            })\n        }\n\n        return awaitable\n    }\n\n    function applyEach (eachfn) {\n        return function applyEach(fns, ...callArgs) {\n            const go = awaitify(function (callback) {\n                var that = this;\n                return eachfn(fns, (fn, cb) => {\n                    wrapAsync(fn).apply(that, callArgs.concat(cb));\n                }, callback);\n            });\n            return go;\n        };\n    }\n\n    function _asyncMap(eachfn, arr, iteratee, callback) {\n        arr = arr || [];\n        var results = [];\n        var counter = 0;\n        var _iteratee = wrapAsync(iteratee);\n\n        return eachfn(arr, (value, _, iterCb) => {\n            var index = counter++;\n            _iteratee(value, (err, v) => {\n                results[index] = v;\n                iterCb(err);\n            });\n        }, err => {\n            callback(err, results);\n        });\n    }\n\n    function isArrayLike(value) {\n        return value &&\n            typeof value.length === 'number' &&\n            value.length >= 0 &&\n            value.length % 1 === 0;\n    }\n\n    // A temporary value used to identify if the loop should be broken.\n    // See #1064, #1293\n    const breakLoop = {};\n\n    function once(fn) {\n        function wrapper (...args) {\n            if (fn === null) return;\n            var callFn = fn;\n            fn = null;\n            callFn.apply(this, args);\n        }\n        Object.assign(wrapper, fn);\n        return wrapper\n    }\n\n    function getIterator (coll) {\n        return coll[Symbol.iterator] && coll[Symbol.iterator]();\n    }\n\n    function createArrayIterator(coll) {\n        var i = -1;\n        var len = coll.length;\n        return function next() {\n            return ++i < len ? {value: coll[i], key: i} : null;\n        }\n    }\n\n    function createES2015Iterator(iterator) {\n        var i = -1;\n        return function next() {\n            var item = iterator.next();\n            if (item.done)\n                return null;\n            i++;\n            return {value: item.value, key: i};\n        }\n    }\n\n    function createObjectIterator(obj) {\n        var okeys = obj ? Object.keys(obj) : [];\n        var i = -1;\n        var len = okeys.length;\n        return function next() {\n            var key = okeys[++i];\n            if (key === '__proto__') {\n                return next();\n            }\n            return i < len ? {value: obj[key], key} : null;\n        };\n    }\n\n    function createIterator(coll) {\n        if (isArrayLike(coll)) {\n            return createArrayIterator(coll);\n        }\n\n        var iterator = getIterator(coll);\n        return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);\n    }\n\n    function onlyOnce(fn) {\n        return function (...args) {\n            if (fn === null) throw new Error(\"Callback was already called.\");\n            var callFn = fn;\n            fn = null;\n            callFn.apply(this, args);\n        };\n    }\n\n    // for async generators\n    function asyncEachOfLimit(generator, limit, iteratee, callback) {\n        let done = false;\n        let canceled = false;\n        let awaiting = false;\n        let running = 0;\n        let idx = 0;\n\n        function replenish() {\n            //console.log('replenish')\n            if (running >= limit || awaiting || done) return\n            //console.log('replenish awaiting')\n            awaiting = true;\n            generator.next().then(({value, done: iterDone}) => {\n                //console.log('got value', value)\n                if (canceled || done) return\n                awaiting = false;\n                if (iterDone) {\n                    done = true;\n                    if (running <= 0) {\n                        //console.log('done nextCb')\n                        callback(null);\n                    }\n                    return;\n                }\n                running++;\n                iteratee(value, idx, iterateeCallback);\n                idx++;\n                replenish();\n            }).catch(handleError);\n        }\n\n        function iterateeCallback(err, result) {\n            //console.log('iterateeCallback')\n            running -= 1;\n            if (canceled) return\n            if (err) return handleError(err)\n\n            if (err === false) {\n                done = true;\n                canceled = true;\n                return\n            }\n\n            if (result === breakLoop || (done && running <= 0)) {\n                done = true;\n                //console.log('done iterCb')\n                return callback(null);\n            }\n            replenish();\n        }\n\n        function handleError(err) {\n            if (canceled) return\n            awaiting = false;\n            done = true;\n            callback(err);\n        }\n\n        replenish();\n    }\n\n    var eachOfLimit = (limit) => {\n        return (obj, iteratee, callback) => {\n            callback = once(callback);\n            if (limit <= 0) {\n                throw new RangeError('concurrency limit cannot be less than 1')\n            }\n            if (!obj) {\n                return callback(null);\n            }\n            if (isAsyncGenerator(obj)) {\n                return asyncEachOfLimit(obj, limit, iteratee, callback)\n            }\n            if (isAsyncIterable(obj)) {\n                return asyncEachOfLimit(obj[Symbol.asyncIterator](), limit, iteratee, callback)\n            }\n            var nextElem = createIterator(obj);\n            var done = false;\n            var canceled = false;\n            var running = 0;\n            var looping = false;\n\n            function iterateeCallback(err, value) {\n                if (canceled) return\n                running -= 1;\n                if (err) {\n                    done = true;\n                    callback(err);\n                }\n                else if (err === false) {\n                    done = true;\n                    canceled = true;\n                }\n                else if (value === breakLoop || (done && running <= 0)) {\n                    done = true;\n                    return callback(null);\n                }\n                else if (!looping) {\n                    replenish();\n                }\n            }\n\n            function replenish () {\n                looping = true;\n                while (running < limit && !done) {\n                    var elem = nextElem();\n                    if (elem === null) {\n                        done = true;\n                        if (running <= 0) {\n                            callback(null);\n                        }\n                        return;\n                    }\n                    running += 1;\n                    iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));\n                }\n                looping = false;\n            }\n\n            replenish();\n        };\n    };\n\n    /**\n     * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a\n     * time.\n     *\n     * @name eachOfLimit\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.eachOf]{@link module:Collections.eachOf}\n     * @alias forEachOfLimit\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {number} limit - The maximum number of async operations at a time.\n     * @param {AsyncFunction} iteratee - An async function to apply to each\n     * item in `coll`. The `key` is the item's key, or index in the case of an\n     * array.\n     * Invoked with (item, key, callback).\n     * @param {Function} [callback] - A callback which is called when all\n     * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n     * @returns {Promise} a promise, if a callback is omitted\n     */\n    function eachOfLimit$1(coll, limit, iteratee, callback) {\n        return eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);\n    }\n\n    var eachOfLimit$2 = awaitify(eachOfLimit$1, 4);\n\n    // eachOf implementation optimized for array-likes\n    function eachOfArrayLike(coll, iteratee, callback) {\n        callback = once(callback);\n        var index = 0,\n            completed = 0,\n            {length} = coll,\n            canceled = false;\n        if (length === 0) {\n            callback(null);\n        }\n\n        function iteratorCallback(err, value) {\n            if (err === false) {\n                canceled = true;\n            }\n            if (canceled === true) return\n            if (err) {\n                callback(err);\n            } else if ((++completed === length) || value === breakLoop) {\n                callback(null);\n            }\n        }\n\n        for (; index < length; index++) {\n            iteratee(coll[index], index, onlyOnce(iteratorCallback));\n        }\n    }\n\n    // a generic version of eachOf which can handle array, object, and iterator cases.\n    function eachOfGeneric (coll, iteratee, callback) {\n        return eachOfLimit$2(coll, Infinity, iteratee, callback);\n    }\n\n    /**\n     * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument\n     * to the iteratee.\n     *\n     * @name eachOf\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @alias forEachOf\n     * @category Collection\n     * @see [async.each]{@link module:Collections.each}\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {AsyncFunction} iteratee - A function to apply to each\n     * item in `coll`.\n     * The `key` is the item's key, or index in the case of an array.\n     * Invoked with (item, key, callback).\n     * @param {Function} [callback] - A callback which is called when all\n     * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n     * @returns {Promise} a promise, if a callback is omitted\n     * @example\n     *\n     * // dev.json is a file containing a valid json object config for dev environment\n     * // dev.json is a file containing a valid json object config for test environment\n     * // prod.json is a file containing a valid json object config for prod environment\n     * // invalid.json is a file with a malformed json object\n     *\n     * let configs = {}; //global variable\n     * let validConfigFileMap = {dev: 'dev.json', test: 'test.json', prod: 'prod.json'};\n     * let invalidConfigFileMap = {dev: 'dev.json', test: 'test.json', invalid: 'invalid.json'};\n     *\n     * // asynchronous function that reads a json file and parses the contents as json object\n     * function parseFile(file, key, callback) {\n     *     fs.readFile(file, \"utf8\", function(err, data) {\n     *         if (err) return calback(err);\n     *         try {\n     *             configs[key] = JSON.parse(data);\n     *         } catch (e) {\n     *             return callback(e);\n     *         }\n     *         callback();\n     *     });\n     * }\n     *\n     * // Using callbacks\n     * async.forEachOf(validConfigFileMap, parseFile, function (err) {\n     *     if (err) {\n     *         console.error(err);\n     *     } else {\n     *         console.log(configs);\n     *         // configs is now a map of JSON data, e.g.\n     *         // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}\n     *     }\n     * });\n     *\n     * //Error handing\n     * async.forEachOf(invalidConfigFileMap, parseFile, function (err) {\n     *     if (err) {\n     *         console.error(err);\n     *         // JSON parse error exception\n     *     } else {\n     *         console.log(configs);\n     *     }\n     * });\n     *\n     * // Using Promises\n     * async.forEachOf(validConfigFileMap, parseFile)\n     * .then( () => {\n     *     console.log(configs);\n     *     // configs is now a map of JSON data, e.g.\n     *     // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}\n     * }).catch( err => {\n     *     console.error(err);\n     * });\n     *\n     * //Error handing\n     * async.forEachOf(invalidConfigFileMap, parseFile)\n     * .then( () => {\n     *     console.log(configs);\n     * }).catch( err => {\n     *     console.error(err);\n     *     // JSON parse error exception\n     * });\n     *\n     * // Using async/await\n     * async () => {\n     *     try {\n     *         let result = await async.forEachOf(validConfigFileMap, parseFile);\n     *         console.log(configs);\n     *         // configs is now a map of JSON data, e.g.\n     *         // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *     }\n     * }\n     *\n     * //Error handing\n     * async () => {\n     *     try {\n     *         let result = await async.forEachOf(invalidConfigFileMap, parseFile);\n     *         console.log(configs);\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *         // JSON parse error exception\n     *     }\n     * }\n     *\n     */\n    function eachOf(coll, iteratee, callback) {\n        var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;\n        return eachOfImplementation(coll, wrapAsync(iteratee), callback);\n    }\n\n    var eachOf$1 = awaitify(eachOf, 3);\n\n    /**\n     * Produces a new collection of values by mapping each value in `coll` through\n     * the `iteratee` function. The `iteratee` is called with an item from `coll`\n     * and a callback for when it has finished processing. Each of these callbacks\n     * takes 2 arguments: an `error`, and the transformed item from `coll`. If\n     * `iteratee` passes an error to its callback, the main `callback` (for the\n     * `map` function) is immediately called with the error.\n     *\n     * Note, that since this function applies the `iteratee` to each item in\n     * parallel, there is no guarantee that the `iteratee` functions will complete\n     * in order. However, the results array will be in the same order as the\n     * original `coll`.\n     *\n     * If `map` is passed an Object, the results will be an Array.  The results\n     * will roughly be in the order of the original Objects' keys (but this can\n     * vary across JavaScript engines).\n     *\n     * @name map\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {AsyncFunction} iteratee - An async function to apply to each item in\n     * `coll`.\n     * The iteratee should complete with the transformed item.\n     * Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called when all `iteratee`\n     * functions have finished, or an error occurs. Results is an Array of the\n     * transformed items from the `coll`. Invoked with (err, results).\n     * @returns {Promise} a promise, if no callback is passed\n     * @example\n     *\n     * // file1.txt is a file that is 1000 bytes in size\n     * // file2.txt is a file that is 2000 bytes in size\n     * // file3.txt is a file that is 3000 bytes in size\n     * // file4.txt does not exist\n     *\n     * const fileList = ['file1.txt','file2.txt','file3.txt'];\n     * const withMissingFileList = ['file1.txt','file2.txt','file4.txt'];\n     *\n     * // asynchronous function that returns the file size in bytes\n     * function getFileSizeInBytes(file, callback) {\n     *     fs.stat(file, function(err, stat) {\n     *         if (err) {\n     *             return callback(err);\n     *         }\n     *         callback(null, stat.size);\n     *     });\n     * }\n     *\n     * // Using callbacks\n     * async.map(fileList, getFileSizeInBytes, function(err, results) {\n     *     if (err) {\n     *         console.log(err);\n     *     } else {\n     *         console.log(results);\n     *         // results is now an array of the file size in bytes for each file, e.g.\n     *         // [ 1000, 2000, 3000]\n     *     }\n     * });\n     *\n     * // Error Handling\n     * async.map(withMissingFileList, getFileSizeInBytes, function(err, results) {\n     *     if (err) {\n     *         console.log(err);\n     *         // [ Error: ENOENT: no such file or directory ]\n     *     } else {\n     *         console.log(results);\n     *     }\n     * });\n     *\n     * // Using Promises\n     * async.map(fileList, getFileSizeInBytes)\n     * .then( results => {\n     *     console.log(results);\n     *     // results is now an array of the file size in bytes for each file, e.g.\n     *     // [ 1000, 2000, 3000]\n     * }).catch( err => {\n     *     console.log(err);\n     * });\n     *\n     * // Error Handling\n     * async.map(withMissingFileList, getFileSizeInBytes)\n     * .then( results => {\n     *     console.log(results);\n     * }).catch( err => {\n     *     console.log(err);\n     *     // [ Error: ENOENT: no such file or directory ]\n     * });\n     *\n     * // Using async/await\n     * async () => {\n     *     try {\n     *         let results = await async.map(fileList, getFileSizeInBytes);\n     *         console.log(results);\n     *         // results is now an array of the file size in bytes for each file, e.g.\n     *         // [ 1000, 2000, 3000]\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *     }\n     * }\n     *\n     * // Error Handling\n     * async () => {\n     *     try {\n     *         let results = await async.map(withMissingFileList, getFileSizeInBytes);\n     *         console.log(results);\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *         // [ Error: ENOENT: no such file or directory ]\n     *     }\n     * }\n     *\n     */\n    function map (coll, iteratee, callback) {\n        return _asyncMap(eachOf$1, coll, iteratee, callback)\n    }\n    var map$1 = awaitify(map, 3);\n\n    /**\n     * Applies the provided arguments to each function in the array, calling\n     * `callback` after all functions have completed. If you only provide the first\n     * argument, `fns`, then it will return a function which lets you pass in the\n     * arguments as if it were a single function call. If more arguments are\n     * provided, `callback` is required while `args` is still optional. The results\n     * for each of the applied async functions are passed to the final callback\n     * as an array.\n     *\n     * @name applyEach\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @category Control Flow\n     * @param {Array|Iterable|AsyncIterable|Object} fns - A collection of {@link AsyncFunction}s\n     * to all call with the same arguments\n     * @param {...*} [args] - any number of separate arguments to pass to the\n     * function.\n     * @param {Function} [callback] - the final argument should be the callback,\n     * called when all functions have completed processing.\n     * @returns {AsyncFunction} - Returns a function that takes no args other than\n     * an optional callback, that is the result of applying the `args` to each\n     * of the functions.\n     * @example\n     *\n     * const appliedFn = async.applyEach([enableSearch, updateSchema], 'bucket')\n     *\n     * appliedFn((err, results) => {\n     *     // results[0] is the results for `enableSearch`\n     *     // results[1] is the results for `updateSchema`\n     * });\n     *\n     * // partial application example:\n     * async.each(\n     *     buckets,\n     *     async (bucket) => async.applyEach([enableSearch, updateSchema], bucket)(),\n     *     callback\n     * );\n     */\n    var applyEach$1 = applyEach(map$1);\n\n    /**\n     * The same as [`eachOf`]{@link module:Collections.eachOf} but runs only a single async operation at a time.\n     *\n     * @name eachOfSeries\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.eachOf]{@link module:Collections.eachOf}\n     * @alias forEachOfSeries\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {AsyncFunction} iteratee - An async function to apply to each item in\n     * `coll`.\n     * Invoked with (item, key, callback).\n     * @param {Function} [callback] - A callback which is called when all `iteratee`\n     * functions have finished, or an error occurs. Invoked with (err).\n     * @returns {Promise} a promise, if a callback is omitted\n     */\n    function eachOfSeries(coll, iteratee, callback) {\n        return eachOfLimit$2(coll, 1, iteratee, callback)\n    }\n    var eachOfSeries$1 = awaitify(eachOfSeries, 3);\n\n    /**\n     * The same as [`map`]{@link module:Collections.map} but runs only a single async operation at a time.\n     *\n     * @name mapSeries\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.map]{@link module:Collections.map}\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {AsyncFunction} iteratee - An async function to apply to each item in\n     * `coll`.\n     * The iteratee should complete with the transformed item.\n     * Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called when all `iteratee`\n     * functions have finished, or an error occurs. Results is an array of the\n     * transformed items from the `coll`. Invoked with (err, results).\n     * @returns {Promise} a promise, if no callback is passed\n     */\n    function mapSeries (coll, iteratee, callback) {\n        return _asyncMap(eachOfSeries$1, coll, iteratee, callback)\n    }\n    var mapSeries$1 = awaitify(mapSeries, 3);\n\n    /**\n     * The same as [`applyEach`]{@link module:ControlFlow.applyEach} but runs only a single async operation at a time.\n     *\n     * @name applyEachSeries\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @see [async.applyEach]{@link module:ControlFlow.applyEach}\n     * @category Control Flow\n     * @param {Array|Iterable|AsyncIterable|Object} fns - A collection of {@link AsyncFunction}s to all\n     * call with the same arguments\n     * @param {...*} [args] - any number of separate arguments to pass to the\n     * function.\n     * @param {Function} [callback] - the final argument should be the callback,\n     * called when all functions have completed processing.\n     * @returns {AsyncFunction} - A function, that when called, is the result of\n     * appling the `args` to the list of functions.  It takes no args, other than\n     * a callback.\n     */\n    var applyEachSeries = applyEach(mapSeries$1);\n\n    const PROMISE_SYMBOL = Symbol('promiseCallback');\n\n    function promiseCallback () {\n        let resolve, reject;\n        function callback (err, ...args) {\n            if (err) return reject(err)\n            resolve(args.length > 1 ? args : args[0]);\n        }\n\n        callback[PROMISE_SYMBOL] = new Promise((res, rej) => {\n            resolve = res,\n            reject = rej;\n        });\n\n        return callback\n    }\n\n    /**\n     * Determines the best order for running the {@link AsyncFunction}s in `tasks`, based on\n     * their requirements. Each function can optionally depend on other functions\n     * being completed first, and each function is run as soon as its requirements\n     * are satisfied.\n     *\n     * If any of the {@link AsyncFunction}s pass an error to their callback, the `auto` sequence\n     * will stop. Further tasks will not execute (so any other functions depending\n     * on it will not run), and the main `callback` is immediately called with the\n     * error.\n     *\n     * {@link AsyncFunction}s also receive an object containing the results of functions which\n     * have completed so far as the first argument, if they have dependencies. If a\n     * task function has no dependencies, it will only be passed a callback.\n     *\n     * @name auto\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @category Control Flow\n     * @param {Object} tasks - An object. Each of its properties is either a\n     * function or an array of requirements, with the {@link AsyncFunction} itself the last item\n     * in the array. The object's key of a property serves as the name of the task\n     * defined by that property, i.e. can be used when specifying requirements for\n     * other tasks. The function receives one or two arguments:\n     * * a `results` object, containing the results of the previously executed\n     *   functions, only passed if the task has any dependencies,\n     * * a `callback(err, result)` function, which must be called when finished,\n     *   passing an `error` (which can be `null`) and the result of the function's\n     *   execution.\n     * @param {number} [concurrency=Infinity] - An optional `integer` for\n     * determining the maximum number of tasks that can be run in parallel. By\n     * default, as many as possible.\n     * @param {Function} [callback] - An optional callback which is called when all\n     * the tasks have been completed. It receives the `err` argument if any `tasks`\n     * pass an error to their callback. Results are always returned; however, if an\n     * error occurs, no further `tasks` will be performed, and the results object\n     * will only contain partial results. Invoked with (err, results).\n     * @returns {Promise} a promise, if a callback is not passed\n     * @example\n     *\n     * //Using Callbacks\n     * async.auto({\n     *     get_data: function(callback) {\n     *         // async code to get some data\n     *         callback(null, 'data', 'converted to array');\n     *     },\n     *     make_folder: function(callback) {\n     *         // async code to create a directory to store a file in\n     *         // this is run at the same time as getting the data\n     *         callback(null, 'folder');\n     *     },\n     *     write_file: ['get_data', 'make_folder', function(results, callback) {\n     *         // once there is some data and the directory exists,\n     *         // write the data to a file in the directory\n     *         callback(null, 'filename');\n     *     }],\n     *     email_link: ['write_file', function(results, callback) {\n     *         // once the file is written let's email a link to it...\n     *         callback(null, {'file':results.write_file, 'email':'user@example.com'});\n     *     }]\n     * }, function(err, results) {\n     *     if (err) {\n     *         console.log('err = ', err);\n     *     }\n     *     console.log('results = ', results);\n     *     // results = {\n     *     //     get_data: ['data', 'converted to array']\n     *     //     make_folder; 'folder',\n     *     //     write_file: 'filename'\n     *     //     email_link: { file: 'filename', email: 'user@example.com' }\n     *     // }\n     * });\n     *\n     * //Using Promises\n     * async.auto({\n     *     get_data: function(callback) {\n     *         console.log('in get_data');\n     *         // async code to get some data\n     *         callback(null, 'data', 'converted to array');\n     *     },\n     *     make_folder: function(callback) {\n     *         console.log('in make_folder');\n     *         // async code to create a directory to store a file in\n     *         // this is run at the same time as getting the data\n     *         callback(null, 'folder');\n     *     },\n     *     write_file: ['get_data', 'make_folder', function(results, callback) {\n     *         // once there is some data and the directory exists,\n     *         // write the data to a file in the directory\n     *         callback(null, 'filename');\n     *     }],\n     *     email_link: ['write_file', function(results, callback) {\n     *         // once the file is written let's email a link to it...\n     *         callback(null, {'file':results.write_file, 'email':'user@example.com'});\n     *     }]\n     * }).then(results => {\n     *     console.log('results = ', results);\n     *     // results = {\n     *     //     get_data: ['data', 'converted to array']\n     *     //     make_folder; 'folder',\n     *     //     write_file: 'filename'\n     *     //     email_link: { file: 'filename', email: 'user@example.com' }\n     *     // }\n     * }).catch(err => {\n     *     console.log('err = ', err);\n     * });\n     *\n     * //Using async/await\n     * async () => {\n     *     try {\n     *         let results = await async.auto({\n     *             get_data: function(callback) {\n     *                 // async code to get some data\n     *                 callback(null, 'data', 'converted to array');\n     *             },\n     *             make_folder: function(callback) {\n     *                 // async code to create a directory to store a file in\n     *                 // this is run at the same time as getting the data\n     *                 callback(null, 'folder');\n     *             },\n     *             write_file: ['get_data', 'make_folder', function(results, callback) {\n     *                 // once there is some data and the directory exists,\n     *                 // write the data to a file in the directory\n     *                 callback(null, 'filename');\n     *             }],\n     *             email_link: ['write_file', function(results, callback) {\n     *                 // once the file is written let's email a link to it...\n     *                 callback(null, {'file':results.write_file, 'email':'user@example.com'});\n     *             }]\n     *         });\n     *         console.log('results = ', results);\n     *         // results = {\n     *         //     get_data: ['data', 'converted to array']\n     *         //     make_folder; 'folder',\n     *         //     write_file: 'filename'\n     *         //     email_link: { file: 'filename', email: 'user@example.com' }\n     *         // }\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *     }\n     * }\n     *\n     */\n    function auto(tasks, concurrency, callback) {\n        if (typeof concurrency !== 'number') {\n            // concurrency is optional, shift the args.\n            callback = concurrency;\n            concurrency = null;\n        }\n        callback = once(callback || promiseCallback());\n        var numTasks = Object.keys(tasks).length;\n        if (!numTasks) {\n            return callback(null);\n        }\n        if (!concurrency) {\n            concurrency = numTasks;\n        }\n\n        var results = {};\n        var runningTasks = 0;\n        var canceled = false;\n        var hasError = false;\n\n        var listeners = Object.create(null);\n\n        var readyTasks = [];\n\n        // for cycle detection:\n        var readyToCheck = []; // tasks that have been identified as reachable\n        // without the possibility of returning to an ancestor task\n        var uncheckedDependencies = {};\n\n        Object.keys(tasks).forEach(key => {\n            var task = tasks[key];\n            if (!Array.isArray(task)) {\n                // no dependencies\n                enqueueTask(key, [task]);\n                readyToCheck.push(key);\n                return;\n            }\n\n            var dependencies = task.slice(0, task.length - 1);\n            var remainingDependencies = dependencies.length;\n            if (remainingDependencies === 0) {\n                enqueueTask(key, task);\n                readyToCheck.push(key);\n                return;\n            }\n            uncheckedDependencies[key] = remainingDependencies;\n\n            dependencies.forEach(dependencyName => {\n                if (!tasks[dependencyName]) {\n                    throw new Error('async.auto task `' + key +\n                        '` has a non-existent dependency `' +\n                        dependencyName + '` in ' +\n                        dependencies.join(', '));\n                }\n                addListener(dependencyName, () => {\n                    remainingDependencies--;\n                    if (remainingDependencies === 0) {\n                        enqueueTask(key, task);\n                    }\n                });\n            });\n        });\n\n        checkForDeadlocks();\n        processQueue();\n\n        function enqueueTask(key, task) {\n            readyTasks.push(() => runTask(key, task));\n        }\n\n        function processQueue() {\n            if (canceled) return\n            if (readyTasks.length === 0 && runningTasks === 0) {\n                return callback(null, results);\n            }\n            while(readyTasks.length && runningTasks < concurrency) {\n                var run = readyTasks.shift();\n                run();\n            }\n\n        }\n\n        function addListener(taskName, fn) {\n            var taskListeners = listeners[taskName];\n            if (!taskListeners) {\n                taskListeners = listeners[taskName] = [];\n            }\n\n            taskListeners.push(fn);\n        }\n\n        function taskComplete(taskName) {\n            var taskListeners = listeners[taskName] || [];\n            taskListeners.forEach(fn => fn());\n            processQueue();\n        }\n\n\n        function runTask(key, task) {\n            if (hasError) return;\n\n            var taskCallback = onlyOnce((err, ...result) => {\n                runningTasks--;\n                if (err === false) {\n                    canceled = true;\n                    return\n                }\n                if (result.length < 2) {\n                    [result] = result;\n                }\n                if (err) {\n                    var safeResults = {};\n                    Object.keys(results).forEach(rkey => {\n                        safeResults[rkey] = results[rkey];\n                    });\n                    safeResults[key] = result;\n                    hasError = true;\n                    listeners = Object.create(null);\n                    if (canceled) return\n                    callback(err, safeResults);\n                } else {\n                    results[key] = result;\n                    taskComplete(key);\n                }\n            });\n\n            runningTasks++;\n            var taskFn = wrapAsync(task[task.length - 1]);\n            if (task.length > 1) {\n                taskFn(results, taskCallback);\n            } else {\n                taskFn(taskCallback);\n            }\n        }\n\n        function checkForDeadlocks() {\n            // Kahn's algorithm\n            // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm\n            // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html\n            var currentTask;\n            var counter = 0;\n            while (readyToCheck.length) {\n                currentTask = readyToCheck.pop();\n                counter++;\n                getDependents(currentTask).forEach(dependent => {\n                    if (--uncheckedDependencies[dependent] === 0) {\n                        readyToCheck.push(dependent);\n                    }\n                });\n            }\n\n            if (counter !== numTasks) {\n                throw new Error(\n                    'async.auto cannot execute tasks due to a recursive dependency'\n                );\n            }\n        }\n\n        function getDependents(taskName) {\n            var result = [];\n            Object.keys(tasks).forEach(key => {\n                const task = tasks[key];\n                if (Array.isArray(task) && task.indexOf(taskName) >= 0) {\n                    result.push(key);\n                }\n            });\n            return result;\n        }\n\n        return callback[PROMISE_SYMBOL]\n    }\n\n    var FN_ARGS = /^(?:async\\s+)?(?:function)?\\s*\\w*\\s*\\(\\s*([^)]+)\\s*\\)(?:\\s*{)/;\n    var ARROW_FN_ARGS = /^(?:async\\s+)?\\(?\\s*([^)=]+)\\s*\\)?(?:\\s*=>)/;\n    var FN_ARG_SPLIT = /,/;\n    var FN_ARG = /(=.+)?(\\s*)$/;\n\n    function stripComments(string) {\n        let stripped = '';\n        let index = 0;\n        let endBlockComment = string.indexOf('*/');\n        while (index < string.length) {\n            if (string[index] === '/' && string[index+1] === '/') {\n                // inline comment\n                let endIndex = string.indexOf('\\n', index);\n                index = (endIndex === -1) ? string.length : endIndex;\n            } else if ((endBlockComment !== -1) && (string[index] === '/') && (string[index+1] === '*')) {\n                // block comment\n                let endIndex = string.indexOf('*/', index);\n                if (endIndex !== -1) {\n                    index = endIndex + 2;\n                    endBlockComment = string.indexOf('*/', index);\n                } else {\n                    stripped += string[index];\n                    index++;\n                }\n            } else {\n                stripped += string[index];\n                index++;\n            }\n        }\n        return stripped;\n    }\n\n    function parseParams(func) {\n        const src = stripComments(func.toString());\n        let match = src.match(FN_ARGS);\n        if (!match) {\n            match = src.match(ARROW_FN_ARGS);\n        }\n        if (!match) throw new Error('could not parse args in autoInject\\nSource:\\n' + src)\n        let [, args] = match;\n        return args\n            .replace(/\\s/g, '')\n            .split(FN_ARG_SPLIT)\n            .map((arg) => arg.replace(FN_ARG, '').trim());\n    }\n\n    /**\n     * A dependency-injected version of the [async.auto]{@link module:ControlFlow.auto} function. Dependent\n     * tasks are specified as parameters to the function, after the usual callback\n     * parameter, with the parameter names matching the names of the tasks it\n     * depends on. This can provide even more readable task graphs which can be\n     * easier to maintain.\n     *\n     * If a final callback is specified, the task results are similarly injected,\n     * specified as named parameters after the initial error parameter.\n     *\n     * The autoInject function is purely syntactic sugar and its semantics are\n     * otherwise equivalent to [async.auto]{@link module:ControlFlow.auto}.\n     *\n     * @name autoInject\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @see [async.auto]{@link module:ControlFlow.auto}\n     * @category Control Flow\n     * @param {Object} tasks - An object, each of whose properties is an {@link AsyncFunction} of\n     * the form 'func([dependencies...], callback). The object's key of a property\n     * serves as the name of the task defined by that property, i.e. can be used\n     * when specifying requirements for other tasks.\n     * * The `callback` parameter is a `callback(err, result)` which must be called\n     *   when finished, passing an `error` (which can be `null`) and the result of\n     *   the function's execution. The remaining parameters name other tasks on\n     *   which the task is dependent, and the results from those tasks are the\n     *   arguments of those parameters.\n     * @param {Function} [callback] - An optional callback which is called when all\n     * the tasks have been completed. It receives the `err` argument if any `tasks`\n     * pass an error to their callback, and a `results` object with any completed\n     * task results, similar to `auto`.\n     * @returns {Promise} a promise, if no callback is passed\n     * @example\n     *\n     * //  The example from `auto` can be rewritten as follows:\n     * async.autoInject({\n     *     get_data: function(callback) {\n     *         // async code to get some data\n     *         callback(null, 'data', 'converted to array');\n     *     },\n     *     make_folder: function(callback) {\n     *         // async code to create a directory to store a file in\n     *         // this is run at the same time as getting the data\n     *         callback(null, 'folder');\n     *     },\n     *     write_file: function(get_data, make_folder, callback) {\n     *         // once there is some data and the directory exists,\n     *         // write the data to a file in the directory\n     *         callback(null, 'filename');\n     *     },\n     *     email_link: function(write_file, callback) {\n     *         // once the file is written let's email a link to it...\n     *         // write_file contains the filename returned by write_file.\n     *         callback(null, {'file':write_file, 'email':'user@example.com'});\n     *     }\n     * }, function(err, results) {\n     *     console.log('err = ', err);\n     *     console.log('email_link = ', results.email_link);\n     * });\n     *\n     * // If you are using a JS minifier that mangles parameter names, `autoInject`\n     * // will not work with plain functions, since the parameter names will be\n     * // collapsed to a single letter identifier.  To work around this, you can\n     * // explicitly specify the names of the parameters your task function needs\n     * // in an array, similar to Angular.js dependency injection.\n     *\n     * // This still has an advantage over plain `auto`, since the results a task\n     * // depends on are still spread into arguments.\n     * async.autoInject({\n     *     //...\n     *     write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {\n     *         callback(null, 'filename');\n     *     }],\n     *     email_link: ['write_file', function(write_file, callback) {\n     *         callback(null, {'file':write_file, 'email':'user@example.com'});\n     *     }]\n     *     //...\n     * }, function(err, results) {\n     *     console.log('err = ', err);\n     *     console.log('email_link = ', results.email_link);\n     * });\n     */\n    function autoInject(tasks, callback) {\n        var newTasks = {};\n\n        Object.keys(tasks).forEach(key => {\n            var taskFn = tasks[key];\n            var params;\n            var fnIsAsync = isAsync(taskFn);\n            var hasNoDeps =\n                (!fnIsAsync && taskFn.length === 1) ||\n                (fnIsAsync && taskFn.length === 0);\n\n            if (Array.isArray(taskFn)) {\n                params = [...taskFn];\n                taskFn = params.pop();\n\n                newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);\n            } else if (hasNoDeps) {\n                // no dependencies, use the function as-is\n                newTasks[key] = taskFn;\n            } else {\n                params = parseParams(taskFn);\n                if ((taskFn.length === 0 && !fnIsAsync) && params.length === 0) {\n                    throw new Error(\"autoInject task functions require explicit parameters.\");\n                }\n\n                // remove callback param\n                if (!fnIsAsync) params.pop();\n\n                newTasks[key] = params.concat(newTask);\n            }\n\n            function newTask(results, taskCb) {\n                var newArgs = params.map(name => results[name]);\n                newArgs.push(taskCb);\n                wrapAsync(taskFn)(...newArgs);\n            }\n        });\n\n        return auto(newTasks, callback);\n    }\n\n    // Simple doubly linked list (https://en.wikipedia.org/wiki/Doubly_linked_list) implementation\n    // used for queues. This implementation assumes that the node provided by the user can be modified\n    // to adjust the next and last properties. We implement only the minimal functionality\n    // for queue support.\n    class DLL {\n        constructor() {\n            this.head = this.tail = null;\n            this.length = 0;\n        }\n\n        removeLink(node) {\n            if (node.prev) node.prev.next = node.next;\n            else this.head = node.next;\n            if (node.next) node.next.prev = node.prev;\n            else this.tail = node.prev;\n\n            node.prev = node.next = null;\n            this.length -= 1;\n            return node;\n        }\n\n        empty () {\n            while(this.head) this.shift();\n            return this;\n        }\n\n        insertAfter(node, newNode) {\n            newNode.prev = node;\n            newNode.next = node.next;\n            if (node.next) node.next.prev = newNode;\n            else this.tail = newNode;\n            node.next = newNode;\n            this.length += 1;\n        }\n\n        insertBefore(node, newNode) {\n            newNode.prev = node.prev;\n            newNode.next = node;\n            if (node.prev) node.prev.next = newNode;\n            else this.head = newNode;\n            node.prev = newNode;\n            this.length += 1;\n        }\n\n        unshift(node) {\n            if (this.head) this.insertBefore(this.head, node);\n            else setInitial(this, node);\n        }\n\n        push(node) {\n            if (this.tail) this.insertAfter(this.tail, node);\n            else setInitial(this, node);\n        }\n\n        shift() {\n            return this.head && this.removeLink(this.head);\n        }\n\n        pop() {\n            return this.tail && this.removeLink(this.tail);\n        }\n\n        toArray() {\n            return [...this]\n        }\n\n        *[Symbol.iterator] () {\n            var cur = this.head;\n            while (cur) {\n                yield cur.data;\n                cur = cur.next;\n            }\n        }\n\n        remove (testFn) {\n            var curr = this.head;\n            while(curr) {\n                var {next} = curr;\n                if (testFn(curr)) {\n                    this.removeLink(curr);\n                }\n                curr = next;\n            }\n            return this;\n        }\n    }\n\n    function setInitial(dll, node) {\n        dll.length = 1;\n        dll.head = dll.tail = node;\n    }\n\n    function queue(worker, concurrency, payload) {\n        if (concurrency == null) {\n            concurrency = 1;\n        }\n        else if(concurrency === 0) {\n            throw new RangeError('Concurrency must not be zero');\n        }\n\n        var _worker = wrapAsync(worker);\n        var numRunning = 0;\n        var workersList = [];\n        const events = {\n            error: [],\n            drain: [],\n            saturated: [],\n            unsaturated: [],\n            empty: []\n        };\n\n        function on (event, handler) {\n            events[event].push(handler);\n        }\n\n        function once (event, handler) {\n            const handleAndRemove = (...args) => {\n                off(event, handleAndRemove);\n                handler(...args);\n            };\n            events[event].push(handleAndRemove);\n        }\n\n        function off (event, handler) {\n            if (!event) return Object.keys(events).forEach(ev => events[ev] = [])\n            if (!handler) return events[event] = []\n            events[event] = events[event].filter(ev => ev !== handler);\n        }\n\n        function trigger (event, ...args) {\n            events[event].forEach(handler => handler(...args));\n        }\n\n        var processingScheduled = false;\n        function _insert(data, insertAtFront, rejectOnError, callback) {\n            if (callback != null && typeof callback !== 'function') {\n                throw new Error('task callback must be a function');\n            }\n            q.started = true;\n\n            var res, rej;\n            function promiseCallback (err, ...args) {\n                // we don't care about the error, let the global error handler\n                // deal with it\n                if (err) return rejectOnError ? rej(err) : res()\n                if (args.length <= 1) return res(args[0])\n                res(args);\n            }\n\n            var item = q._createTaskItem(\n                data,\n                rejectOnError ? promiseCallback :\n                    (callback || promiseCallback)\n            );\n\n            if (insertAtFront) {\n                q._tasks.unshift(item);\n            } else {\n                q._tasks.push(item);\n            }\n\n            if (!processingScheduled) {\n                processingScheduled = true;\n                setImmediate$1(() => {\n                    processingScheduled = false;\n                    q.process();\n                });\n            }\n\n            if (rejectOnError || !callback) {\n                return new Promise((resolve, reject) => {\n                    res = resolve;\n                    rej = reject;\n                })\n            }\n        }\n\n        function _createCB(tasks) {\n            return function (err, ...args) {\n                numRunning -= 1;\n\n                for (var i = 0, l = tasks.length; i < l; i++) {\n                    var task = tasks[i];\n\n                    var index = workersList.indexOf(task);\n                    if (index === 0) {\n                        workersList.shift();\n                    } else if (index > 0) {\n                        workersList.splice(index, 1);\n                    }\n\n                    task.callback(err, ...args);\n\n                    if (err != null) {\n                        trigger('error', err, task.data);\n                    }\n                }\n\n                if (numRunning <= (q.concurrency - q.buffer) ) {\n                    trigger('unsaturated');\n                }\n\n                if (q.idle()) {\n                    trigger('drain');\n                }\n                q.process();\n            };\n        }\n\n        function _maybeDrain(data) {\n            if (data.length === 0 && q.idle()) {\n                // call drain immediately if there are no tasks\n                setImmediate$1(() => trigger('drain'));\n                return true\n            }\n            return false\n        }\n\n        const eventMethod = (name) => (handler) => {\n            if (!handler) {\n                return new Promise((resolve, reject) => {\n                    once(name, (err, data) => {\n                        if (err) return reject(err)\n                        resolve(data);\n                    });\n                })\n            }\n            off(name);\n            on(name, handler);\n\n        };\n\n        var isProcessing = false;\n        var q = {\n            _tasks: new DLL(),\n            _createTaskItem (data, callback) {\n                return {\n                    data,\n                    callback\n                };\n            },\n            *[Symbol.iterator] () {\n                yield* q._tasks[Symbol.iterator]();\n            },\n            concurrency,\n            payload,\n            buffer: concurrency / 4,\n            started: false,\n            paused: false,\n            push (data, callback) {\n                if (Array.isArray(data)) {\n                    if (_maybeDrain(data)) return\n                    return data.map(datum => _insert(datum, false, false, callback))\n                }\n                return _insert(data, false, false, callback);\n            },\n            pushAsync (data, callback) {\n                if (Array.isArray(data)) {\n                    if (_maybeDrain(data)) return\n                    return data.map(datum => _insert(datum, false, true, callback))\n                }\n                return _insert(data, false, true, callback);\n            },\n            kill () {\n                off();\n                q._tasks.empty();\n            },\n            unshift (data, callback) {\n                if (Array.isArray(data)) {\n                    if (_maybeDrain(data)) return\n                    return data.map(datum => _insert(datum, true, false, callback))\n                }\n                return _insert(data, true, false, callback);\n            },\n            unshiftAsync (data, callback) {\n                if (Array.isArray(data)) {\n                    if (_maybeDrain(data)) return\n                    return data.map(datum => _insert(datum, true, true, callback))\n                }\n                return _insert(data, true, true, callback);\n            },\n            remove (testFn) {\n                q._tasks.remove(testFn);\n            },\n            process () {\n                // Avoid trying to start too many processing operations. This can occur\n                // when callbacks resolve synchronously (#1267).\n                if (isProcessing) {\n                    return;\n                }\n                isProcessing = true;\n                while(!q.paused && numRunning < q.concurrency && q._tasks.length){\n                    var tasks = [], data = [];\n                    var l = q._tasks.length;\n                    if (q.payload) l = Math.min(l, q.payload);\n                    for (var i = 0; i < l; i++) {\n                        var node = q._tasks.shift();\n                        tasks.push(node);\n                        workersList.push(node);\n                        data.push(node.data);\n                    }\n\n                    numRunning += 1;\n\n                    if (q._tasks.length === 0) {\n                        trigger('empty');\n                    }\n\n                    if (numRunning === q.concurrency) {\n                        trigger('saturated');\n                    }\n\n                    var cb = onlyOnce(_createCB(tasks));\n                    _worker(data, cb);\n                }\n                isProcessing = false;\n            },\n            length () {\n                return q._tasks.length;\n            },\n            running () {\n                return numRunning;\n            },\n            workersList () {\n                return workersList;\n            },\n            idle() {\n                return q._tasks.length + numRunning === 0;\n            },\n            pause () {\n                q.paused = true;\n            },\n            resume () {\n                if (q.paused === false) { return; }\n                q.paused = false;\n                setImmediate$1(q.process);\n            }\n        };\n        // define these as fixed properties, so people get useful errors when updating\n        Object.defineProperties(q, {\n            saturated: {\n                writable: false,\n                value: eventMethod('saturated')\n            },\n            unsaturated: {\n                writable: false,\n                value: eventMethod('unsaturated')\n            },\n            empty: {\n                writable: false,\n                value: eventMethod('empty')\n            },\n            drain: {\n                writable: false,\n                value: eventMethod('drain')\n            },\n            error: {\n                writable: false,\n                value: eventMethod('error')\n            },\n        });\n        return q;\n    }\n\n    /**\n     * Creates a `cargo` object with the specified payload. Tasks added to the\n     * cargo will be processed altogether (up to the `payload` limit). If the\n     * `worker` is in progress, the task is queued until it becomes available. Once\n     * the `worker` has completed some tasks, each callback of those tasks is\n     * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)\n     * for how `cargo` and `queue` work.\n     *\n     * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers\n     * at a time, cargo passes an array of tasks to a single worker, repeating\n     * when the worker is finished.\n     *\n     * @name cargo\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @see [async.queue]{@link module:ControlFlow.queue}\n     * @category Control Flow\n     * @param {AsyncFunction} worker - An asynchronous function for processing an array\n     * of queued tasks. Invoked with `(tasks, callback)`.\n     * @param {number} [payload=Infinity] - An optional `integer` for determining\n     * how many tasks should be processed per round; if omitted, the default is\n     * unlimited.\n     * @returns {module:ControlFlow.QueueObject} A cargo object to manage the tasks. Callbacks can\n     * attached as certain properties to listen for specific events during the\n     * lifecycle of the cargo and inner queue.\n     * @example\n     *\n     * // create a cargo object with payload 2\n     * var cargo = async.cargo(function(tasks, callback) {\n     *     for (var i=0; i<tasks.length; i++) {\n     *         console.log('hello ' + tasks[i].name);\n     *     }\n     *     callback();\n     * }, 2);\n     *\n     * // add some items\n     * cargo.push({name: 'foo'}, function(err) {\n     *     console.log('finished processing foo');\n     * });\n     * cargo.push({name: 'bar'}, function(err) {\n     *     console.log('finished processing bar');\n     * });\n     * await cargo.push({name: 'baz'});\n     * console.log('finished processing baz');\n     */\n    function cargo(worker, payload) {\n        return queue(worker, 1, payload);\n    }\n\n    /**\n     * Creates a `cargoQueue` object with the specified payload. Tasks added to the\n     * cargoQueue will be processed together (up to the `payload` limit) in `concurrency` parallel workers.\n     * If the all `workers` are in progress, the task is queued until one becomes available. Once\n     * a `worker` has completed some tasks, each callback of those tasks is\n     * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)\n     * for how `cargo` and `queue` work.\n     *\n     * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers\n     * at a time, and [`cargo`]{@link module:ControlFlow.cargo} passes an array of tasks to a single worker,\n     * the cargoQueue passes an array of tasks to multiple parallel workers.\n     *\n     * @name cargoQueue\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @see [async.queue]{@link module:ControlFlow.queue}\n     * @see [async.cargo]{@link module:ControlFLow.cargo}\n     * @category Control Flow\n     * @param {AsyncFunction} worker - An asynchronous function for processing an array\n     * of queued tasks. Invoked with `(tasks, callback)`.\n     * @param {number} [concurrency=1] - An `integer` for determining how many\n     * `worker` functions should be run in parallel.  If omitted, the concurrency\n     * defaults to `1`.  If the concurrency is `0`, an error is thrown.\n     * @param {number} [payload=Infinity] - An optional `integer` for determining\n     * how many tasks should be processed per round; if omitted, the default is\n     * unlimited.\n     * @returns {module:ControlFlow.QueueObject} A cargoQueue object to manage the tasks. Callbacks can\n     * attached as certain properties to listen for specific events during the\n     * lifecycle of the cargoQueue and inner queue.\n     * @example\n     *\n     * // create a cargoQueue object with payload 2 and concurrency 2\n     * var cargoQueue = async.cargoQueue(function(tasks, callback) {\n     *     for (var i=0; i<tasks.length; i++) {\n     *         console.log('hello ' + tasks[i].name);\n     *     }\n     *     callback();\n     * }, 2, 2);\n     *\n     * // add some items\n     * cargoQueue.push({name: 'foo'}, function(err) {\n     *     console.log('finished processing foo');\n     * });\n     * cargoQueue.push({name: 'bar'}, function(err) {\n     *     console.log('finished processing bar');\n     * });\n     * cargoQueue.push({name: 'baz'}, function(err) {\n     *     console.log('finished processing baz');\n     * });\n     * cargoQueue.push({name: 'boo'}, function(err) {\n     *     console.log('finished processing boo');\n     * });\n     */\n    function cargo$1(worker, concurrency, payload) {\n        return queue(worker, concurrency, payload);\n    }\n\n    /**\n     * Reduces `coll` into a single value using an async `iteratee` to return each\n     * successive step. `memo` is the initial state of the reduction. This function\n     * only operates in series.\n     *\n     * For performance reasons, it may make sense to split a call to this function\n     * into a parallel map, and then use the normal `Array.prototype.reduce` on the\n     * results. This function is for situations where each step in the reduction\n     * needs to be async; if you can get the data before reducing it, then it's\n     * probably a good idea to do so.\n     *\n     * @name reduce\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @alias inject\n     * @alias foldl\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {*} memo - The initial state of the reduction.\n     * @param {AsyncFunction} iteratee - A function applied to each item in the\n     * array to produce the next step in the reduction.\n     * The `iteratee` should complete with the next state of the reduction.\n     * If the iteratee completes with an error, the reduction is stopped and the\n     * main `callback` is immediately called with the error.\n     * Invoked with (memo, item, callback).\n     * @param {Function} [callback] - A callback which is called after all the\n     * `iteratee` functions have finished. Result is the reduced value. Invoked with\n     * (err, result).\n     * @returns {Promise} a promise, if no callback is passed\n     * @example\n     *\n     * // file1.txt is a file that is 1000 bytes in size\n     * // file2.txt is a file that is 2000 bytes in size\n     * // file3.txt is a file that is 3000 bytes in size\n     * // file4.txt does not exist\n     *\n     * const fileList = ['file1.txt','file2.txt','file3.txt'];\n     * const withMissingFileList = ['file1.txt','file2.txt','file3.txt', 'file4.txt'];\n     *\n     * // asynchronous function that computes the file size in bytes\n     * // file size is added to the memoized value, then returned\n     * function getFileSizeInBytes(memo, file, callback) {\n     *     fs.stat(file, function(err, stat) {\n     *         if (err) {\n     *             return callback(err);\n     *         }\n     *         callback(null, memo + stat.size);\n     *     });\n     * }\n     *\n     * // Using callbacks\n     * async.reduce(fileList, 0, getFileSizeInBytes, function(err, result) {\n     *     if (err) {\n     *         console.log(err);\n     *     } else {\n     *         console.log(result);\n     *         // 6000\n     *         // which is the sum of the file sizes of the three files\n     *     }\n     * });\n     *\n     * // Error Handling\n     * async.reduce(withMissingFileList, 0, getFileSizeInBytes, function(err, result) {\n     *     if (err) {\n     *         console.log(err);\n     *         // [ Error: ENOENT: no such file or directory ]\n     *     } else {\n     *         console.log(result);\n     *     }\n     * });\n     *\n     * // Using Promises\n     * async.reduce(fileList, 0, getFileSizeInBytes)\n     * .then( result => {\n     *     console.log(result);\n     *     // 6000\n     *     // which is the sum of the file sizes of the three files\n     * }).catch( err => {\n     *     console.log(err);\n     * });\n     *\n     * // Error Handling\n     * async.reduce(withMissingFileList, 0, getFileSizeInBytes)\n     * .then( result => {\n     *     console.log(result);\n     * }).catch( err => {\n     *     console.log(err);\n     *     // [ Error: ENOENT: no such file or directory ]\n     * });\n     *\n     * // Using async/await\n     * async () => {\n     *     try {\n     *         let result = await async.reduce(fileList, 0, getFileSizeInBytes);\n     *         console.log(result);\n     *         // 6000\n     *         // which is the sum of the file sizes of the three files\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *     }\n     * }\n     *\n     * // Error Handling\n     * async () => {\n     *     try {\n     *         let result = await async.reduce(withMissingFileList, 0, getFileSizeInBytes);\n     *         console.log(result);\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *         // [ Error: ENOENT: no such file or directory ]\n     *     }\n     * }\n     *\n     */\n    function reduce(coll, memo, iteratee, callback) {\n        callback = once(callback);\n        var _iteratee = wrapAsync(iteratee);\n        return eachOfSeries$1(coll, (x, i, iterCb) => {\n            _iteratee(memo, x, (err, v) => {\n                memo = v;\n                iterCb(err);\n            });\n        }, err => callback(err, memo));\n    }\n    var reduce$1 = awaitify(reduce, 4);\n\n    /**\n     * Version of the compose function that is more natural to read. Each function\n     * consumes the return value of the previous function. It is the equivalent of\n     * [compose]{@link module:ControlFlow.compose} with the arguments reversed.\n     *\n     * Each function is executed with the `this` binding of the composed function.\n     *\n     * @name seq\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @see [async.compose]{@link module:ControlFlow.compose}\n     * @category Control Flow\n     * @param {...AsyncFunction} functions - the asynchronous functions to compose\n     * @returns {Function} a function that composes the `functions` in order\n     * @example\n     *\n     * // Requires lodash (or underscore), express3 and dresende's orm2.\n     * // Part of an app, that fetches cats of the logged user.\n     * // This example uses `seq` function to avoid overnesting and error\n     * // handling clutter.\n     * app.get('/cats', function(request, response) {\n     *     var User = request.models.User;\n     *     async.seq(\n     *         User.get.bind(User),  // 'User.get' has signature (id, callback(err, data))\n     *         function(user, fn) {\n     *             user.getCats(fn);      // 'getCats' has signature (callback(err, data))\n     *         }\n     *     )(req.session.user_id, function (err, cats) {\n     *         if (err) {\n     *             console.error(err);\n     *             response.json({ status: 'error', message: err.message });\n     *         } else {\n     *             response.json({ status: 'ok', message: 'Cats found', data: cats });\n     *         }\n     *     });\n     * });\n     */\n    function seq(...functions) {\n        var _functions = functions.map(wrapAsync);\n        return function (...args) {\n            var that = this;\n\n            var cb = args[args.length - 1];\n            if (typeof cb == 'function') {\n                args.pop();\n            } else {\n                cb = promiseCallback();\n            }\n\n            reduce$1(_functions, args, (newargs, fn, iterCb) => {\n                fn.apply(that, newargs.concat((err, ...nextargs) => {\n                    iterCb(err, nextargs);\n                }));\n            },\n            (err, results) => cb(err, ...results));\n\n            return cb[PROMISE_SYMBOL]\n        };\n    }\n\n    /**\n     * Creates a function which is a composition of the passed asynchronous\n     * functions. Each function consumes the return value of the function that\n     * follows. Composing functions `f()`, `g()`, and `h()` would produce the result\n     * of `f(g(h()))`, only this version uses callbacks to obtain the return values.\n     *\n     * If the last argument to the composed function is not a function, a promise\n     * is returned when you call it.\n     *\n     * Each function is executed with the `this` binding of the composed function.\n     *\n     * @name compose\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @category Control Flow\n     * @param {...AsyncFunction} functions - the asynchronous functions to compose\n     * @returns {Function} an asynchronous function that is the composed\n     * asynchronous `functions`\n     * @example\n     *\n     * function add1(n, callback) {\n     *     setTimeout(function () {\n     *         callback(null, n + 1);\n     *     }, 10);\n     * }\n     *\n     * function mul3(n, callback) {\n     *     setTimeout(function () {\n     *         callback(null, n * 3);\n     *     }, 10);\n     * }\n     *\n     * var add1mul3 = async.compose(mul3, add1);\n     * add1mul3(4, function (err, result) {\n     *     // result now equals 15\n     * });\n     */\n    function compose(...args) {\n        return seq(...args.reverse());\n    }\n\n    /**\n     * The same as [`map`]{@link module:Collections.map} but runs a maximum of `limit` async operations at a time.\n     *\n     * @name mapLimit\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.map]{@link module:Collections.map}\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {number} limit - The maximum number of async operations at a time.\n     * @param {AsyncFunction} iteratee - An async function to apply to each item in\n     * `coll`.\n     * The iteratee should complete with the transformed item.\n     * Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called when all `iteratee`\n     * functions have finished, or an error occurs. Results is an array of the\n     * transformed items from the `coll`. Invoked with (err, results).\n     * @returns {Promise} a promise, if no callback is passed\n     */\n    function mapLimit (coll, limit, iteratee, callback) {\n        return _asyncMap(eachOfLimit(limit), coll, iteratee, callback)\n    }\n    var mapLimit$1 = awaitify(mapLimit, 4);\n\n    /**\n     * The same as [`concat`]{@link module:Collections.concat} but runs a maximum of `limit` async operations at a time.\n     *\n     * @name concatLimit\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.concat]{@link module:Collections.concat}\n     * @category Collection\n     * @alias flatMapLimit\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {number} limit - The maximum number of async operations at a time.\n     * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,\n     * which should use an array as its result. Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called after all the\n     * `iteratee` functions have finished, or an error occurs. Results is an array\n     * containing the concatenated results of the `iteratee` function. Invoked with\n     * (err, results).\n     * @returns A Promise, if no callback is passed\n     */\n    function concatLimit(coll, limit, iteratee, callback) {\n        var _iteratee = wrapAsync(iteratee);\n        return mapLimit$1(coll, limit, (val, iterCb) => {\n            _iteratee(val, (err, ...args) => {\n                if (err) return iterCb(err);\n                return iterCb(err, args);\n            });\n        }, (err, mapResults) => {\n            var result = [];\n            for (var i = 0; i < mapResults.length; i++) {\n                if (mapResults[i]) {\n                    result = result.concat(...mapResults[i]);\n                }\n            }\n\n            return callback(err, result);\n        });\n    }\n    var concatLimit$1 = awaitify(concatLimit, 4);\n\n    /**\n     * Applies `iteratee` to each item in `coll`, concatenating the results. Returns\n     * the concatenated list. The `iteratee`s are called in parallel, and the\n     * results are concatenated as they return. The results array will be returned in\n     * the original order of `coll` passed to the `iteratee` function.\n     *\n     * @name concat\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @category Collection\n     * @alias flatMap\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,\n     * which should use an array as its result. Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called after all the\n     * `iteratee` functions have finished, or an error occurs. Results is an array\n     * containing the concatenated results of the `iteratee` function. Invoked with\n     * (err, results).\n     * @returns A Promise, if no callback is passed\n     * @example\n     *\n     * // dir1 is a directory that contains file1.txt, file2.txt\n     * // dir2 is a directory that contains file3.txt, file4.txt\n     * // dir3 is a directory that contains file5.txt\n     * // dir4 does not exist\n     *\n     * let directoryList = ['dir1','dir2','dir3'];\n     * let withMissingDirectoryList = ['dir1','dir2','dir3', 'dir4'];\n     *\n     * // Using callbacks\n     * async.concat(directoryList, fs.readdir, function(err, results) {\n     *    if (err) {\n     *        console.log(err);\n     *    } else {\n     *        console.log(results);\n     *        // [ 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', file5.txt ]\n     *    }\n     * });\n     *\n     * // Error Handling\n     * async.concat(withMissingDirectoryList, fs.readdir, function(err, results) {\n     *    if (err) {\n     *        console.log(err);\n     *        // [ Error: ENOENT: no such file or directory ]\n     *        // since dir4 does not exist\n     *    } else {\n     *        console.log(results);\n     *    }\n     * });\n     *\n     * // Using Promises\n     * async.concat(directoryList, fs.readdir)\n     * .then(results => {\n     *     console.log(results);\n     *     // [ 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', file5.txt ]\n     * }).catch(err => {\n     *      console.log(err);\n     * });\n     *\n     * // Error Handling\n     * async.concat(withMissingDirectoryList, fs.readdir)\n     * .then(results => {\n     *     console.log(results);\n     * }).catch(err => {\n     *     console.log(err);\n     *     // [ Error: ENOENT: no such file or directory ]\n     *     // since dir4 does not exist\n     * });\n     *\n     * // Using async/await\n     * async () => {\n     *     try {\n     *         let results = await async.concat(directoryList, fs.readdir);\n     *         console.log(results);\n     *         // [ 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', file5.txt ]\n     *     } catch (err) {\n     *         console.log(err);\n     *     }\n     * }\n     *\n     * // Error Handling\n     * async () => {\n     *     try {\n     *         let results = await async.concat(withMissingDirectoryList, fs.readdir);\n     *         console.log(results);\n     *     } catch (err) {\n     *         console.log(err);\n     *         // [ Error: ENOENT: no such file or directory ]\n     *         // since dir4 does not exist\n     *     }\n     * }\n     *\n     */\n    function concat(coll, iteratee, callback) {\n        return concatLimit$1(coll, Infinity, iteratee, callback)\n    }\n    var concat$1 = awaitify(concat, 3);\n\n    /**\n     * The same as [`concat`]{@link module:Collections.concat} but runs only a single async operation at a time.\n     *\n     * @name concatSeries\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.concat]{@link module:Collections.concat}\n     * @category Collection\n     * @alias flatMapSeries\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`.\n     * The iteratee should complete with an array an array of results.\n     * Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called after all the\n     * `iteratee` functions have finished, or an error occurs. Results is an array\n     * containing the concatenated results of the `iteratee` function. Invoked with\n     * (err, results).\n     * @returns A Promise, if no callback is passed\n     */\n    function concatSeries(coll, iteratee, callback) {\n        return concatLimit$1(coll, 1, iteratee, callback)\n    }\n    var concatSeries$1 = awaitify(concatSeries, 3);\n\n    /**\n     * Returns a function that when called, calls-back with the values provided.\n     * Useful as the first function in a [`waterfall`]{@link module:ControlFlow.waterfall}, or for plugging values in to\n     * [`auto`]{@link module:ControlFlow.auto}.\n     *\n     * @name constant\n     * @static\n     * @memberOf module:Utils\n     * @method\n     * @category Util\n     * @param {...*} arguments... - Any number of arguments to automatically invoke\n     * callback with.\n     * @returns {AsyncFunction} Returns a function that when invoked, automatically\n     * invokes the callback with the previous given arguments.\n     * @example\n     *\n     * async.waterfall([\n     *     async.constant(42),\n     *     function (value, next) {\n     *         // value === 42\n     *     },\n     *     //...\n     * ], callback);\n     *\n     * async.waterfall([\n     *     async.constant(filename, \"utf8\"),\n     *     fs.readFile,\n     *     function (fileData, next) {\n     *         //...\n     *     }\n     *     //...\n     * ], callback);\n     *\n     * async.auto({\n     *     hostname: async.constant(\"https://server.net/\"),\n     *     port: findFreePort,\n     *     launchServer: [\"hostname\", \"port\", function (options, cb) {\n     *         startServer(options, cb);\n     *     }],\n     *     //...\n     * }, callback);\n     */\n    function constant(...args) {\n        return function (...ignoredArgs/*, callback*/) {\n            var callback = ignoredArgs.pop();\n            return callback(null, ...args);\n        };\n    }\n\n    function _createTester(check, getResult) {\n        return (eachfn, arr, _iteratee, cb) => {\n            var testPassed = false;\n            var testResult;\n            const iteratee = wrapAsync(_iteratee);\n            eachfn(arr, (value, _, callback) => {\n                iteratee(value, (err, result) => {\n                    if (err || err === false) return callback(err);\n\n                    if (check(result) && !testResult) {\n                        testPassed = true;\n                        testResult = getResult(true, value);\n                        return callback(null, breakLoop);\n                    }\n                    callback();\n                });\n            }, err => {\n                if (err) return cb(err);\n                cb(null, testPassed ? testResult : getResult(false));\n            });\n        };\n    }\n\n    /**\n     * Returns the first value in `coll` that passes an async truth test. The\n     * `iteratee` is applied in parallel, meaning the first iteratee to return\n     * `true` will fire the detect `callback` with that result. That means the\n     * result might not be the first item in the original `coll` (in terms of order)\n     * that passes the test.\n\n     * If order within the original `coll` is important, then look at\n     * [`detectSeries`]{@link module:Collections.detectSeries}.\n     *\n     * @name detect\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @alias find\n     * @category Collections\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n     * The iteratee must complete with a boolean value as its result.\n     * Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called as soon as any\n     * iteratee returns `true`, or after all the `iteratee` functions have finished.\n     * Result will be the first item in the array that passes the truth test\n     * (iteratee) or the value `undefined` if none passed. Invoked with\n     * (err, result).\n     * @returns {Promise} a promise, if a callback is omitted\n     * @example\n     *\n     * // dir1 is a directory that contains file1.txt, file2.txt\n     * // dir2 is a directory that contains file3.txt, file4.txt\n     * // dir3 is a directory that contains file5.txt\n     *\n     * // asynchronous function that checks if a file exists\n     * function fileExists(file, callback) {\n     *    fs.access(file, fs.constants.F_OK, (err) => {\n     *        callback(null, !err);\n     *    });\n     * }\n     *\n     * async.detect(['file3.txt','file2.txt','dir1/file1.txt'], fileExists,\n     *    function(err, result) {\n     *        console.log(result);\n     *        // dir1/file1.txt\n     *        // result now equals the first file in the list that exists\n     *    }\n     *);\n     *\n     * // Using Promises\n     * async.detect(['file3.txt','file2.txt','dir1/file1.txt'], fileExists)\n     * .then(result => {\n     *     console.log(result);\n     *     // dir1/file1.txt\n     *     // result now equals the first file in the list that exists\n     * }).catch(err => {\n     *     console.log(err);\n     * });\n     *\n     * // Using async/await\n     * async () => {\n     *     try {\n     *         let result = await async.detect(['file3.txt','file2.txt','dir1/file1.txt'], fileExists);\n     *         console.log(result);\n     *         // dir1/file1.txt\n     *         // result now equals the file in the list that exists\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *     }\n     * }\n     *\n     */\n    function detect(coll, iteratee, callback) {\n        return _createTester(bool => bool, (res, item) => item)(eachOf$1, coll, iteratee, callback)\n    }\n    var detect$1 = awaitify(detect, 3);\n\n    /**\n     * The same as [`detect`]{@link module:Collections.detect} but runs a maximum of `limit` async operations at a\n     * time.\n     *\n     * @name detectLimit\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.detect]{@link module:Collections.detect}\n     * @alias findLimit\n     * @category Collections\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {number} limit - The maximum number of async operations at a time.\n     * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n     * The iteratee must complete with a boolean value as its result.\n     * Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called as soon as any\n     * iteratee returns `true`, or after all the `iteratee` functions have finished.\n     * Result will be the first item in the array that passes the truth test\n     * (iteratee) or the value `undefined` if none passed. Invoked with\n     * (err, result).\n     * @returns {Promise} a promise, if a callback is omitted\n     */\n    function detectLimit(coll, limit, iteratee, callback) {\n        return _createTester(bool => bool, (res, item) => item)(eachOfLimit(limit), coll, iteratee, callback)\n    }\n    var detectLimit$1 = awaitify(detectLimit, 4);\n\n    /**\n     * The same as [`detect`]{@link module:Collections.detect} but runs only a single async operation at a time.\n     *\n     * @name detectSeries\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.detect]{@link module:Collections.detect}\n     * @alias findSeries\n     * @category Collections\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n     * The iteratee must complete with a boolean value as its result.\n     * Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called as soon as any\n     * iteratee returns `true`, or after all the `iteratee` functions have finished.\n     * Result will be the first item in the array that passes the truth test\n     * (iteratee) or the value `undefined` if none passed. Invoked with\n     * (err, result).\n     * @returns {Promise} a promise, if a callback is omitted\n     */\n    function detectSeries(coll, iteratee, callback) {\n        return _createTester(bool => bool, (res, item) => item)(eachOfLimit(1), coll, iteratee, callback)\n    }\n\n    var detectSeries$1 = awaitify(detectSeries, 3);\n\n    function consoleFunc(name) {\n        return (fn, ...args) => wrapAsync(fn)(...args, (err, ...resultArgs) => {\n            /* istanbul ignore else */\n            if (typeof console === 'object') {\n                /* istanbul ignore else */\n                if (err) {\n                    /* istanbul ignore else */\n                    if (console.error) {\n                        console.error(err);\n                    }\n                } else if (console[name]) { /* istanbul ignore else */\n                    resultArgs.forEach(x => console[name](x));\n                }\n            }\n        })\n    }\n\n    /**\n     * Logs the result of an [`async` function]{@link AsyncFunction} to the\n     * `console` using `console.dir` to display the properties of the resulting object.\n     * Only works in Node.js or in browsers that support `console.dir` and\n     * `console.error` (such as FF and Chrome).\n     * If multiple arguments are returned from the async function,\n     * `console.dir` is called on each argument in order.\n     *\n     * @name dir\n     * @static\n     * @memberOf module:Utils\n     * @method\n     * @category Util\n     * @param {AsyncFunction} function - The function you want to eventually apply\n     * all arguments to.\n     * @param {...*} arguments... - Any number of arguments to apply to the function.\n     * @example\n     *\n     * // in a module\n     * var hello = function(name, callback) {\n     *     setTimeout(function() {\n     *         callback(null, {hello: name});\n     *     }, 1000);\n     * };\n     *\n     * // in the node repl\n     * node> async.dir(hello, 'world');\n     * {hello: 'world'}\n     */\n    var dir = consoleFunc('dir');\n\n    /**\n     * The post-check version of [`whilst`]{@link module:ControlFlow.whilst}. To reflect the difference in\n     * the order of operations, the arguments `test` and `iteratee` are switched.\n     *\n     * `doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.\n     *\n     * @name doWhilst\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @see [async.whilst]{@link module:ControlFlow.whilst}\n     * @category Control Flow\n     * @param {AsyncFunction} iteratee - A function which is called each time `test`\n     * passes. Invoked with (callback).\n     * @param {AsyncFunction} test - asynchronous truth test to perform after each\n     * execution of `iteratee`. Invoked with (...args, callback), where `...args` are the\n     * non-error args from the previous callback of `iteratee`.\n     * @param {Function} [callback] - A callback which is called after the test\n     * function has failed and repeated execution of `iteratee` has stopped.\n     * `callback` will be passed an error and any arguments passed to the final\n     * `iteratee`'s callback. Invoked with (err, [results]);\n     * @returns {Promise} a promise, if no callback is passed\n     */\n    function doWhilst(iteratee, test, callback) {\n        callback = onlyOnce(callback);\n        var _fn = wrapAsync(iteratee);\n        var _test = wrapAsync(test);\n        var results;\n\n        function next(err, ...args) {\n            if (err) return callback(err);\n            if (err === false) return;\n            results = args;\n            _test(...args, check);\n        }\n\n        function check(err, truth) {\n            if (err) return callback(err);\n            if (err === false) return;\n            if (!truth) return callback(null, ...results);\n            _fn(next);\n        }\n\n        return check(null, true);\n    }\n\n    var doWhilst$1 = awaitify(doWhilst, 3);\n\n    /**\n     * Like ['doWhilst']{@link module:ControlFlow.doWhilst}, except the `test` is inverted. Note the\n     * argument ordering differs from `until`.\n     *\n     * @name doUntil\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @see [async.doWhilst]{@link module:ControlFlow.doWhilst}\n     * @category Control Flow\n     * @param {AsyncFunction} iteratee - An async function which is called each time\n     * `test` fails. Invoked with (callback).\n     * @param {AsyncFunction} test - asynchronous truth test to perform after each\n     * execution of `iteratee`. Invoked with (...args, callback), where `...args` are the\n     * non-error args from the previous callback of `iteratee`\n     * @param {Function} [callback] - A callback which is called after the test\n     * function has passed and repeated execution of `iteratee` has stopped. `callback`\n     * will be passed an error and any arguments passed to the final `iteratee`'s\n     * callback. Invoked with (err, [results]);\n     * @returns {Promise} a promise, if no callback is passed\n     */\n    function doUntil(iteratee, test, callback) {\n        const _test = wrapAsync(test);\n        return doWhilst$1(iteratee, (...args) => {\n            const cb = args.pop();\n            _test(...args, (err, truth) => cb (err, !truth));\n        }, callback);\n    }\n\n    function _withoutIndex(iteratee) {\n        return (value, index, callback) => iteratee(value, callback);\n    }\n\n    /**\n     * Applies the function `iteratee` to each item in `coll`, in parallel.\n     * The `iteratee` is called with an item from the list, and a callback for when\n     * it has finished. If the `iteratee` passes an error to its `callback`, the\n     * main `callback` (for the `each` function) is immediately called with the\n     * error.\n     *\n     * Note, that since this function applies `iteratee` to each item in parallel,\n     * there is no guarantee that the iteratee functions will complete in order.\n     *\n     * @name each\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @alias forEach\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {AsyncFunction} iteratee - An async function to apply to\n     * each item in `coll`. Invoked with (item, callback).\n     * The array index is not passed to the iteratee.\n     * If you need the index, use `eachOf`.\n     * @param {Function} [callback] - A callback which is called when all\n     * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n     * @returns {Promise} a promise, if a callback is omitted\n     * @example\n     *\n     * // dir1 is a directory that contains file1.txt, file2.txt\n     * // dir2 is a directory that contains file3.txt, file4.txt\n     * // dir3 is a directory that contains file5.txt\n     * // dir4 does not exist\n     *\n     * const fileList = [ 'dir1/file2.txt', 'dir2/file3.txt', 'dir/file5.txt'];\n     * const withMissingFileList = ['dir1/file1.txt', 'dir4/file2.txt'];\n     *\n     * // asynchronous function that deletes a file\n     * const deleteFile = function(file, callback) {\n     *     fs.unlink(file, callback);\n     * };\n     *\n     * // Using callbacks\n     * async.each(fileList, deleteFile, function(err) {\n     *     if( err ) {\n     *         console.log(err);\n     *     } else {\n     *         console.log('All files have been deleted successfully');\n     *     }\n     * });\n     *\n     * // Error Handling\n     * async.each(withMissingFileList, deleteFile, function(err){\n     *     console.log(err);\n     *     // [ Error: ENOENT: no such file or directory ]\n     *     // since dir4/file2.txt does not exist\n     *     // dir1/file1.txt could have been deleted\n     * });\n     *\n     * // Using Promises\n     * async.each(fileList, deleteFile)\n     * .then( () => {\n     *     console.log('All files have been deleted successfully');\n     * }).catch( err => {\n     *     console.log(err);\n     * });\n     *\n     * // Error Handling\n     * async.each(fileList, deleteFile)\n     * .then( () => {\n     *     console.log('All files have been deleted successfully');\n     * }).catch( err => {\n     *     console.log(err);\n     *     // [ Error: ENOENT: no such file or directory ]\n     *     // since dir4/file2.txt does not exist\n     *     // dir1/file1.txt could have been deleted\n     * });\n     *\n     * // Using async/await\n     * async () => {\n     *     try {\n     *         await async.each(files, deleteFile);\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *     }\n     * }\n     *\n     * // Error Handling\n     * async () => {\n     *     try {\n     *         await async.each(withMissingFileList, deleteFile);\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *         // [ Error: ENOENT: no such file or directory ]\n     *         // since dir4/file2.txt does not exist\n     *         // dir1/file1.txt could have been deleted\n     *     }\n     * }\n     *\n     */\n    function eachLimit(coll, iteratee, callback) {\n        return eachOf$1(coll, _withoutIndex(wrapAsync(iteratee)), callback);\n    }\n\n    var each = awaitify(eachLimit, 3);\n\n    /**\n     * The same as [`each`]{@link module:Collections.each} but runs a maximum of `limit` async operations at a time.\n     *\n     * @name eachLimit\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.each]{@link module:Collections.each}\n     * @alias forEachLimit\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {number} limit - The maximum number of async operations at a time.\n     * @param {AsyncFunction} iteratee - An async function to apply to each item in\n     * `coll`.\n     * The array index is not passed to the iteratee.\n     * If you need the index, use `eachOfLimit`.\n     * Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called when all\n     * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n     * @returns {Promise} a promise, if a callback is omitted\n     */\n    function eachLimit$1(coll, limit, iteratee, callback) {\n        return eachOfLimit(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);\n    }\n    var eachLimit$2 = awaitify(eachLimit$1, 4);\n\n    /**\n     * The same as [`each`]{@link module:Collections.each} but runs only a single async operation at a time.\n     *\n     * Note, that unlike [`each`]{@link module:Collections.each}, this function applies iteratee to each item\n     * in series and therefore the iteratee functions will complete in order.\n\n     * @name eachSeries\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.each]{@link module:Collections.each}\n     * @alias forEachSeries\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {AsyncFunction} iteratee - An async function to apply to each\n     * item in `coll`.\n     * The array index is not passed to the iteratee.\n     * If you need the index, use `eachOfSeries`.\n     * Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called when all\n     * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n     * @returns {Promise} a promise, if a callback is omitted\n     */\n    function eachSeries(coll, iteratee, callback) {\n        return eachLimit$2(coll, 1, iteratee, callback)\n    }\n    var eachSeries$1 = awaitify(eachSeries, 3);\n\n    /**\n     * Wrap an async function and ensure it calls its callback on a later tick of\n     * the event loop.  If the function already calls its callback on a next tick,\n     * no extra deferral is added. This is useful for preventing stack overflows\n     * (`RangeError: Maximum call stack size exceeded`) and generally keeping\n     * [Zalgo](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)\n     * contained. ES2017 `async` functions are returned as-is -- they are immune\n     * to Zalgo's corrupting influences, as they always resolve on a later tick.\n     *\n     * @name ensureAsync\n     * @static\n     * @memberOf module:Utils\n     * @method\n     * @category Util\n     * @param {AsyncFunction} fn - an async function, one that expects a node-style\n     * callback as its last argument.\n     * @returns {AsyncFunction} Returns a wrapped function with the exact same call\n     * signature as the function passed in.\n     * @example\n     *\n     * function sometimesAsync(arg, callback) {\n     *     if (cache[arg]) {\n     *         return callback(null, cache[arg]); // this would be synchronous!!\n     *     } else {\n     *         doSomeIO(arg, callback); // this IO would be asynchronous\n     *     }\n     * }\n     *\n     * // this has a risk of stack overflows if many results are cached in a row\n     * async.mapSeries(args, sometimesAsync, done);\n     *\n     * // this will defer sometimesAsync's callback if necessary,\n     * // preventing stack overflows\n     * async.mapSeries(args, async.ensureAsync(sometimesAsync), done);\n     */\n    function ensureAsync(fn) {\n        if (isAsync(fn)) return fn;\n        return function (...args/*, callback*/) {\n            var callback = args.pop();\n            var sync = true;\n            args.push((...innerArgs) => {\n                if (sync) {\n                    setImmediate$1(() => callback(...innerArgs));\n                } else {\n                    callback(...innerArgs);\n                }\n            });\n            fn.apply(this, args);\n            sync = false;\n        };\n    }\n\n    /**\n     * Returns `true` if every element in `coll` satisfies an async test. If any\n     * iteratee call returns `false`, the main `callback` is immediately called.\n     *\n     * @name every\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @alias all\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n     * in the collection in parallel.\n     * The iteratee must complete with a boolean result value.\n     * Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called after all the\n     * `iteratee` functions have finished. Result will be either `true` or `false`\n     * depending on the values of the async tests. Invoked with (err, result).\n     * @returns {Promise} a promise, if no callback provided\n     * @example\n     *\n     * // dir1 is a directory that contains file1.txt, file2.txt\n     * // dir2 is a directory that contains file3.txt, file4.txt\n     * // dir3 is a directory that contains file5.txt\n     * // dir4 does not exist\n     *\n     * const fileList = ['dir1/file1.txt','dir2/file3.txt','dir3/file5.txt'];\n     * const withMissingFileList = ['file1.txt','file2.txt','file4.txt'];\n     *\n     * // asynchronous function that checks if a file exists\n     * function fileExists(file, callback) {\n     *    fs.access(file, fs.constants.F_OK, (err) => {\n     *        callback(null, !err);\n     *    });\n     * }\n     *\n     * // Using callbacks\n     * async.every(fileList, fileExists, function(err, result) {\n     *     console.log(result);\n     *     // true\n     *     // result is true since every file exists\n     * });\n     *\n     * async.every(withMissingFileList, fileExists, function(err, result) {\n     *     console.log(result);\n     *     // false\n     *     // result is false since NOT every file exists\n     * });\n     *\n     * // Using Promises\n     * async.every(fileList, fileExists)\n     * .then( result => {\n     *     console.log(result);\n     *     // true\n     *     // result is true since every file exists\n     * }).catch( err => {\n     *     console.log(err);\n     * });\n     *\n     * async.every(withMissingFileList, fileExists)\n     * .then( result => {\n     *     console.log(result);\n     *     // false\n     *     // result is false since NOT every file exists\n     * }).catch( err => {\n     *     console.log(err);\n     * });\n     *\n     * // Using async/await\n     * async () => {\n     *     try {\n     *         let result = await async.every(fileList, fileExists);\n     *         console.log(result);\n     *         // true\n     *         // result is true since every file exists\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *     }\n     * }\n     *\n     * async () => {\n     *     try {\n     *         let result = await async.every(withMissingFileList, fileExists);\n     *         console.log(result);\n     *         // false\n     *         // result is false since NOT every file exists\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *     }\n     * }\n     *\n     */\n    function every(coll, iteratee, callback) {\n        return _createTester(bool => !bool, res => !res)(eachOf$1, coll, iteratee, callback)\n    }\n    var every$1 = awaitify(every, 3);\n\n    /**\n     * The same as [`every`]{@link module:Collections.every} but runs a maximum of `limit` async operations at a time.\n     *\n     * @name everyLimit\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.every]{@link module:Collections.every}\n     * @alias allLimit\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {number} limit - The maximum number of async operations at a time.\n     * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n     * in the collection in parallel.\n     * The iteratee must complete with a boolean result value.\n     * Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called after all the\n     * `iteratee` functions have finished. Result will be either `true` or `false`\n     * depending on the values of the async tests. Invoked with (err, result).\n     * @returns {Promise} a promise, if no callback provided\n     */\n    function everyLimit(coll, limit, iteratee, callback) {\n        return _createTester(bool => !bool, res => !res)(eachOfLimit(limit), coll, iteratee, callback)\n    }\n    var everyLimit$1 = awaitify(everyLimit, 4);\n\n    /**\n     * The same as [`every`]{@link module:Collections.every} but runs only a single async operation at a time.\n     *\n     * @name everySeries\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.every]{@link module:Collections.every}\n     * @alias allSeries\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n     * in the collection in series.\n     * The iteratee must complete with a boolean result value.\n     * Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called after all the\n     * `iteratee` functions have finished. Result will be either `true` or `false`\n     * depending on the values of the async tests. Invoked with (err, result).\n     * @returns {Promise} a promise, if no callback provided\n     */\n    function everySeries(coll, iteratee, callback) {\n        return _createTester(bool => !bool, res => !res)(eachOfSeries$1, coll, iteratee, callback)\n    }\n    var everySeries$1 = awaitify(everySeries, 3);\n\n    function filterArray(eachfn, arr, iteratee, callback) {\n        var truthValues = new Array(arr.length);\n        eachfn(arr, (x, index, iterCb) => {\n            iteratee(x, (err, v) => {\n                truthValues[index] = !!v;\n                iterCb(err);\n            });\n        }, err => {\n            if (err) return callback(err);\n            var results = [];\n            for (var i = 0; i < arr.length; i++) {\n                if (truthValues[i]) results.push(arr[i]);\n            }\n            callback(null, results);\n        });\n    }\n\n    function filterGeneric(eachfn, coll, iteratee, callback) {\n        var results = [];\n        eachfn(coll, (x, index, iterCb) => {\n            iteratee(x, (err, v) => {\n                if (err) return iterCb(err);\n                if (v) {\n                    results.push({index, value: x});\n                }\n                iterCb(err);\n            });\n        }, err => {\n            if (err) return callback(err);\n            callback(null, results\n                .sort((a, b) => a.index - b.index)\n                .map(v => v.value));\n        });\n    }\n\n    function _filter(eachfn, coll, iteratee, callback) {\n        var filter = isArrayLike(coll) ? filterArray : filterGeneric;\n        return filter(eachfn, coll, wrapAsync(iteratee), callback);\n    }\n\n    /**\n     * Returns a new array of all the values in `coll` which pass an async truth\n     * test. This operation is performed in parallel, but the results array will be\n     * in the same order as the original.\n     *\n     * @name filter\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @alias select\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n     * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n     * with a boolean argument once it has completed. Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called after all the\n     * `iteratee` functions have finished. Invoked with (err, results).\n     * @returns {Promise} a promise, if no callback provided\n     * @example\n     *\n     * // dir1 is a directory that contains file1.txt, file2.txt\n     * // dir2 is a directory that contains file3.txt, file4.txt\n     * // dir3 is a directory that contains file5.txt\n     *\n     * const files = ['dir1/file1.txt','dir2/file3.txt','dir3/file6.txt'];\n     *\n     * // asynchronous function that checks if a file exists\n     * function fileExists(file, callback) {\n     *    fs.access(file, fs.constants.F_OK, (err) => {\n     *        callback(null, !err);\n     *    });\n     * }\n     *\n     * // Using callbacks\n     * async.filter(files, fileExists, function(err, results) {\n     *    if(err) {\n     *        console.log(err);\n     *    } else {\n     *        console.log(results);\n     *        // [ 'dir1/file1.txt', 'dir2/file3.txt' ]\n     *        // results is now an array of the existing files\n     *    }\n     * });\n     *\n     * // Using Promises\n     * async.filter(files, fileExists)\n     * .then(results => {\n     *     console.log(results);\n     *     // [ 'dir1/file1.txt', 'dir2/file3.txt' ]\n     *     // results is now an array of the existing files\n     * }).catch(err => {\n     *     console.log(err);\n     * });\n     *\n     * // Using async/await\n     * async () => {\n     *     try {\n     *         let results = await async.filter(files, fileExists);\n     *         console.log(results);\n     *         // [ 'dir1/file1.txt', 'dir2/file3.txt' ]\n     *         // results is now an array of the existing files\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *     }\n     * }\n     *\n     */\n    function filter (coll, iteratee, callback) {\n        return _filter(eachOf$1, coll, iteratee, callback)\n    }\n    var filter$1 = awaitify(filter, 3);\n\n    /**\n     * The same as [`filter`]{@link module:Collections.filter} but runs a maximum of `limit` async operations at a\n     * time.\n     *\n     * @name filterLimit\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.filter]{@link module:Collections.filter}\n     * @alias selectLimit\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {number} limit - The maximum number of async operations at a time.\n     * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n     * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n     * with a boolean argument once it has completed. Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called after all the\n     * `iteratee` functions have finished. Invoked with (err, results).\n     * @returns {Promise} a promise, if no callback provided\n     */\n    function filterLimit (coll, limit, iteratee, callback) {\n        return _filter(eachOfLimit(limit), coll, iteratee, callback)\n    }\n    var filterLimit$1 = awaitify(filterLimit, 4);\n\n    /**\n     * The same as [`filter`]{@link module:Collections.filter} but runs only a single async operation at a time.\n     *\n     * @name filterSeries\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.filter]{@link module:Collections.filter}\n     * @alias selectSeries\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n     * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n     * with a boolean argument once it has completed. Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called after all the\n     * `iteratee` functions have finished. Invoked with (err, results)\n     * @returns {Promise} a promise, if no callback provided\n     */\n    function filterSeries (coll, iteratee, callback) {\n        return _filter(eachOfSeries$1, coll, iteratee, callback)\n    }\n    var filterSeries$1 = awaitify(filterSeries, 3);\n\n    /**\n     * Calls the asynchronous function `fn` with a callback parameter that allows it\n     * to call itself again, in series, indefinitely.\n\n     * If an error is passed to the callback then `errback` is called with the\n     * error, and execution stops, otherwise it will never be called.\n     *\n     * @name forever\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @category Control Flow\n     * @param {AsyncFunction} fn - an async function to call repeatedly.\n     * Invoked with (next).\n     * @param {Function} [errback] - when `fn` passes an error to it's callback,\n     * this function will be called, and execution stops. Invoked with (err).\n     * @returns {Promise} a promise that rejects if an error occurs and an errback\n     * is not passed\n     * @example\n     *\n     * async.forever(\n     *     function(next) {\n     *         // next is suitable for passing to things that need a callback(err [, whatever]);\n     *         // it will result in this function being called again.\n     *     },\n     *     function(err) {\n     *         // if next is called with a value in its first parameter, it will appear\n     *         // in here as 'err', and execution will stop.\n     *     }\n     * );\n     */\n    function forever(fn, errback) {\n        var done = onlyOnce(errback);\n        var task = wrapAsync(ensureAsync(fn));\n\n        function next(err) {\n            if (err) return done(err);\n            if (err === false) return;\n            task(next);\n        }\n        return next();\n    }\n    var forever$1 = awaitify(forever, 2);\n\n    /**\n     * The same as [`groupBy`]{@link module:Collections.groupBy} but runs a maximum of `limit` async operations at a time.\n     *\n     * @name groupByLimit\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.groupBy]{@link module:Collections.groupBy}\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {number} limit - The maximum number of async operations at a time.\n     * @param {AsyncFunction} iteratee - An async function to apply to each item in\n     * `coll`.\n     * The iteratee should complete with a `key` to group the value under.\n     * Invoked with (value, callback).\n     * @param {Function} [callback] - A callback which is called when all `iteratee`\n     * functions have finished, or an error occurs. Result is an `Object` whoses\n     * properties are arrays of values which returned the corresponding key.\n     * @returns {Promise} a promise, if no callback is passed\n     */\n    function groupByLimit(coll, limit, iteratee, callback) {\n        var _iteratee = wrapAsync(iteratee);\n        return mapLimit$1(coll, limit, (val, iterCb) => {\n            _iteratee(val, (err, key) => {\n                if (err) return iterCb(err);\n                return iterCb(err, {key, val});\n            });\n        }, (err, mapResults) => {\n            var result = {};\n            // from MDN, handle object having an `hasOwnProperty` prop\n            var {hasOwnProperty} = Object.prototype;\n\n            for (var i = 0; i < mapResults.length; i++) {\n                if (mapResults[i]) {\n                    var {key} = mapResults[i];\n                    var {val} = mapResults[i];\n\n                    if (hasOwnProperty.call(result, key)) {\n                        result[key].push(val);\n                    } else {\n                        result[key] = [val];\n                    }\n                }\n            }\n\n            return callback(err, result);\n        });\n    }\n\n    var groupByLimit$1 = awaitify(groupByLimit, 4);\n\n    /**\n     * Returns a new object, where each value corresponds to an array of items, from\n     * `coll`, that returned the corresponding key. That is, the keys of the object\n     * correspond to the values passed to the `iteratee` callback.\n     *\n     * Note: Since this function applies the `iteratee` to each item in parallel,\n     * there is no guarantee that the `iteratee` functions will complete in order.\n     * However, the values for each key in the `result` will be in the same order as\n     * the original `coll`. For Objects, the values will roughly be in the order of\n     * the original Objects' keys (but this can vary across JavaScript engines).\n     *\n     * @name groupBy\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {AsyncFunction} iteratee - An async function to apply to each item in\n     * `coll`.\n     * The iteratee should complete with a `key` to group the value under.\n     * Invoked with (value, callback).\n     * @param {Function} [callback] - A callback which is called when all `iteratee`\n     * functions have finished, or an error occurs. Result is an `Object` whoses\n     * properties are arrays of values which returned the corresponding key.\n     * @returns {Promise} a promise, if no callback is passed\n     * @example\n     *\n     * // dir1 is a directory that contains file1.txt, file2.txt\n     * // dir2 is a directory that contains file3.txt, file4.txt\n     * // dir3 is a directory that contains file5.txt\n     * // dir4 does not exist\n     *\n     * const files = ['dir1/file1.txt','dir2','dir4']\n     *\n     * // asynchronous function that detects file type as none, file, or directory\n     * function detectFile(file, callback) {\n     *     fs.stat(file, function(err, stat) {\n     *         if (err) {\n     *             return callback(null, 'none');\n     *         }\n     *         callback(null, stat.isDirectory() ? 'directory' : 'file');\n     *     });\n     * }\n     *\n     * //Using callbacks\n     * async.groupBy(files, detectFile, function(err, result) {\n     *     if(err) {\n     *         console.log(err);\n     *     } else {\n     *\t       console.log(result);\n     *         // {\n     *         //     file: [ 'dir1/file1.txt' ],\n     *         //     none: [ 'dir4' ],\n     *         //     directory: [ 'dir2']\n     *         // }\n     *         // result is object containing the files grouped by type\n     *     }\n     * });\n     *\n     * // Using Promises\n     * async.groupBy(files, detectFile)\n     * .then( result => {\n     *     console.log(result);\n     *     // {\n     *     //     file: [ 'dir1/file1.txt' ],\n     *     //     none: [ 'dir4' ],\n     *     //     directory: [ 'dir2']\n     *     // }\n     *     // result is object containing the files grouped by type\n     * }).catch( err => {\n     *     console.log(err);\n     * });\n     *\n     * // Using async/await\n     * async () => {\n     *     try {\n     *         let result = await async.groupBy(files, detectFile);\n     *         console.log(result);\n     *         // {\n     *         //     file: [ 'dir1/file1.txt' ],\n     *         //     none: [ 'dir4' ],\n     *         //     directory: [ 'dir2']\n     *         // }\n     *         // result is object containing the files grouped by type\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *     }\n     * }\n     *\n     */\n    function groupBy (coll, iteratee, callback) {\n        return groupByLimit$1(coll, Infinity, iteratee, callback)\n    }\n\n    /**\n     * The same as [`groupBy`]{@link module:Collections.groupBy} but runs only a single async operation at a time.\n     *\n     * @name groupBySeries\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.groupBy]{@link module:Collections.groupBy}\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {AsyncFunction} iteratee - An async function to apply to each item in\n     * `coll`.\n     * The iteratee should complete with a `key` to group the value under.\n     * Invoked with (value, callback).\n     * @param {Function} [callback] - A callback which is called when all `iteratee`\n     * functions have finished, or an error occurs. Result is an `Object` whose\n     * properties are arrays of values which returned the corresponding key.\n     * @returns {Promise} a promise, if no callback is passed\n     */\n    function groupBySeries (coll, iteratee, callback) {\n        return groupByLimit$1(coll, 1, iteratee, callback)\n    }\n\n    /**\n     * Logs the result of an `async` function to the `console`. Only works in\n     * Node.js or in browsers that support `console.log` and `console.error` (such\n     * as FF and Chrome). If multiple arguments are returned from the async\n     * function, `console.log` is called on each argument in order.\n     *\n     * @name log\n     * @static\n     * @memberOf module:Utils\n     * @method\n     * @category Util\n     * @param {AsyncFunction} function - The function you want to eventually apply\n     * all arguments to.\n     * @param {...*} arguments... - Any number of arguments to apply to the function.\n     * @example\n     *\n     * // in a module\n     * var hello = function(name, callback) {\n     *     setTimeout(function() {\n     *         callback(null, 'hello ' + name);\n     *     }, 1000);\n     * };\n     *\n     * // in the node repl\n     * node> async.log(hello, 'world');\n     * 'hello world'\n     */\n    var log = consoleFunc('log');\n\n    /**\n     * The same as [`mapValues`]{@link module:Collections.mapValues} but runs a maximum of `limit` async operations at a\n     * time.\n     *\n     * @name mapValuesLimit\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.mapValues]{@link module:Collections.mapValues}\n     * @category Collection\n     * @param {Object} obj - A collection to iterate over.\n     * @param {number} limit - The maximum number of async operations at a time.\n     * @param {AsyncFunction} iteratee - A function to apply to each value and key\n     * in `coll`.\n     * The iteratee should complete with the transformed value as its result.\n     * Invoked with (value, key, callback).\n     * @param {Function} [callback] - A callback which is called when all `iteratee`\n     * functions have finished, or an error occurs. `result` is a new object consisting\n     * of each key from `obj`, with each transformed value on the right-hand side.\n     * Invoked with (err, result).\n     * @returns {Promise} a promise, if no callback is passed\n     */\n    function mapValuesLimit(obj, limit, iteratee, callback) {\n        callback = once(callback);\n        var newObj = {};\n        var _iteratee = wrapAsync(iteratee);\n        return eachOfLimit(limit)(obj, (val, key, next) => {\n            _iteratee(val, key, (err, result) => {\n                if (err) return next(err);\n                newObj[key] = result;\n                next(err);\n            });\n        }, err => callback(err, newObj));\n    }\n\n    var mapValuesLimit$1 = awaitify(mapValuesLimit, 4);\n\n    /**\n     * A relative of [`map`]{@link module:Collections.map}, designed for use with objects.\n     *\n     * Produces a new Object by mapping each value of `obj` through the `iteratee`\n     * function. The `iteratee` is called each `value` and `key` from `obj` and a\n     * callback for when it has finished processing. Each of these callbacks takes\n     * two arguments: an `error`, and the transformed item from `obj`. If `iteratee`\n     * passes an error to its callback, the main `callback` (for the `mapValues`\n     * function) is immediately called with the error.\n     *\n     * Note, the order of the keys in the result is not guaranteed.  The keys will\n     * be roughly in the order they complete, (but this is very engine-specific)\n     *\n     * @name mapValues\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @category Collection\n     * @param {Object} obj - A collection to iterate over.\n     * @param {AsyncFunction} iteratee - A function to apply to each value and key\n     * in `coll`.\n     * The iteratee should complete with the transformed value as its result.\n     * Invoked with (value, key, callback).\n     * @param {Function} [callback] - A callback which is called when all `iteratee`\n     * functions have finished, or an error occurs. `result` is a new object consisting\n     * of each key from `obj`, with each transformed value on the right-hand side.\n     * Invoked with (err, result).\n     * @returns {Promise} a promise, if no callback is passed\n     * @example\n     *\n     * // file1.txt is a file that is 1000 bytes in size\n     * // file2.txt is a file that is 2000 bytes in size\n     * // file3.txt is a file that is 3000 bytes in size\n     * // file4.txt does not exist\n     *\n     * const fileMap = {\n     *     f1: 'file1.txt',\n     *     f2: 'file2.txt',\n     *     f3: 'file3.txt'\n     * };\n     *\n     * const withMissingFileMap = {\n     *     f1: 'file1.txt',\n     *     f2: 'file2.txt',\n     *     f3: 'file4.txt'\n     * };\n     *\n     * // asynchronous function that returns the file size in bytes\n     * function getFileSizeInBytes(file, key, callback) {\n     *     fs.stat(file, function(err, stat) {\n     *         if (err) {\n     *             return callback(err);\n     *         }\n     *         callback(null, stat.size);\n     *     });\n     * }\n     *\n     * // Using callbacks\n     * async.mapValues(fileMap, getFileSizeInBytes, function(err, result) {\n     *     if (err) {\n     *         console.log(err);\n     *     } else {\n     *         console.log(result);\n     *         // result is now a map of file size in bytes for each file, e.g.\n     *         // {\n     *         //     f1: 1000,\n     *         //     f2: 2000,\n     *         //     f3: 3000\n     *         // }\n     *     }\n     * });\n     *\n     * // Error handling\n     * async.mapValues(withMissingFileMap, getFileSizeInBytes, function(err, result) {\n     *     if (err) {\n     *         console.log(err);\n     *         // [ Error: ENOENT: no such file or directory ]\n     *     } else {\n     *         console.log(result);\n     *     }\n     * });\n     *\n     * // Using Promises\n     * async.mapValues(fileMap, getFileSizeInBytes)\n     * .then( result => {\n     *     console.log(result);\n     *     // result is now a map of file size in bytes for each file, e.g.\n     *     // {\n     *     //     f1: 1000,\n     *     //     f2: 2000,\n     *     //     f3: 3000\n     *     // }\n     * }).catch (err => {\n     *     console.log(err);\n     * });\n     *\n     * // Error Handling\n     * async.mapValues(withMissingFileMap, getFileSizeInBytes)\n     * .then( result => {\n     *     console.log(result);\n     * }).catch (err => {\n     *     console.log(err);\n     *     // [ Error: ENOENT: no such file or directory ]\n     * });\n     *\n     * // Using async/await\n     * async () => {\n     *     try {\n     *         let result = await async.mapValues(fileMap, getFileSizeInBytes);\n     *         console.log(result);\n     *         // result is now a map of file size in bytes for each file, e.g.\n     *         // {\n     *         //     f1: 1000,\n     *         //     f2: 2000,\n     *         //     f3: 3000\n     *         // }\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *     }\n     * }\n     *\n     * // Error Handling\n     * async () => {\n     *     try {\n     *         let result = await async.mapValues(withMissingFileMap, getFileSizeInBytes);\n     *         console.log(result);\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *         // [ Error: ENOENT: no such file or directory ]\n     *     }\n     * }\n     *\n     */\n    function mapValues(obj, iteratee, callback) {\n        return mapValuesLimit$1(obj, Infinity, iteratee, callback)\n    }\n\n    /**\n     * The same as [`mapValues`]{@link module:Collections.mapValues} but runs only a single async operation at a time.\n     *\n     * @name mapValuesSeries\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.mapValues]{@link module:Collections.mapValues}\n     * @category Collection\n     * @param {Object} obj - A collection to iterate over.\n     * @param {AsyncFunction} iteratee - A function to apply to each value and key\n     * in `coll`.\n     * The iteratee should complete with the transformed value as its result.\n     * Invoked with (value, key, callback).\n     * @param {Function} [callback] - A callback which is called when all `iteratee`\n     * functions have finished, or an error occurs. `result` is a new object consisting\n     * of each key from `obj`, with each transformed value on the right-hand side.\n     * Invoked with (err, result).\n     * @returns {Promise} a promise, if no callback is passed\n     */\n    function mapValuesSeries(obj, iteratee, callback) {\n        return mapValuesLimit$1(obj, 1, iteratee, callback)\n    }\n\n    /**\n     * Caches the results of an async function. When creating a hash to store\n     * function results against, the callback is omitted from the hash and an\n     * optional hash function can be used.\n     *\n     * **Note: if the async function errs, the result will not be cached and\n     * subsequent calls will call the wrapped function.**\n     *\n     * If no hash function is specified, the first argument is used as a hash key,\n     * which may work reasonably if it is a string or a data type that converts to a\n     * distinct string. Note that objects and arrays will not behave reasonably.\n     * Neither will cases where the other arguments are significant. In such cases,\n     * specify your own hash function.\n     *\n     * The cache of results is exposed as the `memo` property of the function\n     * returned by `memoize`.\n     *\n     * @name memoize\n     * @static\n     * @memberOf module:Utils\n     * @method\n     * @category Util\n     * @param {AsyncFunction} fn - The async function to proxy and cache results from.\n     * @param {Function} hasher - An optional function for generating a custom hash\n     * for storing results. It has all the arguments applied to it apart from the\n     * callback, and must be synchronous.\n     * @returns {AsyncFunction} a memoized version of `fn`\n     * @example\n     *\n     * var slow_fn = function(name, callback) {\n     *     // do something\n     *     callback(null, result);\n     * };\n     * var fn = async.memoize(slow_fn);\n     *\n     * // fn can now be used as if it were slow_fn\n     * fn('some name', function() {\n     *     // callback\n     * });\n     */\n    function memoize(fn, hasher = v => v) {\n        var memo = Object.create(null);\n        var queues = Object.create(null);\n        var _fn = wrapAsync(fn);\n        var memoized = initialParams((args, callback) => {\n            var key = hasher(...args);\n            if (key in memo) {\n                setImmediate$1(() => callback(null, ...memo[key]));\n            } else if (key in queues) {\n                queues[key].push(callback);\n            } else {\n                queues[key] = [callback];\n                _fn(...args, (err, ...resultArgs) => {\n                    // #1465 don't memoize if an error occurred\n                    if (!err) {\n                        memo[key] = resultArgs;\n                    }\n                    var q = queues[key];\n                    delete queues[key];\n                    for (var i = 0, l = q.length; i < l; i++) {\n                        q[i](err, ...resultArgs);\n                    }\n                });\n            }\n        });\n        memoized.memo = memo;\n        memoized.unmemoized = fn;\n        return memoized;\n    }\n\n    /* istanbul ignore file */\n\n    /**\n     * Calls `callback` on a later loop around the event loop. In Node.js this just\n     * calls `process.nextTick`.  In the browser it will use `setImmediate` if\n     * available, otherwise `setTimeout(callback, 0)`, which means other higher\n     * priority events may precede the execution of `callback`.\n     *\n     * This is used internally for browser-compatibility purposes.\n     *\n     * @name nextTick\n     * @static\n     * @memberOf module:Utils\n     * @method\n     * @see [async.setImmediate]{@link module:Utils.setImmediate}\n     * @category Util\n     * @param {Function} callback - The function to call on a later loop around\n     * the event loop. Invoked with (args...).\n     * @param {...*} args... - any number of additional arguments to pass to the\n     * callback on the next tick.\n     * @example\n     *\n     * var call_order = [];\n     * async.nextTick(function() {\n     *     call_order.push('two');\n     *     // call_order now equals ['one','two']\n     * });\n     * call_order.push('one');\n     *\n     * async.setImmediate(function (a, b, c) {\n     *     // a, b, and c equal 1, 2, and 3\n     * }, 1, 2, 3);\n     */\n    var _defer$1;\n\n    if (hasNextTick) {\n        _defer$1 = process.nextTick;\n    } else if (hasSetImmediate) {\n        _defer$1 = setImmediate;\n    } else {\n        _defer$1 = fallback;\n    }\n\n    var nextTick = wrap(_defer$1);\n\n    var parallel = awaitify((eachfn, tasks, callback) => {\n        var results = isArrayLike(tasks) ? [] : {};\n\n        eachfn(tasks, (task, key, taskCb) => {\n            wrapAsync(task)((err, ...result) => {\n                if (result.length < 2) {\n                    [result] = result;\n                }\n                results[key] = result;\n                taskCb(err);\n            });\n        }, err => callback(err, results));\n    }, 3);\n\n    /**\n     * Run the `tasks` collection of functions in parallel, without waiting until\n     * the previous function has completed. If any of the functions pass an error to\n     * its callback, the main `callback` is immediately called with the value of the\n     * error. Once the `tasks` have completed, the results are passed to the final\n     * `callback` as an array.\n     *\n     * **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about\n     * parallel execution of code.  If your tasks do not use any timers or perform\n     * any I/O, they will actually be executed in series.  Any synchronous setup\n     * sections for each task will happen one after the other.  JavaScript remains\n     * single-threaded.\n     *\n     * **Hint:** Use [`reflect`]{@link module:Utils.reflect} to continue the\n     * execution of other tasks when a task fails.\n     *\n     * It is also possible to use an object instead of an array. Each property will\n     * be run as a function and the results will be passed to the final `callback`\n     * as an object instead of an array. This can be a more readable way of handling\n     * results from {@link async.parallel}.\n     *\n     * @name parallel\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @category Control Flow\n     * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection of\n     * [async functions]{@link AsyncFunction} to run.\n     * Each async function can complete with any number of optional `result` values.\n     * @param {Function} [callback] - An optional callback to run once all the\n     * functions have completed successfully. This function gets a results array\n     * (or object) containing all the result arguments passed to the task callbacks.\n     * Invoked with (err, results).\n     * @returns {Promise} a promise, if a callback is not passed\n     *\n     * @example\n     *\n     * //Using Callbacks\n     * async.parallel([\n     *     function(callback) {\n     *         setTimeout(function() {\n     *             callback(null, 'one');\n     *         }, 200);\n     *     },\n     *     function(callback) {\n     *         setTimeout(function() {\n     *             callback(null, 'two');\n     *         }, 100);\n     *     }\n     * ], function(err, results) {\n     *     console.log(results);\n     *     // results is equal to ['one','two'] even though\n     *     // the second function had a shorter timeout.\n     * });\n     *\n     * // an example using an object instead of an array\n     * async.parallel({\n     *     one: function(callback) {\n     *         setTimeout(function() {\n     *             callback(null, 1);\n     *         }, 200);\n     *     },\n     *     two: function(callback) {\n     *         setTimeout(function() {\n     *             callback(null, 2);\n     *         }, 100);\n     *     }\n     * }, function(err, results) {\n     *     console.log(results);\n     *     // results is equal to: { one: 1, two: 2 }\n     * });\n     *\n     * //Using Promises\n     * async.parallel([\n     *     function(callback) {\n     *         setTimeout(function() {\n     *             callback(null, 'one');\n     *         }, 200);\n     *     },\n     *     function(callback) {\n     *         setTimeout(function() {\n     *             callback(null, 'two');\n     *         }, 100);\n     *     }\n     * ]).then(results => {\n     *     console.log(results);\n     *     // results is equal to ['one','two'] even though\n     *     // the second function had a shorter timeout.\n     * }).catch(err => {\n     *     console.log(err);\n     * });\n     *\n     * // an example using an object instead of an array\n     * async.parallel({\n     *     one: function(callback) {\n     *         setTimeout(function() {\n     *             callback(null, 1);\n     *         }, 200);\n     *     },\n     *     two: function(callback) {\n     *         setTimeout(function() {\n     *             callback(null, 2);\n     *         }, 100);\n     *     }\n     * }).then(results => {\n     *     console.log(results);\n     *     // results is equal to: { one: 1, two: 2 }\n     * }).catch(err => {\n     *     console.log(err);\n     * });\n     *\n     * //Using async/await\n     * async () => {\n     *     try {\n     *         let results = await async.parallel([\n     *             function(callback) {\n     *                 setTimeout(function() {\n     *                     callback(null, 'one');\n     *                 }, 200);\n     *             },\n     *             function(callback) {\n     *                 setTimeout(function() {\n     *                     callback(null, 'two');\n     *                 }, 100);\n     *             }\n     *         ]);\n     *         console.log(results);\n     *         // results is equal to ['one','two'] even though\n     *         // the second function had a shorter timeout.\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *     }\n     * }\n     *\n     * // an example using an object instead of an array\n     * async () => {\n     *     try {\n     *         let results = await async.parallel({\n     *             one: function(callback) {\n     *                 setTimeout(function() {\n     *                     callback(null, 1);\n     *                 }, 200);\n     *             },\n     *            two: function(callback) {\n     *                 setTimeout(function() {\n     *                     callback(null, 2);\n     *                 }, 100);\n     *            }\n     *         });\n     *         console.log(results);\n     *         // results is equal to: { one: 1, two: 2 }\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *     }\n     * }\n     *\n     */\n    function parallel$1(tasks, callback) {\n        return parallel(eachOf$1, tasks, callback);\n    }\n\n    /**\n     * The same as [`parallel`]{@link module:ControlFlow.parallel} but runs a maximum of `limit` async operations at a\n     * time.\n     *\n     * @name parallelLimit\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @see [async.parallel]{@link module:ControlFlow.parallel}\n     * @category Control Flow\n     * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection of\n     * [async functions]{@link AsyncFunction} to run.\n     * Each async function can complete with any number of optional `result` values.\n     * @param {number} limit - The maximum number of async operations at a time.\n     * @param {Function} [callback] - An optional callback to run once all the\n     * functions have completed successfully. This function gets a results array\n     * (or object) containing all the result arguments passed to the task callbacks.\n     * Invoked with (err, results).\n     * @returns {Promise} a promise, if a callback is not passed\n     */\n    function parallelLimit(tasks, limit, callback) {\n        return parallel(eachOfLimit(limit), tasks, callback);\n    }\n\n    /**\n     * A queue of tasks for the worker function to complete.\n     * @typedef {Iterable} QueueObject\n     * @memberOf module:ControlFlow\n     * @property {Function} length - a function returning the number of items\n     * waiting to be processed. Invoke with `queue.length()`.\n     * @property {boolean} started - a boolean indicating whether or not any\n     * items have been pushed and processed by the queue.\n     * @property {Function} running - a function returning the number of items\n     * currently being processed. Invoke with `queue.running()`.\n     * @property {Function} workersList - a function returning the array of items\n     * currently being processed. Invoke with `queue.workersList()`.\n     * @property {Function} idle - a function returning false if there are items\n     * waiting or being processed, or true if not. Invoke with `queue.idle()`.\n     * @property {number} concurrency - an integer for determining how many `worker`\n     * functions should be run in parallel. This property can be changed after a\n     * `queue` is created to alter the concurrency on-the-fly.\n     * @property {number} payload - an integer that specifies how many items are\n     * passed to the worker function at a time. only applies if this is a\n     * [cargo]{@link module:ControlFlow.cargo} object\n     * @property {AsyncFunction} push - add a new task to the `queue`. Calls `callback`\n     * once the `worker` has finished processing the task. Instead of a single task,\n     * a `tasks` array can be submitted. The respective callback is used for every\n     * task in the list. Invoke with `queue.push(task, [callback])`,\n     * @property {AsyncFunction} unshift - add a new task to the front of the `queue`.\n     * Invoke with `queue.unshift(task, [callback])`.\n     * @property {AsyncFunction} pushAsync - the same as `q.push`, except this returns\n     * a promise that rejects if an error occurs.\n     * @property {AsyncFunction} unshiftAsync - the same as `q.unshift`, except this returns\n     * a promise that rejects if an error occurs.\n     * @property {Function} remove - remove items from the queue that match a test\n     * function.  The test function will be passed an object with a `data` property,\n     * and a `priority` property, if this is a\n     * [priorityQueue]{@link module:ControlFlow.priorityQueue} object.\n     * Invoked with `queue.remove(testFn)`, where `testFn` is of the form\n     * `function ({data, priority}) {}` and returns a Boolean.\n     * @property {Function} saturated - a function that sets a callback that is\n     * called when the number of running workers hits the `concurrency` limit, and\n     * further tasks will be queued.  If the callback is omitted, `q.saturated()`\n     * returns a promise for the next occurrence.\n     * @property {Function} unsaturated - a function that sets a callback that is\n     * called when the number of running workers is less than the `concurrency` &\n     * `buffer` limits, and further tasks will not be queued. If the callback is\n     * omitted, `q.unsaturated()` returns a promise for the next occurrence.\n     * @property {number} buffer - A minimum threshold buffer in order to say that\n     * the `queue` is `unsaturated`.\n     * @property {Function} empty - a function that sets a callback that is called\n     * when the last item from the `queue` is given to a `worker`. If the callback\n     * is omitted, `q.empty()` returns a promise for the next occurrence.\n     * @property {Function} drain - a function that sets a callback that is called\n     * when the last item from the `queue` has returned from the `worker`. If the\n     * callback is omitted, `q.drain()` returns a promise for the next occurrence.\n     * @property {Function} error - a function that sets a callback that is called\n     * when a task errors. Has the signature `function(error, task)`. If the\n     * callback is omitted, `error()` returns a promise that rejects on the next\n     * error.\n     * @property {boolean} paused - a boolean for determining whether the queue is\n     * in a paused state.\n     * @property {Function} pause - a function that pauses the processing of tasks\n     * until `resume()` is called. Invoke with `queue.pause()`.\n     * @property {Function} resume - a function that resumes the processing of\n     * queued tasks when the queue is paused. Invoke with `queue.resume()`.\n     * @property {Function} kill - a function that removes the `drain` callback and\n     * empties remaining tasks from the queue forcing it to go idle. No more tasks\n     * should be pushed to the queue after calling this function. Invoke with `queue.kill()`.\n     *\n     * @example\n     * const q = async.queue(worker, 2)\n     * q.push(item1)\n     * q.push(item2)\n     * q.push(item3)\n     * // queues are iterable, spread into an array to inspect\n     * const items = [...q] // [item1, item2, item3]\n     * // or use for of\n     * for (let item of q) {\n     *     console.log(item)\n     * }\n     *\n     * q.drain(() => {\n     *     console.log('all done')\n     * })\n     * // or\n     * await q.drain()\n     */\n\n    /**\n     * Creates a `queue` object with the specified `concurrency`. Tasks added to the\n     * `queue` are processed in parallel (up to the `concurrency` limit). If all\n     * `worker`s are in progress, the task is queued until one becomes available.\n     * Once a `worker` completes a `task`, that `task`'s callback is called.\n     *\n     * @name queue\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @category Control Flow\n     * @param {AsyncFunction} worker - An async function for processing a queued task.\n     * If you want to handle errors from an individual task, pass a callback to\n     * `q.push()`. Invoked with (task, callback).\n     * @param {number} [concurrency=1] - An `integer` for determining how many\n     * `worker` functions should be run in parallel.  If omitted, the concurrency\n     * defaults to `1`.  If the concurrency is `0`, an error is thrown.\n     * @returns {module:ControlFlow.QueueObject} A queue object to manage the tasks. Callbacks can be\n     * attached as certain properties to listen for specific events during the\n     * lifecycle of the queue.\n     * @example\n     *\n     * // create a queue object with concurrency 2\n     * var q = async.queue(function(task, callback) {\n     *     console.log('hello ' + task.name);\n     *     callback();\n     * }, 2);\n     *\n     * // assign a callback\n     * q.drain(function() {\n     *     console.log('all items have been processed');\n     * });\n     * // or await the end\n     * await q.drain()\n     *\n     * // assign an error callback\n     * q.error(function(err, task) {\n     *     console.error('task experienced an error');\n     * });\n     *\n     * // add some items to the queue\n     * q.push({name: 'foo'}, function(err) {\n     *     console.log('finished processing foo');\n     * });\n     * // callback is optional\n     * q.push({name: 'bar'});\n     *\n     * // add some items to the queue (batch-wise)\n     * q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function(err) {\n     *     console.log('finished processing item');\n     * });\n     *\n     * // add some items to the front of the queue\n     * q.unshift({name: 'bar'}, function (err) {\n     *     console.log('finished processing bar');\n     * });\n     */\n    function queue$1 (worker, concurrency) {\n        var _worker = wrapAsync(worker);\n        return queue((items, cb) => {\n            _worker(items[0], cb);\n        }, concurrency, 1);\n    }\n\n    // Binary min-heap implementation used for priority queue.\n    // Implementation is stable, i.e. push time is considered for equal priorities\n    class Heap {\n        constructor() {\n            this.heap = [];\n            this.pushCount = Number.MIN_SAFE_INTEGER;\n        }\n\n        get length() {\n            return this.heap.length;\n        }\n\n        empty () {\n            this.heap = [];\n            return this;\n        }\n\n        percUp(index) {\n            let p;\n\n            while (index > 0 && smaller(this.heap[index], this.heap[p=parent(index)])) {\n                let t = this.heap[index];\n                this.heap[index] = this.heap[p];\n                this.heap[p] = t;\n\n                index = p;\n            }\n        }\n\n        percDown(index) {\n            let l;\n\n            while ((l=leftChi(index)) < this.heap.length) {\n                if (l+1 < this.heap.length && smaller(this.heap[l+1], this.heap[l])) {\n                    l = l+1;\n                }\n\n                if (smaller(this.heap[index], this.heap[l])) {\n                    break;\n                }\n\n                let t = this.heap[index];\n                this.heap[index] = this.heap[l];\n                this.heap[l] = t;\n\n                index = l;\n            }\n        }\n\n        push(node) {\n            node.pushCount = ++this.pushCount;\n            this.heap.push(node);\n            this.percUp(this.heap.length-1);\n        }\n\n        unshift(node) {\n            return this.heap.push(node);\n        }\n\n        shift() {\n            let [top] = this.heap;\n\n            this.heap[0] = this.heap[this.heap.length-1];\n            this.heap.pop();\n            this.percDown(0);\n\n            return top;\n        }\n\n        toArray() {\n            return [...this];\n        }\n\n        *[Symbol.iterator] () {\n            for (let i = 0; i < this.heap.length; i++) {\n                yield this.heap[i].data;\n            }\n        }\n\n        remove (testFn) {\n            let j = 0;\n            for (let i = 0; i < this.heap.length; i++) {\n                if (!testFn(this.heap[i])) {\n                    this.heap[j] = this.heap[i];\n                    j++;\n                }\n            }\n\n            this.heap.splice(j);\n\n            for (let i = parent(this.heap.length-1); i >= 0; i--) {\n                this.percDown(i);\n            }\n\n            return this;\n        }\n    }\n\n    function leftChi(i) {\n        return (i<<1)+1;\n    }\n\n    function parent(i) {\n        return ((i+1)>>1)-1;\n    }\n\n    function smaller(x, y) {\n        if (x.priority !== y.priority) {\n            return x.priority < y.priority;\n        }\n        else {\n            return x.pushCount < y.pushCount;\n        }\n    }\n\n    /**\n     * The same as [async.queue]{@link module:ControlFlow.queue} only tasks are assigned a priority and\n     * completed in ascending priority order.\n     *\n     * @name priorityQueue\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @see [async.queue]{@link module:ControlFlow.queue}\n     * @category Control Flow\n     * @param {AsyncFunction} worker - An async function for processing a queued task.\n     * If you want to handle errors from an individual task, pass a callback to\n     * `q.push()`.\n     * Invoked with (task, callback).\n     * @param {number} concurrency - An `integer` for determining how many `worker`\n     * functions should be run in parallel.  If omitted, the concurrency defaults to\n     * `1`.  If the concurrency is `0`, an error is thrown.\n     * @returns {module:ControlFlow.QueueObject} A priorityQueue object to manage the tasks. There are three\n     * differences between `queue` and `priorityQueue` objects:\n     * * `push(task, priority, [callback])` - `priority` should be a number. If an\n     *   array of `tasks` is given, all tasks will be assigned the same priority.\n     * * `pushAsync(task, priority, [callback])` - the same as `priorityQueue.push`,\n     *   except this returns a promise that rejects if an error occurs.\n     * * The `unshift` and `unshiftAsync` methods were removed.\n     */\n    function priorityQueue(worker, concurrency) {\n        // Start with a normal queue\n        var q = queue$1(worker, concurrency);\n\n        var {\n            push,\n            pushAsync\n        } = q;\n\n        q._tasks = new Heap();\n        q._createTaskItem = ({data, priority}, callback) => {\n            return {\n                data,\n                priority,\n                callback\n            };\n        };\n\n        function createDataItems(tasks, priority) {\n            if (!Array.isArray(tasks)) {\n                return {data: tasks, priority};\n            }\n            return tasks.map(data => { return {data, priority}; });\n        }\n\n        // Override push to accept second parameter representing priority\n        q.push = function(data, priority = 0, callback) {\n            return push(createDataItems(data, priority), callback);\n        };\n\n        q.pushAsync = function(data, priority = 0, callback) {\n            return pushAsync(createDataItems(data, priority), callback);\n        };\n\n        // Remove unshift functions\n        delete q.unshift;\n        delete q.unshiftAsync;\n\n        return q;\n    }\n\n    /**\n     * Runs the `tasks` array of functions in parallel, without waiting until the\n     * previous function has completed. Once any of the `tasks` complete or pass an\n     * error to its callback, the main `callback` is immediately called. It's\n     * equivalent to `Promise.race()`.\n     *\n     * @name race\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @category Control Flow\n     * @param {Array} tasks - An array containing [async functions]{@link AsyncFunction}\n     * to run. Each function can complete with an optional `result` value.\n     * @param {Function} callback - A callback to run once any of the functions have\n     * completed. This function gets an error or result from the first function that\n     * completed. Invoked with (err, result).\n     * @returns {Promise} a promise, if a callback is omitted\n     * @example\n     *\n     * async.race([\n     *     function(callback) {\n     *         setTimeout(function() {\n     *             callback(null, 'one');\n     *         }, 200);\n     *     },\n     *     function(callback) {\n     *         setTimeout(function() {\n     *             callback(null, 'two');\n     *         }, 100);\n     *     }\n     * ],\n     * // main callback\n     * function(err, result) {\n     *     // the result will be equal to 'two' as it finishes earlier\n     * });\n     */\n    function race(tasks, callback) {\n        callback = once(callback);\n        if (!Array.isArray(tasks)) return callback(new TypeError('First argument to race must be an array of functions'));\n        if (!tasks.length) return callback();\n        for (var i = 0, l = tasks.length; i < l; i++) {\n            wrapAsync(tasks[i])(callback);\n        }\n    }\n\n    var race$1 = awaitify(race, 2);\n\n    /**\n     * Same as [`reduce`]{@link module:Collections.reduce}, only operates on `array` in reverse order.\n     *\n     * @name reduceRight\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.reduce]{@link module:Collections.reduce}\n     * @alias foldr\n     * @category Collection\n     * @param {Array} array - A collection to iterate over.\n     * @param {*} memo - The initial state of the reduction.\n     * @param {AsyncFunction} iteratee - A function applied to each item in the\n     * array to produce the next step in the reduction.\n     * The `iteratee` should complete with the next state of the reduction.\n     * If the iteratee completes with an error, the reduction is stopped and the\n     * main `callback` is immediately called with the error.\n     * Invoked with (memo, item, callback).\n     * @param {Function} [callback] - A callback which is called after all the\n     * `iteratee` functions have finished. Result is the reduced value. Invoked with\n     * (err, result).\n     * @returns {Promise} a promise, if no callback is passed\n     */\n    function reduceRight (array, memo, iteratee, callback) {\n        var reversed = [...array].reverse();\n        return reduce$1(reversed, memo, iteratee, callback);\n    }\n\n    /**\n     * Wraps the async function in another function that always completes with a\n     * result object, even when it errors.\n     *\n     * The result object has either the property `error` or `value`.\n     *\n     * @name reflect\n     * @static\n     * @memberOf module:Utils\n     * @method\n     * @category Util\n     * @param {AsyncFunction} fn - The async function you want to wrap\n     * @returns {Function} - A function that always passes null to it's callback as\n     * the error. The second argument to the callback will be an `object` with\n     * either an `error` or a `value` property.\n     * @example\n     *\n     * async.parallel([\n     *     async.reflect(function(callback) {\n     *         // do some stuff ...\n     *         callback(null, 'one');\n     *     }),\n     *     async.reflect(function(callback) {\n     *         // do some more stuff but error ...\n     *         callback('bad stuff happened');\n     *     }),\n     *     async.reflect(function(callback) {\n     *         // do some more stuff ...\n     *         callback(null, 'two');\n     *     })\n     * ],\n     * // optional callback\n     * function(err, results) {\n     *     // values\n     *     // results[0].value = 'one'\n     *     // results[1].error = 'bad stuff happened'\n     *     // results[2].value = 'two'\n     * });\n     */\n    function reflect(fn) {\n        var _fn = wrapAsync(fn);\n        return initialParams(function reflectOn(args, reflectCallback) {\n            args.push((error, ...cbArgs) => {\n                let retVal = {};\n                if (error) {\n                    retVal.error = error;\n                }\n                if (cbArgs.length > 0){\n                    var value = cbArgs;\n                    if (cbArgs.length <= 1) {\n                        [value] = cbArgs;\n                    }\n                    retVal.value = value;\n                }\n                reflectCallback(null, retVal);\n            });\n\n            return _fn.apply(this, args);\n        });\n    }\n\n    /**\n     * A helper function that wraps an array or an object of functions with `reflect`.\n     *\n     * @name reflectAll\n     * @static\n     * @memberOf module:Utils\n     * @method\n     * @see [async.reflect]{@link module:Utils.reflect}\n     * @category Util\n     * @param {Array|Object|Iterable} tasks - The collection of\n     * [async functions]{@link AsyncFunction} to wrap in `async.reflect`.\n     * @returns {Array} Returns an array of async functions, each wrapped in\n     * `async.reflect`\n     * @example\n     *\n     * let tasks = [\n     *     function(callback) {\n     *         setTimeout(function() {\n     *             callback(null, 'one');\n     *         }, 200);\n     *     },\n     *     function(callback) {\n     *         // do some more stuff but error ...\n     *         callback(new Error('bad stuff happened'));\n     *     },\n     *     function(callback) {\n     *         setTimeout(function() {\n     *             callback(null, 'two');\n     *         }, 100);\n     *     }\n     * ];\n     *\n     * async.parallel(async.reflectAll(tasks),\n     * // optional callback\n     * function(err, results) {\n     *     // values\n     *     // results[0].value = 'one'\n     *     // results[1].error = Error('bad stuff happened')\n     *     // results[2].value = 'two'\n     * });\n     *\n     * // an example using an object instead of an array\n     * let tasks = {\n     *     one: function(callback) {\n     *         setTimeout(function() {\n     *             callback(null, 'one');\n     *         }, 200);\n     *     },\n     *     two: function(callback) {\n     *         callback('two');\n     *     },\n     *     three: function(callback) {\n     *         setTimeout(function() {\n     *             callback(null, 'three');\n     *         }, 100);\n     *     }\n     * };\n     *\n     * async.parallel(async.reflectAll(tasks),\n     * // optional callback\n     * function(err, results) {\n     *     // values\n     *     // results.one.value = 'one'\n     *     // results.two.error = 'two'\n     *     // results.three.value = 'three'\n     * });\n     */\n    function reflectAll(tasks) {\n        var results;\n        if (Array.isArray(tasks)) {\n            results = tasks.map(reflect);\n        } else {\n            results = {};\n            Object.keys(tasks).forEach(key => {\n                results[key] = reflect.call(this, tasks[key]);\n            });\n        }\n        return results;\n    }\n\n    function reject(eachfn, arr, _iteratee, callback) {\n        const iteratee = wrapAsync(_iteratee);\n        return _filter(eachfn, arr, (value, cb) => {\n            iteratee(value, (err, v) => {\n                cb(err, !v);\n            });\n        }, callback);\n    }\n\n    /**\n     * The opposite of [`filter`]{@link module:Collections.filter}. Removes values that pass an `async` truth test.\n     *\n     * @name reject\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.filter]{@link module:Collections.filter}\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {Function} iteratee - An async truth test to apply to each item in\n     * `coll`.\n     * The should complete with a boolean value as its `result`.\n     * Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called after all the\n     * `iteratee` functions have finished. Invoked with (err, results).\n     * @returns {Promise} a promise, if no callback is passed\n     * @example\n     *\n     * // dir1 is a directory that contains file1.txt, file2.txt\n     * // dir2 is a directory that contains file3.txt, file4.txt\n     * // dir3 is a directory that contains file5.txt\n     *\n     * const fileList = ['dir1/file1.txt','dir2/file3.txt','dir3/file6.txt'];\n     *\n     * // asynchronous function that checks if a file exists\n     * function fileExists(file, callback) {\n     *    fs.access(file, fs.constants.F_OK, (err) => {\n     *        callback(null, !err);\n     *    });\n     * }\n     *\n     * // Using callbacks\n     * async.reject(fileList, fileExists, function(err, results) {\n     *    // [ 'dir3/file6.txt' ]\n     *    // results now equals an array of the non-existing files\n     * });\n     *\n     * // Using Promises\n     * async.reject(fileList, fileExists)\n     * .then( results => {\n     *     console.log(results);\n     *     // [ 'dir3/file6.txt' ]\n     *     // results now equals an array of the non-existing files\n     * }).catch( err => {\n     *     console.log(err);\n     * });\n     *\n     * // Using async/await\n     * async () => {\n     *     try {\n     *         let results = await async.reject(fileList, fileExists);\n     *         console.log(results);\n     *         // [ 'dir3/file6.txt' ]\n     *         // results now equals an array of the non-existing files\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *     }\n     * }\n     *\n     */\n    function reject$1 (coll, iteratee, callback) {\n        return reject(eachOf$1, coll, iteratee, callback)\n    }\n    var reject$2 = awaitify(reject$1, 3);\n\n    /**\n     * The same as [`reject`]{@link module:Collections.reject} but runs a maximum of `limit` async operations at a\n     * time.\n     *\n     * @name rejectLimit\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.reject]{@link module:Collections.reject}\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {number} limit - The maximum number of async operations at a time.\n     * @param {Function} iteratee - An async truth test to apply to each item in\n     * `coll`.\n     * The should complete with a boolean value as its `result`.\n     * Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called after all the\n     * `iteratee` functions have finished. Invoked with (err, results).\n     * @returns {Promise} a promise, if no callback is passed\n     */\n    function rejectLimit (coll, limit, iteratee, callback) {\n        return reject(eachOfLimit(limit), coll, iteratee, callback)\n    }\n    var rejectLimit$1 = awaitify(rejectLimit, 4);\n\n    /**\n     * The same as [`reject`]{@link module:Collections.reject} but runs only a single async operation at a time.\n     *\n     * @name rejectSeries\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.reject]{@link module:Collections.reject}\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {Function} iteratee - An async truth test to apply to each item in\n     * `coll`.\n     * The should complete with a boolean value as its `result`.\n     * Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called after all the\n     * `iteratee` functions have finished. Invoked with (err, results).\n     * @returns {Promise} a promise, if no callback is passed\n     */\n    function rejectSeries (coll, iteratee, callback) {\n        return reject(eachOfSeries$1, coll, iteratee, callback)\n    }\n    var rejectSeries$1 = awaitify(rejectSeries, 3);\n\n    function constant$1(value) {\n        return function () {\n            return value;\n        }\n    }\n\n    /**\n     * Attempts to get a successful response from `task` no more than `times` times\n     * before returning an error. If the task is successful, the `callback` will be\n     * passed the result of the successful task. If all attempts fail, the callback\n     * will be passed the error and result (if any) of the final attempt.\n     *\n     * @name retry\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @category Control Flow\n     * @see [async.retryable]{@link module:ControlFlow.retryable}\n     * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an\n     * object with `times` and `interval` or a number.\n     * * `times` - The number of attempts to make before giving up.  The default\n     *   is `5`.\n     * * `interval` - The time to wait between retries, in milliseconds.  The\n     *   default is `0`. The interval may also be specified as a function of the\n     *   retry count (see example).\n     * * `errorFilter` - An optional synchronous function that is invoked on\n     *   erroneous result. If it returns `true` the retry attempts will continue;\n     *   if the function returns `false` the retry flow is aborted with the current\n     *   attempt's error and result being returned to the final callback.\n     *   Invoked with (err).\n     * * If `opts` is a number, the number specifies the number of times to retry,\n     *   with the default interval of `0`.\n     * @param {AsyncFunction} task - An async function to retry.\n     * Invoked with (callback).\n     * @param {Function} [callback] - An optional callback which is called when the\n     * task has succeeded, or after the final failed attempt. It receives the `err`\n     * and `result` arguments of the last attempt at completing the `task`. Invoked\n     * with (err, results).\n     * @returns {Promise} a promise if no callback provided\n     *\n     * @example\n     *\n     * // The `retry` function can be used as a stand-alone control flow by passing\n     * // a callback, as shown below:\n     *\n     * // try calling apiMethod 3 times\n     * async.retry(3, apiMethod, function(err, result) {\n     *     // do something with the result\n     * });\n     *\n     * // try calling apiMethod 3 times, waiting 200 ms between each retry\n     * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {\n     *     // do something with the result\n     * });\n     *\n     * // try calling apiMethod 10 times with exponential backoff\n     * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)\n     * async.retry({\n     *   times: 10,\n     *   interval: function(retryCount) {\n     *     return 50 * Math.pow(2, retryCount);\n     *   }\n     * }, apiMethod, function(err, result) {\n     *     // do something with the result\n     * });\n     *\n     * // try calling apiMethod the default 5 times no delay between each retry\n     * async.retry(apiMethod, function(err, result) {\n     *     // do something with the result\n     * });\n     *\n     * // try calling apiMethod only when error condition satisfies, all other\n     * // errors will abort the retry control flow and return to final callback\n     * async.retry({\n     *   errorFilter: function(err) {\n     *     return err.message === 'Temporary error'; // only retry on a specific error\n     *   }\n     * }, apiMethod, function(err, result) {\n     *     // do something with the result\n     * });\n     *\n     * // to retry individual methods that are not as reliable within other\n     * // control flow functions, use the `retryable` wrapper:\n     * async.auto({\n     *     users: api.getUsers.bind(api),\n     *     payments: async.retryable(3, api.getPayments.bind(api))\n     * }, function(err, results) {\n     *     // do something with the results\n     * });\n     *\n     */\n    const DEFAULT_TIMES = 5;\n    const DEFAULT_INTERVAL = 0;\n\n    function retry(opts, task, callback) {\n        var options = {\n            times: DEFAULT_TIMES,\n            intervalFunc: constant$1(DEFAULT_INTERVAL)\n        };\n\n        if (arguments.length < 3 && typeof opts === 'function') {\n            callback = task || promiseCallback();\n            task = opts;\n        } else {\n            parseTimes(options, opts);\n            callback = callback || promiseCallback();\n        }\n\n        if (typeof task !== 'function') {\n            throw new Error(\"Invalid arguments for async.retry\");\n        }\n\n        var _task = wrapAsync(task);\n\n        var attempt = 1;\n        function retryAttempt() {\n            _task((err, ...args) => {\n                if (err === false) return\n                if (err && attempt++ < options.times &&\n                    (typeof options.errorFilter != 'function' ||\n                        options.errorFilter(err))) {\n                    setTimeout(retryAttempt, options.intervalFunc(attempt - 1));\n                } else {\n                    callback(err, ...args);\n                }\n            });\n        }\n\n        retryAttempt();\n        return callback[PROMISE_SYMBOL]\n    }\n\n    function parseTimes(acc, t) {\n        if (typeof t === 'object') {\n            acc.times = +t.times || DEFAULT_TIMES;\n\n            acc.intervalFunc = typeof t.interval === 'function' ?\n                t.interval :\n                constant$1(+t.interval || DEFAULT_INTERVAL);\n\n            acc.errorFilter = t.errorFilter;\n        } else if (typeof t === 'number' || typeof t === 'string') {\n            acc.times = +t || DEFAULT_TIMES;\n        } else {\n            throw new Error(\"Invalid arguments for async.retry\");\n        }\n    }\n\n    /**\n     * A close relative of [`retry`]{@link module:ControlFlow.retry}.  This method\n     * wraps a task and makes it retryable, rather than immediately calling it\n     * with retries.\n     *\n     * @name retryable\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @see [async.retry]{@link module:ControlFlow.retry}\n     * @category Control Flow\n     * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - optional\n     * options, exactly the same as from `retry`, except for a `opts.arity` that\n     * is the arity of the `task` function, defaulting to `task.length`\n     * @param {AsyncFunction} task - the asynchronous function to wrap.\n     * This function will be passed any arguments passed to the returned wrapper.\n     * Invoked with (...args, callback).\n     * @returns {AsyncFunction} The wrapped function, which when invoked, will\n     * retry on an error, based on the parameters specified in `opts`.\n     * This function will accept the same parameters as `task`.\n     * @example\n     *\n     * async.auto({\n     *     dep1: async.retryable(3, getFromFlakyService),\n     *     process: [\"dep1\", async.retryable(3, function (results, cb) {\n     *         maybeProcessData(results.dep1, cb);\n     *     })]\n     * }, callback);\n     */\n    function retryable (opts, task) {\n        if (!task) {\n            task = opts;\n            opts = null;\n        }\n        let arity = (opts && opts.arity) || task.length;\n        if (isAsync(task)) {\n            arity += 1;\n        }\n        var _task = wrapAsync(task);\n        return initialParams((args, callback) => {\n            if (args.length < arity - 1 || callback == null) {\n                args.push(callback);\n                callback = promiseCallback();\n            }\n            function taskFn(cb) {\n                _task(...args, cb);\n            }\n\n            if (opts) retry(opts, taskFn, callback);\n            else retry(taskFn, callback);\n\n            return callback[PROMISE_SYMBOL]\n        });\n    }\n\n    /**\n     * Run the functions in the `tasks` collection in series, each one running once\n     * the previous function has completed. If any functions in the series pass an\n     * error to its callback, no more functions are run, and `callback` is\n     * immediately called with the value of the error. Otherwise, `callback`\n     * receives an array of results when `tasks` have completed.\n     *\n     * It is also possible to use an object instead of an array. Each property will\n     * be run as a function, and the results will be passed to the final `callback`\n     * as an object instead of an array. This can be a more readable way of handling\n     *  results from {@link async.series}.\n     *\n     * **Note** that while many implementations preserve the order of object\n     * properties, the [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6)\n     * explicitly states that\n     *\n     * > The mechanics and order of enumerating the properties is not specified.\n     *\n     * So if you rely on the order in which your series of functions are executed,\n     * and want this to work on all platforms, consider using an array.\n     *\n     * @name series\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @category Control Flow\n     * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection containing\n     * [async functions]{@link AsyncFunction} to run in series.\n     * Each function can complete with any number of optional `result` values.\n     * @param {Function} [callback] - An optional callback to run once all the\n     * functions have completed. This function gets a results array (or object)\n     * containing all the result arguments passed to the `task` callbacks. Invoked\n     * with (err, result).\n     * @return {Promise} a promise, if no callback is passed\n     * @example\n     *\n     * //Using Callbacks\n     * async.series([\n     *     function(callback) {\n     *         setTimeout(function() {\n     *             // do some async task\n     *             callback(null, 'one');\n     *         }, 200);\n     *     },\n     *     function(callback) {\n     *         setTimeout(function() {\n     *             // then do another async task\n     *             callback(null, 'two');\n     *         }, 100);\n     *     }\n     * ], function(err, results) {\n     *     console.log(results);\n     *     // results is equal to ['one','two']\n     * });\n     *\n     * // an example using objects instead of arrays\n     * async.series({\n     *     one: function(callback) {\n     *         setTimeout(function() {\n     *             // do some async task\n     *             callback(null, 1);\n     *         }, 200);\n     *     },\n     *     two: function(callback) {\n     *         setTimeout(function() {\n     *             // then do another async task\n     *             callback(null, 2);\n     *         }, 100);\n     *     }\n     * }, function(err, results) {\n     *     console.log(results);\n     *     // results is equal to: { one: 1, two: 2 }\n     * });\n     *\n     * //Using Promises\n     * async.series([\n     *     function(callback) {\n     *         setTimeout(function() {\n     *             callback(null, 'one');\n     *         }, 200);\n     *     },\n     *     function(callback) {\n     *         setTimeout(function() {\n     *             callback(null, 'two');\n     *         }, 100);\n     *     }\n     * ]).then(results => {\n     *     console.log(results);\n     *     // results is equal to ['one','two']\n     * }).catch(err => {\n     *     console.log(err);\n     * });\n     *\n     * // an example using an object instead of an array\n     * async.series({\n     *     one: function(callback) {\n     *         setTimeout(function() {\n     *             // do some async task\n     *             callback(null, 1);\n     *         }, 200);\n     *     },\n     *     two: function(callback) {\n     *         setTimeout(function() {\n     *             // then do another async task\n     *             callback(null, 2);\n     *         }, 100);\n     *     }\n     * }).then(results => {\n     *     console.log(results);\n     *     // results is equal to: { one: 1, two: 2 }\n     * }).catch(err => {\n     *     console.log(err);\n     * });\n     *\n     * //Using async/await\n     * async () => {\n     *     try {\n     *         let results = await async.series([\n     *             function(callback) {\n     *                 setTimeout(function() {\n     *                     // do some async task\n     *                     callback(null, 'one');\n     *                 }, 200);\n     *             },\n     *             function(callback) {\n     *                 setTimeout(function() {\n     *                     // then do another async task\n     *                     callback(null, 'two');\n     *                 }, 100);\n     *             }\n     *         ]);\n     *         console.log(results);\n     *         // results is equal to ['one','two']\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *     }\n     * }\n     *\n     * // an example using an object instead of an array\n     * async () => {\n     *     try {\n     *         let results = await async.parallel({\n     *             one: function(callback) {\n     *                 setTimeout(function() {\n     *                     // do some async task\n     *                     callback(null, 1);\n     *                 }, 200);\n     *             },\n     *            two: function(callback) {\n     *                 setTimeout(function() {\n     *                     // then do another async task\n     *                     callback(null, 2);\n     *                 }, 100);\n     *            }\n     *         });\n     *         console.log(results);\n     *         // results is equal to: { one: 1, two: 2 }\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *     }\n     * }\n     *\n     */\n    function series(tasks, callback) {\n        return parallel(eachOfSeries$1, tasks, callback);\n    }\n\n    /**\n     * Returns `true` if at least one element in the `coll` satisfies an async test.\n     * If any iteratee call returns `true`, the main `callback` is immediately\n     * called.\n     *\n     * @name some\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @alias any\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n     * in the collections in parallel.\n     * The iteratee should complete with a boolean `result` value.\n     * Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called as soon as any\n     * iteratee returns `true`, or after all the iteratee functions have finished.\n     * Result will be either `true` or `false` depending on the values of the async\n     * tests. Invoked with (err, result).\n     * @returns {Promise} a promise, if no callback provided\n     * @example\n     *\n     * // dir1 is a directory that contains file1.txt, file2.txt\n     * // dir2 is a directory that contains file3.txt, file4.txt\n     * // dir3 is a directory that contains file5.txt\n     * // dir4 does not exist\n     *\n     * // asynchronous function that checks if a file exists\n     * function fileExists(file, callback) {\n     *    fs.access(file, fs.constants.F_OK, (err) => {\n     *        callback(null, !err);\n     *    });\n     * }\n     *\n     * // Using callbacks\n     * async.some(['dir1/missing.txt','dir2/missing.txt','dir3/file5.txt'], fileExists,\n     *    function(err, result) {\n     *        console.log(result);\n     *        // true\n     *        // result is true since some file in the list exists\n     *    }\n     *);\n     *\n     * async.some(['dir1/missing.txt','dir2/missing.txt','dir4/missing.txt'], fileExists,\n     *    function(err, result) {\n     *        console.log(result);\n     *        // false\n     *        // result is false since none of the files exists\n     *    }\n     *);\n     *\n     * // Using Promises\n     * async.some(['dir1/missing.txt','dir2/missing.txt','dir3/file5.txt'], fileExists)\n     * .then( result => {\n     *     console.log(result);\n     *     // true\n     *     // result is true since some file in the list exists\n     * }).catch( err => {\n     *     console.log(err);\n     * });\n     *\n     * async.some(['dir1/missing.txt','dir2/missing.txt','dir4/missing.txt'], fileExists)\n     * .then( result => {\n     *     console.log(result);\n     *     // false\n     *     // result is false since none of the files exists\n     * }).catch( err => {\n     *     console.log(err);\n     * });\n     *\n     * // Using async/await\n     * async () => {\n     *     try {\n     *         let result = await async.some(['dir1/missing.txt','dir2/missing.txt','dir3/file5.txt'], fileExists);\n     *         console.log(result);\n     *         // true\n     *         // result is true since some file in the list exists\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *     }\n     * }\n     *\n     * async () => {\n     *     try {\n     *         let result = await async.some(['dir1/missing.txt','dir2/missing.txt','dir4/missing.txt'], fileExists);\n     *         console.log(result);\n     *         // false\n     *         // result is false since none of the files exists\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *     }\n     * }\n     *\n     */\n    function some(coll, iteratee, callback) {\n        return _createTester(Boolean, res => res)(eachOf$1, coll, iteratee, callback)\n    }\n    var some$1 = awaitify(some, 3);\n\n    /**\n     * The same as [`some`]{@link module:Collections.some} but runs a maximum of `limit` async operations at a time.\n     *\n     * @name someLimit\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.some]{@link module:Collections.some}\n     * @alias anyLimit\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {number} limit - The maximum number of async operations at a time.\n     * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n     * in the collections in parallel.\n     * The iteratee should complete with a boolean `result` value.\n     * Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called as soon as any\n     * iteratee returns `true`, or after all the iteratee functions have finished.\n     * Result will be either `true` or `false` depending on the values of the async\n     * tests. Invoked with (err, result).\n     * @returns {Promise} a promise, if no callback provided\n     */\n    function someLimit(coll, limit, iteratee, callback) {\n        return _createTester(Boolean, res => res)(eachOfLimit(limit), coll, iteratee, callback)\n    }\n    var someLimit$1 = awaitify(someLimit, 4);\n\n    /**\n     * The same as [`some`]{@link module:Collections.some} but runs only a single async operation at a time.\n     *\n     * @name someSeries\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @see [async.some]{@link module:Collections.some}\n     * @alias anySeries\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n     * in the collections in series.\n     * The iteratee should complete with a boolean `result` value.\n     * Invoked with (item, callback).\n     * @param {Function} [callback] - A callback which is called as soon as any\n     * iteratee returns `true`, or after all the iteratee functions have finished.\n     * Result will be either `true` or `false` depending on the values of the async\n     * tests. Invoked with (err, result).\n     * @returns {Promise} a promise, if no callback provided\n     */\n    function someSeries(coll, iteratee, callback) {\n        return _createTester(Boolean, res => res)(eachOfSeries$1, coll, iteratee, callback)\n    }\n    var someSeries$1 = awaitify(someSeries, 3);\n\n    /**\n     * Sorts a list by the results of running each `coll` value through an async\n     * `iteratee`.\n     *\n     * @name sortBy\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {AsyncFunction} iteratee - An async function to apply to each item in\n     * `coll`.\n     * The iteratee should complete with a value to use as the sort criteria as\n     * its `result`.\n     * Invoked with (item, callback).\n     * @param {Function} callback - A callback which is called after all the\n     * `iteratee` functions have finished, or an error occurs. Results is the items\n     * from the original `coll` sorted by the values returned by the `iteratee`\n     * calls. Invoked with (err, results).\n     * @returns {Promise} a promise, if no callback passed\n     * @example\n     *\n     * // bigfile.txt is a file that is 251100 bytes in size\n     * // mediumfile.txt is a file that is 11000 bytes in size\n     * // smallfile.txt is a file that is 121 bytes in size\n     *\n     * // asynchronous function that returns the file size in bytes\n     * function getFileSizeInBytes(file, callback) {\n     *     fs.stat(file, function(err, stat) {\n     *         if (err) {\n     *             return callback(err);\n     *         }\n     *         callback(null, stat.size);\n     *     });\n     * }\n     *\n     * // Using callbacks\n     * async.sortBy(['mediumfile.txt','smallfile.txt','bigfile.txt'], getFileSizeInBytes,\n     *     function(err, results) {\n     *         if (err) {\n     *             console.log(err);\n     *         } else {\n     *             console.log(results);\n     *             // results is now the original array of files sorted by\n     *             // file size (ascending by default), e.g.\n     *             // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']\n     *         }\n     *     }\n     * );\n     *\n     * // By modifying the callback parameter the\n     * // sorting order can be influenced:\n     *\n     * // ascending order\n     * async.sortBy(['mediumfile.txt','smallfile.txt','bigfile.txt'], function(file, callback) {\n     *     getFileSizeInBytes(file, function(getFileSizeErr, fileSize) {\n     *         if (getFileSizeErr) return callback(getFileSizeErr);\n     *         callback(null, fileSize);\n     *     });\n     * }, function(err, results) {\n     *         if (err) {\n     *             console.log(err);\n     *         } else {\n     *             console.log(results);\n     *             // results is now the original array of files sorted by\n     *             // file size (ascending by default), e.g.\n     *             // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']\n     *         }\n     *     }\n     * );\n     *\n     * // descending order\n     * async.sortBy(['bigfile.txt','mediumfile.txt','smallfile.txt'], function(file, callback) {\n     *     getFileSizeInBytes(file, function(getFileSizeErr, fileSize) {\n     *         if (getFileSizeErr) {\n     *             return callback(getFileSizeErr);\n     *         }\n     *         callback(null, fileSize * -1);\n     *     });\n     * }, function(err, results) {\n     *         if (err) {\n     *             console.log(err);\n     *         } else {\n     *             console.log(results);\n     *             // results is now the original array of files sorted by\n     *             // file size (ascending by default), e.g.\n     *             // [ 'bigfile.txt', 'mediumfile.txt', 'smallfile.txt']\n     *         }\n     *     }\n     * );\n     *\n     * // Error handling\n     * async.sortBy(['mediumfile.txt','smallfile.txt','missingfile.txt'], getFileSizeInBytes,\n     *     function(err, results) {\n     *         if (err) {\n     *             console.log(err);\n     *             // [ Error: ENOENT: no such file or directory ]\n     *         } else {\n     *             console.log(results);\n     *         }\n     *     }\n     * );\n     *\n     * // Using Promises\n     * async.sortBy(['mediumfile.txt','smallfile.txt','bigfile.txt'], getFileSizeInBytes)\n     * .then( results => {\n     *     console.log(results);\n     *     // results is now the original array of files sorted by\n     *     // file size (ascending by default), e.g.\n     *     // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']\n     * }).catch( err => {\n     *     console.log(err);\n     * });\n     *\n     * // Error handling\n     * async.sortBy(['mediumfile.txt','smallfile.txt','missingfile.txt'], getFileSizeInBytes)\n     * .then( results => {\n     *     console.log(results);\n     * }).catch( err => {\n     *     console.log(err);\n     *     // [ Error: ENOENT: no such file or directory ]\n     * });\n     *\n     * // Using async/await\n     * (async () => {\n     *     try {\n     *         let results = await async.sortBy(['bigfile.txt','mediumfile.txt','smallfile.txt'], getFileSizeInBytes);\n     *         console.log(results);\n     *         // results is now the original array of files sorted by\n     *         // file size (ascending by default), e.g.\n     *         // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *     }\n     * })();\n     *\n     * // Error handling\n     * async () => {\n     *     try {\n     *         let results = await async.sortBy(['missingfile.txt','mediumfile.txt','smallfile.txt'], getFileSizeInBytes);\n     *         console.log(results);\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *         // [ Error: ENOENT: no such file or directory ]\n     *     }\n     * }\n     *\n     */\n    function sortBy (coll, iteratee, callback) {\n        var _iteratee = wrapAsync(iteratee);\n        return map$1(coll, (x, iterCb) => {\n            _iteratee(x, (err, criteria) => {\n                if (err) return iterCb(err);\n                iterCb(err, {value: x, criteria});\n            });\n        }, (err, results) => {\n            if (err) return callback(err);\n            callback(null, results.sort(comparator).map(v => v.value));\n        });\n\n        function comparator(left, right) {\n            var a = left.criteria, b = right.criteria;\n            return a < b ? -1 : a > b ? 1 : 0;\n        }\n    }\n    var sortBy$1 = awaitify(sortBy, 3);\n\n    /**\n     * Sets a time limit on an asynchronous function. If the function does not call\n     * its callback within the specified milliseconds, it will be called with a\n     * timeout error. The code property for the error object will be `'ETIMEDOUT'`.\n     *\n     * @name timeout\n     * @static\n     * @memberOf module:Utils\n     * @method\n     * @category Util\n     * @param {AsyncFunction} asyncFn - The async function to limit in time.\n     * @param {number} milliseconds - The specified time limit.\n     * @param {*} [info] - Any variable you want attached (`string`, `object`, etc)\n     * to timeout Error for more information..\n     * @returns {AsyncFunction} Returns a wrapped function that can be used with any\n     * of the control flow functions.\n     * Invoke this function with the same parameters as you would `asyncFunc`.\n     * @example\n     *\n     * function myFunction(foo, callback) {\n     *     doAsyncTask(foo, function(err, data) {\n     *         // handle errors\n     *         if (err) return callback(err);\n     *\n     *         // do some stuff ...\n     *\n     *         // return processed data\n     *         return callback(null, data);\n     *     });\n     * }\n     *\n     * var wrapped = async.timeout(myFunction, 1000);\n     *\n     * // call `wrapped` as you would `myFunction`\n     * wrapped({ bar: 'bar' }, function(err, data) {\n     *     // if `myFunction` takes < 1000 ms to execute, `err`\n     *     // and `data` will have their expected values\n     *\n     *     // else `err` will be an Error with the code 'ETIMEDOUT'\n     * });\n     */\n    function timeout(asyncFn, milliseconds, info) {\n        var fn = wrapAsync(asyncFn);\n\n        return initialParams((args, callback) => {\n            var timedOut = false;\n            var timer;\n\n            function timeoutCallback() {\n                var name = asyncFn.name || 'anonymous';\n                var error  = new Error('Callback function \"' + name + '\" timed out.');\n                error.code = 'ETIMEDOUT';\n                if (info) {\n                    error.info = info;\n                }\n                timedOut = true;\n                callback(error);\n            }\n\n            args.push((...cbArgs) => {\n                if (!timedOut) {\n                    callback(...cbArgs);\n                    clearTimeout(timer);\n                }\n            });\n\n            // setup timer and call original function\n            timer = setTimeout(timeoutCallback, milliseconds);\n            fn(...args);\n        });\n    }\n\n    function range(size) {\n        var result = Array(size);\n        while (size--) {\n            result[size] = size;\n        }\n        return result;\n    }\n\n    /**\n     * The same as [times]{@link module:ControlFlow.times} but runs a maximum of `limit` async operations at a\n     * time.\n     *\n     * @name timesLimit\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @see [async.times]{@link module:ControlFlow.times}\n     * @category Control Flow\n     * @param {number} count - The number of times to run the function.\n     * @param {number} limit - The maximum number of async operations at a time.\n     * @param {AsyncFunction} iteratee - The async function to call `n` times.\n     * Invoked with the iteration index and a callback: (n, next).\n     * @param {Function} callback - see [async.map]{@link module:Collections.map}.\n     * @returns {Promise} a promise, if no callback is provided\n     */\n    function timesLimit(count, limit, iteratee, callback) {\n        var _iteratee = wrapAsync(iteratee);\n        return mapLimit$1(range(count), limit, _iteratee, callback);\n    }\n\n    /**\n     * Calls the `iteratee` function `n` times, and accumulates results in the same\n     * manner you would use with [map]{@link module:Collections.map}.\n     *\n     * @name times\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @see [async.map]{@link module:Collections.map}\n     * @category Control Flow\n     * @param {number} n - The number of times to run the function.\n     * @param {AsyncFunction} iteratee - The async function to call `n` times.\n     * Invoked with the iteration index and a callback: (n, next).\n     * @param {Function} callback - see {@link module:Collections.map}.\n     * @returns {Promise} a promise, if no callback is provided\n     * @example\n     *\n     * // Pretend this is some complicated async factory\n     * var createUser = function(id, callback) {\n     *     callback(null, {\n     *         id: 'user' + id\n     *     });\n     * };\n     *\n     * // generate 5 users\n     * async.times(5, function(n, next) {\n     *     createUser(n, function(err, user) {\n     *         next(err, user);\n     *     });\n     * }, function(err, users) {\n     *     // we should now have 5 users\n     * });\n     */\n    function times (n, iteratee, callback) {\n        return timesLimit(n, Infinity, iteratee, callback)\n    }\n\n    /**\n     * The same as [times]{@link module:ControlFlow.times} but runs only a single async operation at a time.\n     *\n     * @name timesSeries\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @see [async.times]{@link module:ControlFlow.times}\n     * @category Control Flow\n     * @param {number} n - The number of times to run the function.\n     * @param {AsyncFunction} iteratee - The async function to call `n` times.\n     * Invoked with the iteration index and a callback: (n, next).\n     * @param {Function} callback - see {@link module:Collections.map}.\n     * @returns {Promise} a promise, if no callback is provided\n     */\n    function timesSeries (n, iteratee, callback) {\n        return timesLimit(n, 1, iteratee, callback)\n    }\n\n    /**\n     * A relative of `reduce`.  Takes an Object or Array, and iterates over each\n     * element in parallel, each step potentially mutating an `accumulator` value.\n     * The type of the accumulator defaults to the type of collection passed in.\n     *\n     * @name transform\n     * @static\n     * @memberOf module:Collections\n     * @method\n     * @category Collection\n     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n     * @param {*} [accumulator] - The initial state of the transform.  If omitted,\n     * it will default to an empty Object or Array, depending on the type of `coll`\n     * @param {AsyncFunction} iteratee - A function applied to each item in the\n     * collection that potentially modifies the accumulator.\n     * Invoked with (accumulator, item, key, callback).\n     * @param {Function} [callback] - A callback which is called after all the\n     * `iteratee` functions have finished. Result is the transformed accumulator.\n     * Invoked with (err, result).\n     * @returns {Promise} a promise, if no callback provided\n     * @example\n     *\n     * // file1.txt is a file that is 1000 bytes in size\n     * // file2.txt is a file that is 2000 bytes in size\n     * // file3.txt is a file that is 3000 bytes in size\n     *\n     * // helper function that returns human-readable size format from bytes\n     * function formatBytes(bytes, decimals = 2) {\n     *   // implementation not included for brevity\n     *   return humanReadbleFilesize;\n     * }\n     *\n     * const fileList = ['file1.txt','file2.txt','file3.txt'];\n     *\n     * // asynchronous function that returns the file size, transformed to human-readable format\n     * // e.g. 1024 bytes = 1KB, 1234 bytes = 1.21 KB, 1048576 bytes = 1MB, etc.\n     * function transformFileSize(acc, value, key, callback) {\n     *     fs.stat(value, function(err, stat) {\n     *         if (err) {\n     *             return callback(err);\n     *         }\n     *         acc[key] = formatBytes(stat.size);\n     *         callback(null);\n     *     });\n     * }\n     *\n     * // Using callbacks\n     * async.transform(fileList, transformFileSize, function(err, result) {\n     *     if(err) {\n     *         console.log(err);\n     *     } else {\n     *         console.log(result);\n     *         // [ '1000 Bytes', '1.95 KB', '2.93 KB' ]\n     *     }\n     * });\n     *\n     * // Using Promises\n     * async.transform(fileList, transformFileSize)\n     * .then(result => {\n     *     console.log(result);\n     *     // [ '1000 Bytes', '1.95 KB', '2.93 KB' ]\n     * }).catch(err => {\n     *     console.log(err);\n     * });\n     *\n     * // Using async/await\n     * (async () => {\n     *     try {\n     *         let result = await async.transform(fileList, transformFileSize);\n     *         console.log(result);\n     *         // [ '1000 Bytes', '1.95 KB', '2.93 KB' ]\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *     }\n     * })();\n     *\n     * @example\n     *\n     * // file1.txt is a file that is 1000 bytes in size\n     * // file2.txt is a file that is 2000 bytes in size\n     * // file3.txt is a file that is 3000 bytes in size\n     *\n     * // helper function that returns human-readable size format from bytes\n     * function formatBytes(bytes, decimals = 2) {\n     *   // implementation not included for brevity\n     *   return humanReadbleFilesize;\n     * }\n     *\n     * const fileMap = { f1: 'file1.txt', f2: 'file2.txt', f3: 'file3.txt' };\n     *\n     * // asynchronous function that returns the file size, transformed to human-readable format\n     * // e.g. 1024 bytes = 1KB, 1234 bytes = 1.21 KB, 1048576 bytes = 1MB, etc.\n     * function transformFileSize(acc, value, key, callback) {\n     *     fs.stat(value, function(err, stat) {\n     *         if (err) {\n     *             return callback(err);\n     *         }\n     *         acc[key] = formatBytes(stat.size);\n     *         callback(null);\n     *     });\n     * }\n     *\n     * // Using callbacks\n     * async.transform(fileMap, transformFileSize, function(err, result) {\n     *     if(err) {\n     *         console.log(err);\n     *     } else {\n     *         console.log(result);\n     *         // { f1: '1000 Bytes', f2: '1.95 KB', f3: '2.93 KB' }\n     *     }\n     * });\n     *\n     * // Using Promises\n     * async.transform(fileMap, transformFileSize)\n     * .then(result => {\n     *     console.log(result);\n     *     // { f1: '1000 Bytes', f2: '1.95 KB', f3: '2.93 KB' }\n     * }).catch(err => {\n     *     console.log(err);\n     * });\n     *\n     * // Using async/await\n     * async () => {\n     *     try {\n     *         let result = await async.transform(fileMap, transformFileSize);\n     *         console.log(result);\n     *         // { f1: '1000 Bytes', f2: '1.95 KB', f3: '2.93 KB' }\n     *     }\n     *     catch (err) {\n     *         console.log(err);\n     *     }\n     * }\n     *\n     */\n    function transform (coll, accumulator, iteratee, callback) {\n        if (arguments.length <= 3 && typeof accumulator === 'function') {\n            callback = iteratee;\n            iteratee = accumulator;\n            accumulator = Array.isArray(coll) ? [] : {};\n        }\n        callback = once(callback || promiseCallback());\n        var _iteratee = wrapAsync(iteratee);\n\n        eachOf$1(coll, (v, k, cb) => {\n            _iteratee(accumulator, v, k, cb);\n        }, err => callback(err, accumulator));\n        return callback[PROMISE_SYMBOL]\n    }\n\n    /**\n     * It runs each task in series but stops whenever any of the functions were\n     * successful. If one of the tasks were successful, the `callback` will be\n     * passed the result of the successful task. If all tasks fail, the callback\n     * will be passed the error and result (if any) of the final attempt.\n     *\n     * @name tryEach\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @category Control Flow\n     * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection containing functions to\n     * run, each function is passed a `callback(err, result)` it must call on\n     * completion with an error `err` (which can be `null`) and an optional `result`\n     * value.\n     * @param {Function} [callback] - An optional callback which is called when one\n     * of the tasks has succeeded, or all have failed. It receives the `err` and\n     * `result` arguments of the last attempt at completing the `task`. Invoked with\n     * (err, results).\n     * @returns {Promise} a promise, if no callback is passed\n     * @example\n     * async.tryEach([\n     *     function getDataFromFirstWebsite(callback) {\n     *         // Try getting the data from the first website\n     *         callback(err, data);\n     *     },\n     *     function getDataFromSecondWebsite(callback) {\n     *         // First website failed,\n     *         // Try getting the data from the backup website\n     *         callback(err, data);\n     *     }\n     * ],\n     * // optional callback\n     * function(err, results) {\n     *     Now do something with the data.\n     * });\n     *\n     */\n    function tryEach(tasks, callback) {\n        var error = null;\n        var result;\n        return eachSeries$1(tasks, (task, taskCb) => {\n            wrapAsync(task)((err, ...args) => {\n                if (err === false) return taskCb(err);\n\n                if (args.length < 2) {\n                    [result] = args;\n                } else {\n                    result = args;\n                }\n                error = err;\n                taskCb(err ? null : {});\n            });\n        }, () => callback(error, result));\n    }\n\n    var tryEach$1 = awaitify(tryEach);\n\n    /**\n     * Undoes a [memoize]{@link module:Utils.memoize}d function, reverting it to the original,\n     * unmemoized form. Handy for testing.\n     *\n     * @name unmemoize\n     * @static\n     * @memberOf module:Utils\n     * @method\n     * @see [async.memoize]{@link module:Utils.memoize}\n     * @category Util\n     * @param {AsyncFunction} fn - the memoized function\n     * @returns {AsyncFunction} a function that calls the original unmemoized function\n     */\n    function unmemoize(fn) {\n        return (...args) => {\n            return (fn.unmemoized || fn)(...args);\n        };\n    }\n\n    /**\n     * Repeatedly call `iteratee`, while `test` returns `true`. Calls `callback` when\n     * stopped, or an error occurs.\n     *\n     * @name whilst\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @category Control Flow\n     * @param {AsyncFunction} test - asynchronous truth test to perform before each\n     * execution of `iteratee`. Invoked with ().\n     * @param {AsyncFunction} iteratee - An async function which is called each time\n     * `test` passes. Invoked with (callback).\n     * @param {Function} [callback] - A callback which is called after the test\n     * function has failed and repeated execution of `iteratee` has stopped. `callback`\n     * will be passed an error and any arguments passed to the final `iteratee`'s\n     * callback. Invoked with (err, [results]);\n     * @returns {Promise} a promise, if no callback is passed\n     * @example\n     *\n     * var count = 0;\n     * async.whilst(\n     *     function test(cb) { cb(null, count < 5); },\n     *     function iter(callback) {\n     *         count++;\n     *         setTimeout(function() {\n     *             callback(null, count);\n     *         }, 1000);\n     *     },\n     *     function (err, n) {\n     *         // 5 seconds have passed, n = 5\n     *     }\n     * );\n     */\n    function whilst(test, iteratee, callback) {\n        callback = onlyOnce(callback);\n        var _fn = wrapAsync(iteratee);\n        var _test = wrapAsync(test);\n        var results = [];\n\n        function next(err, ...rest) {\n            if (err) return callback(err);\n            results = rest;\n            if (err === false) return;\n            _test(check);\n        }\n\n        function check(err, truth) {\n            if (err) return callback(err);\n            if (err === false) return;\n            if (!truth) return callback(null, ...results);\n            _fn(next);\n        }\n\n        return _test(check);\n    }\n    var whilst$1 = awaitify(whilst, 3);\n\n    /**\n     * Repeatedly call `iteratee` until `test` returns `true`. Calls `callback` when\n     * stopped, or an error occurs. `callback` will be passed an error and any\n     * arguments passed to the final `iteratee`'s callback.\n     *\n     * The inverse of [whilst]{@link module:ControlFlow.whilst}.\n     *\n     * @name until\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @see [async.whilst]{@link module:ControlFlow.whilst}\n     * @category Control Flow\n     * @param {AsyncFunction} test - asynchronous truth test to perform before each\n     * execution of `iteratee`. Invoked with (callback).\n     * @param {AsyncFunction} iteratee - An async function which is called each time\n     * `test` fails. Invoked with (callback).\n     * @param {Function} [callback] - A callback which is called after the test\n     * function has passed and repeated execution of `iteratee` has stopped. `callback`\n     * will be passed an error and any arguments passed to the final `iteratee`'s\n     * callback. Invoked with (err, [results]);\n     * @returns {Promise} a promise, if a callback is not passed\n     *\n     * @example\n     * const results = []\n     * let finished = false\n     * async.until(function test(cb) {\n     *     cb(null, finished)\n     * }, function iter(next) {\n     *     fetchPage(url, (err, body) => {\n     *         if (err) return next(err)\n     *         results = results.concat(body.objects)\n     *         finished = !!body.next\n     *         next(err)\n     *     })\n     * }, function done (err) {\n     *     // all pages have been fetched\n     * })\n     */\n    function until(test, iteratee, callback) {\n        const _test = wrapAsync(test);\n        return whilst$1((cb) => _test((err, truth) => cb (err, !truth)), iteratee, callback);\n    }\n\n    /**\n     * Runs the `tasks` array of functions in series, each passing their results to\n     * the next in the array. However, if any of the `tasks` pass an error to their\n     * own callback, the next function is not executed, and the main `callback` is\n     * immediately called with the error.\n     *\n     * @name waterfall\n     * @static\n     * @memberOf module:ControlFlow\n     * @method\n     * @category Control Flow\n     * @param {Array} tasks - An array of [async functions]{@link AsyncFunction}\n     * to run.\n     * Each function should complete with any number of `result` values.\n     * The `result` values will be passed as arguments, in order, to the next task.\n     * @param {Function} [callback] - An optional callback to run once all the\n     * functions have completed. This will be passed the results of the last task's\n     * callback. Invoked with (err, [results]).\n     * @returns {Promise} a promise, if a callback is omitted\n     * @example\n     *\n     * async.waterfall([\n     *     function(callback) {\n     *         callback(null, 'one', 'two');\n     *     },\n     *     function(arg1, arg2, callback) {\n     *         // arg1 now equals 'one' and arg2 now equals 'two'\n     *         callback(null, 'three');\n     *     },\n     *     function(arg1, callback) {\n     *         // arg1 now equals 'three'\n     *         callback(null, 'done');\n     *     }\n     * ], function (err, result) {\n     *     // result now equals 'done'\n     * });\n     *\n     * // Or, with named functions:\n     * async.waterfall([\n     *     myFirstFunction,\n     *     mySecondFunction,\n     *     myLastFunction,\n     * ], function (err, result) {\n     *     // result now equals 'done'\n     * });\n     * function myFirstFunction(callback) {\n     *     callback(null, 'one', 'two');\n     * }\n     * function mySecondFunction(arg1, arg2, callback) {\n     *     // arg1 now equals 'one' and arg2 now equals 'two'\n     *     callback(null, 'three');\n     * }\n     * function myLastFunction(arg1, callback) {\n     *     // arg1 now equals 'three'\n     *     callback(null, 'done');\n     * }\n     */\n    function waterfall (tasks, callback) {\n        callback = once(callback);\n        if (!Array.isArray(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));\n        if (!tasks.length) return callback();\n        var taskIndex = 0;\n\n        function nextTask(args) {\n            var task = wrapAsync(tasks[taskIndex++]);\n            task(...args, onlyOnce(next));\n        }\n\n        function next(err, ...args) {\n            if (err === false) return\n            if (err || taskIndex === tasks.length) {\n                return callback(err, ...args);\n            }\n            nextTask(args);\n        }\n\n        nextTask([]);\n    }\n\n    var waterfall$1 = awaitify(waterfall);\n\n    /**\n     * An \"async function\" in the context of Async is an asynchronous function with\n     * a variable number of parameters, with the final parameter being a callback.\n     * (`function (arg1, arg2, ..., callback) {}`)\n     * The final callback is of the form `callback(err, results...)`, which must be\n     * called once the function is completed.  The callback should be called with a\n     * Error as its first argument to signal that an error occurred.\n     * Otherwise, if no error occurred, it should be called with `null` as the first\n     * argument, and any additional `result` arguments that may apply, to signal\n     * successful completion.\n     * The callback must be called exactly once, ideally on a later tick of the\n     * JavaScript event loop.\n     *\n     * This type of function is also referred to as a \"Node-style async function\",\n     * or a \"continuation passing-style function\" (CPS). Most of the methods of this\n     * library are themselves CPS/Node-style async functions, or functions that\n     * return CPS/Node-style async functions.\n     *\n     * Wherever we accept a Node-style async function, we also directly accept an\n     * [ES2017 `async` function]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function}.\n     * In this case, the `async` function will not be passed a final callback\n     * argument, and any thrown error will be used as the `err` argument of the\n     * implicit callback, and the return value will be used as the `result` value.\n     * (i.e. a `rejected` of the returned Promise becomes the `err` callback\n     * argument, and a `resolved` value becomes the `result`.)\n     *\n     * Note, due to JavaScript limitations, we can only detect native `async`\n     * functions and not transpilied implementations.\n     * Your environment must have `async`/`await` support for this to work.\n     * (e.g. Node > v7.6, or a recent version of a modern browser).\n     * If you are using `async` functions through a transpiler (e.g. Babel), you\n     * must still wrap the function with [asyncify]{@link module:Utils.asyncify},\n     * because the `async function` will be compiled to an ordinary function that\n     * returns a promise.\n     *\n     * @typedef {Function} AsyncFunction\n     * @static\n     */\n\n    var index = {\n        apply,\n        applyEach: applyEach$1,\n        applyEachSeries,\n        asyncify,\n        auto,\n        autoInject,\n        cargo,\n        cargoQueue: cargo$1,\n        compose,\n        concat: concat$1,\n        concatLimit: concatLimit$1,\n        concatSeries: concatSeries$1,\n        constant,\n        detect: detect$1,\n        detectLimit: detectLimit$1,\n        detectSeries: detectSeries$1,\n        dir,\n        doUntil,\n        doWhilst: doWhilst$1,\n        each,\n        eachLimit: eachLimit$2,\n        eachOf: eachOf$1,\n        eachOfLimit: eachOfLimit$2,\n        eachOfSeries: eachOfSeries$1,\n        eachSeries: eachSeries$1,\n        ensureAsync,\n        every: every$1,\n        everyLimit: everyLimit$1,\n        everySeries: everySeries$1,\n        filter: filter$1,\n        filterLimit: filterLimit$1,\n        filterSeries: filterSeries$1,\n        forever: forever$1,\n        groupBy,\n        groupByLimit: groupByLimit$1,\n        groupBySeries,\n        log,\n        map: map$1,\n        mapLimit: mapLimit$1,\n        mapSeries: mapSeries$1,\n        mapValues,\n        mapValuesLimit: mapValuesLimit$1,\n        mapValuesSeries,\n        memoize,\n        nextTick,\n        parallel: parallel$1,\n        parallelLimit,\n        priorityQueue,\n        queue: queue$1,\n        race: race$1,\n        reduce: reduce$1,\n        reduceRight,\n        reflect,\n        reflectAll,\n        reject: reject$2,\n        rejectLimit: rejectLimit$1,\n        rejectSeries: rejectSeries$1,\n        retry,\n        retryable,\n        seq,\n        series,\n        setImmediate: setImmediate$1,\n        some: some$1,\n        someLimit: someLimit$1,\n        someSeries: someSeries$1,\n        sortBy: sortBy$1,\n        timeout,\n        times,\n        timesLimit,\n        timesSeries,\n        transform,\n        tryEach: tryEach$1,\n        unmemoize,\n        until,\n        waterfall: waterfall$1,\n        whilst: whilst$1,\n\n        // aliases\n        all: every$1,\n        allLimit: everyLimit$1,\n        allSeries: everySeries$1,\n        any: some$1,\n        anyLimit: someLimit$1,\n        anySeries: someSeries$1,\n        find: detect$1,\n        findLimit: detectLimit$1,\n        findSeries: detectSeries$1,\n        flatMap: concat$1,\n        flatMapLimit: concatLimit$1,\n        flatMapSeries: concatSeries$1,\n        forEach: each,\n        forEachSeries: eachSeries$1,\n        forEachLimit: eachLimit$2,\n        forEachOf: eachOf$1,\n        forEachOfSeries: eachOfSeries$1,\n        forEachOfLimit: eachOfLimit$2,\n        inject: reduce$1,\n        foldl: reduce$1,\n        foldr: reduceRight,\n        select: filter$1,\n        selectLimit: filterLimit$1,\n        selectSeries: filterSeries$1,\n        wrapSync: asyncify,\n        during: whilst$1,\n        doDuring: doWhilst$1\n    };\n\n    exports.default = index;\n    exports.apply = apply;\n    exports.applyEach = applyEach$1;\n    exports.applyEachSeries = applyEachSeries;\n    exports.asyncify = asyncify;\n    exports.auto = auto;\n    exports.autoInject = autoInject;\n    exports.cargo = cargo;\n    exports.cargoQueue = cargo$1;\n    exports.compose = compose;\n    exports.concat = concat$1;\n    exports.concatLimit = concatLimit$1;\n    exports.concatSeries = concatSeries$1;\n    exports.constant = constant;\n    exports.detect = detect$1;\n    exports.detectLimit = detectLimit$1;\n    exports.detectSeries = detectSeries$1;\n    exports.dir = dir;\n    exports.doUntil = doUntil;\n    exports.doWhilst = doWhilst$1;\n    exports.each = each;\n    exports.eachLimit = eachLimit$2;\n    exports.eachOf = eachOf$1;\n    exports.eachOfLimit = eachOfLimit$2;\n    exports.eachOfSeries = eachOfSeries$1;\n    exports.eachSeries = eachSeries$1;\n    exports.ensureAsync = ensureAsync;\n    exports.every = every$1;\n    exports.everyLimit = everyLimit$1;\n    exports.everySeries = everySeries$1;\n    exports.filter = filter$1;\n    exports.filterLimit = filterLimit$1;\n    exports.filterSeries = filterSeries$1;\n    exports.forever = forever$1;\n    exports.groupBy = groupBy;\n    exports.groupByLimit = groupByLimit$1;\n    exports.groupBySeries = groupBySeries;\n    exports.log = log;\n    exports.map = map$1;\n    exports.mapLimit = mapLimit$1;\n    exports.mapSeries = mapSeries$1;\n    exports.mapValues = mapValues;\n    exports.mapValuesLimit = mapValuesLimit$1;\n    exports.mapValuesSeries = mapValuesSeries;\n    exports.memoize = memoize;\n    exports.nextTick = nextTick;\n    exports.parallel = parallel$1;\n    exports.parallelLimit = parallelLimit;\n    exports.priorityQueue = priorityQueue;\n    exports.queue = queue$1;\n    exports.race = race$1;\n    exports.reduce = reduce$1;\n    exports.reduceRight = reduceRight;\n    exports.reflect = reflect;\n    exports.reflectAll = reflectAll;\n    exports.reject = reject$2;\n    exports.rejectLimit = rejectLimit$1;\n    exports.rejectSeries = rejectSeries$1;\n    exports.retry = retry;\n    exports.retryable = retryable;\n    exports.seq = seq;\n    exports.series = series;\n    exports.setImmediate = setImmediate$1;\n    exports.some = some$1;\n    exports.someLimit = someLimit$1;\n    exports.someSeries = someSeries$1;\n    exports.sortBy = sortBy$1;\n    exports.timeout = timeout;\n    exports.times = times;\n    exports.timesLimit = timesLimit;\n    exports.timesSeries = timesSeries;\n    exports.transform = transform;\n    exports.tryEach = tryEach$1;\n    exports.unmemoize = unmemoize;\n    exports.until = until;\n    exports.waterfall = waterfall$1;\n    exports.whilst = whilst$1;\n    exports.all = every$1;\n    exports.allLimit = everyLimit$1;\n    exports.allSeries = everySeries$1;\n    exports.any = some$1;\n    exports.anyLimit = someLimit$1;\n    exports.anySeries = someSeries$1;\n    exports.find = detect$1;\n    exports.findLimit = detectLimit$1;\n    exports.findSeries = detectSeries$1;\n    exports.flatMap = concat$1;\n    exports.flatMapLimit = concatLimit$1;\n    exports.flatMapSeries = concatSeries$1;\n    exports.forEach = each;\n    exports.forEachSeries = eachSeries$1;\n    exports.forEachLimit = eachLimit$2;\n    exports.forEachOf = eachOf$1;\n    exports.forEachOfSeries = eachOfSeries$1;\n    exports.forEachOfLimit = eachOfLimit$2;\n    exports.inject = reduce$1;\n    exports.foldl = reduce$1;\n    exports.foldr = reduceRight;\n    exports.select = filter$1;\n    exports.selectLimit = filterLimit$1;\n    exports.selectSeries = filterSeries$1;\n    exports.wrapSync = asyncify;\n    exports.during = whilst$1;\n    exports.doDuring = doWhilst$1;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"]}