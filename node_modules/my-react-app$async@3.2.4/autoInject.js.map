{"version":3,"sources":["autoInject.js"],"names":["Object","defineProperty","exports","value","default","autoInject","_auto","require","_auto2","_interopRequireDefault","_wrapAsync","_wrapAsync2","obj","__esModule","FN_ARGS","ARROW_FN_ARGS","FN_ARG_SPLIT","FN_ARG","stripComments","string","stripped","index","endBlockComment","indexOf","length","endIndex","parseParams","func","src","toString","match","Error","args","replace","split","map","arg","trim","tasks","callback","newTasks","keys","forEach","key","taskFn","params","fnIsAsync","isAsync","hasNoDeps","Array","isArray","pop","concat","newTask","results","taskCb","newArgs","name","push","module"],"mappings":"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","file":"autoInject.js","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = autoInject;\n\nvar _auto = require('./auto.js');\n\nvar _auto2 = _interopRequireDefault(_auto);\n\nvar _wrapAsync = require('./internal/wrapAsync.js');\n\nvar _wrapAsync2 = _interopRequireDefault(_wrapAsync);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar FN_ARGS = /^(?:async\\s+)?(?:function)?\\s*\\w*\\s*\\(\\s*([^)]+)\\s*\\)(?:\\s*{)/;\nvar ARROW_FN_ARGS = /^(?:async\\s+)?\\(?\\s*([^)=]+)\\s*\\)?(?:\\s*=>)/;\nvar FN_ARG_SPLIT = /,/;\nvar FN_ARG = /(=.+)?(\\s*)$/;\n\nfunction stripComments(string) {\n    let stripped = '';\n    let index = 0;\n    let endBlockComment = string.indexOf('*/');\n    while (index < string.length) {\n        if (string[index] === '/' && string[index + 1] === '/') {\n            // inline comment\n            let endIndex = string.indexOf('\\n', index);\n            index = endIndex === -1 ? string.length : endIndex;\n        } else if (endBlockComment !== -1 && string[index] === '/' && string[index + 1] === '*') {\n            // block comment\n            let endIndex = string.indexOf('*/', index);\n            if (endIndex !== -1) {\n                index = endIndex + 2;\n                endBlockComment = string.indexOf('*/', index);\n            } else {\n                stripped += string[index];\n                index++;\n            }\n        } else {\n            stripped += string[index];\n            index++;\n        }\n    }\n    return stripped;\n}\n\nfunction parseParams(func) {\n    const src = stripComments(func.toString());\n    let match = src.match(FN_ARGS);\n    if (!match) {\n        match = src.match(ARROW_FN_ARGS);\n    }\n    if (!match) throw new Error('could not parse args in autoInject\\nSource:\\n' + src);\n    let [, args] = match;\n    return args.replace(/\\s/g, '').split(FN_ARG_SPLIT).map(arg => arg.replace(FN_ARG, '').trim());\n}\n\n/**\n * A dependency-injected version of the [async.auto]{@link module:ControlFlow.auto} function. Dependent\n * tasks are specified as parameters to the function, after the usual callback\n * parameter, with the parameter names matching the names of the tasks it\n * depends on. This can provide even more readable task graphs which can be\n * easier to maintain.\n *\n * If a final callback is specified, the task results are similarly injected,\n * specified as named parameters after the initial error parameter.\n *\n * The autoInject function is purely syntactic sugar and its semantics are\n * otherwise equivalent to [async.auto]{@link module:ControlFlow.auto}.\n *\n * @name autoInject\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.auto]{@link module:ControlFlow.auto}\n * @category Control Flow\n * @param {Object} tasks - An object, each of whose properties is an {@link AsyncFunction} of\n * the form 'func([dependencies...], callback). The object's key of a property\n * serves as the name of the task defined by that property, i.e. can be used\n * when specifying requirements for other tasks.\n * * The `callback` parameter is a `callback(err, result)` which must be called\n *   when finished, passing an `error` (which can be `null`) and the result of\n *   the function's execution. The remaining parameters name other tasks on\n *   which the task is dependent, and the results from those tasks are the\n *   arguments of those parameters.\n * @param {Function} [callback] - An optional callback which is called when all\n * the tasks have been completed. It receives the `err` argument if any `tasks`\n * pass an error to their callback, and a `results` object with any completed\n * task results, similar to `auto`.\n * @returns {Promise} a promise, if no callback is passed\n * @example\n *\n * //  The example from `auto` can be rewritten as follows:\n * async.autoInject({\n *     get_data: function(callback) {\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: function(get_data, make_folder, callback) {\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     },\n *     email_link: function(write_file, callback) {\n *         // once the file is written let's email a link to it...\n *         // write_file contains the filename returned by write_file.\n *         callback(null, {'file':write_file, 'email':'user@example.com'});\n *     }\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('email_link = ', results.email_link);\n * });\n *\n * // If you are using a JS minifier that mangles parameter names, `autoInject`\n * // will not work with plain functions, since the parameter names will be\n * // collapsed to a single letter identifier.  To work around this, you can\n * // explicitly specify the names of the parameters your task function needs\n * // in an array, similar to Angular.js dependency injection.\n *\n * // This still has an advantage over plain `auto`, since the results a task\n * // depends on are still spread into arguments.\n * async.autoInject({\n *     //...\n *     write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(write_file, callback) {\n *         callback(null, {'file':write_file, 'email':'user@example.com'});\n *     }]\n *     //...\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('email_link = ', results.email_link);\n * });\n */\nfunction autoInject(tasks, callback) {\n    var newTasks = {};\n\n    Object.keys(tasks).forEach(key => {\n        var taskFn = tasks[key];\n        var params;\n        var fnIsAsync = (0, _wrapAsync.isAsync)(taskFn);\n        var hasNoDeps = !fnIsAsync && taskFn.length === 1 || fnIsAsync && taskFn.length === 0;\n\n        if (Array.isArray(taskFn)) {\n            params = [...taskFn];\n            taskFn = params.pop();\n\n            newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);\n        } else if (hasNoDeps) {\n            // no dependencies, use the function as-is\n            newTasks[key] = taskFn;\n        } else {\n            params = parseParams(taskFn);\n            if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {\n                throw new Error(\"autoInject task functions require explicit parameters.\");\n            }\n\n            // remove callback param\n            if (!fnIsAsync) params.pop();\n\n            newTasks[key] = params.concat(newTask);\n        }\n\n        function newTask(results, taskCb) {\n            var newArgs = params.map(name => results[name]);\n            newArgs.push(taskCb);\n            (0, _wrapAsync2.default)(taskFn)(...newArgs);\n        }\n    });\n\n    return (0, _auto2.default)(newTasks, callback);\n}\nmodule.exports = exports['default'];"]}