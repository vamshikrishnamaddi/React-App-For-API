{"version":3,"sources":["retry.js"],"names":["Object","defineProperty","exports","value","default","retry","_wrapAsync","require","_wrapAsync2","_interopRequireDefault","_promiseCallback","obj","__esModule","constant","DEFAULT_TIMES","DEFAULT_INTERVAL","opts","task","callback","options","times","intervalFunc","arguments","length","promiseCallback","parseTimes","Error","_task","attempt","retryAttempt","err","args","errorFilter","setTimeout","PROMISE_SYMBOL","acc","t","interval","module"],"mappings":"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","file":"retry.js","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = retry;\n\nvar _wrapAsync = require('./internal/wrapAsync.js');\n\nvar _wrapAsync2 = _interopRequireDefault(_wrapAsync);\n\nvar _promiseCallback = require('./internal/promiseCallback.js');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction constant(value) {\n    return function () {\n        return value;\n    };\n}\n\n/**\n * Attempts to get a successful response from `task` no more than `times` times\n * before returning an error. If the task is successful, the `callback` will be\n * passed the result of the successful task. If all attempts fail, the callback\n * will be passed the error and result (if any) of the final attempt.\n *\n * @name retry\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @see [async.retryable]{@link module:ControlFlow.retryable}\n * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an\n * object with `times` and `interval` or a number.\n * * `times` - The number of attempts to make before giving up.  The default\n *   is `5`.\n * * `interval` - The time to wait between retries, in milliseconds.  The\n *   default is `0`. The interval may also be specified as a function of the\n *   retry count (see example).\n * * `errorFilter` - An optional synchronous function that is invoked on\n *   erroneous result. If it returns `true` the retry attempts will continue;\n *   if the function returns `false` the retry flow is aborted with the current\n *   attempt's error and result being returned to the final callback.\n *   Invoked with (err).\n * * If `opts` is a number, the number specifies the number of times to retry,\n *   with the default interval of `0`.\n * @param {AsyncFunction} task - An async function to retry.\n * Invoked with (callback).\n * @param {Function} [callback] - An optional callback which is called when the\n * task has succeeded, or after the final failed attempt. It receives the `err`\n * and `result` arguments of the last attempt at completing the `task`. Invoked\n * with (err, results).\n * @returns {Promise} a promise if no callback provided\n *\n * @example\n *\n * // The `retry` function can be used as a stand-alone control flow by passing\n * // a callback, as shown below:\n *\n * // try calling apiMethod 3 times\n * async.retry(3, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 3 times, waiting 200 ms between each retry\n * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 10 times with exponential backoff\n * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)\n * async.retry({\n *   times: 10,\n *   interval: function(retryCount) {\n *     return 50 * Math.pow(2, retryCount);\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod the default 5 times no delay between each retry\n * async.retry(apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod only when error condition satisfies, all other\n * // errors will abort the retry control flow and return to final callback\n * async.retry({\n *   errorFilter: function(err) {\n *     return err.message === 'Temporary error'; // only retry on a specific error\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // to retry individual methods that are not as reliable within other\n * // control flow functions, use the `retryable` wrapper:\n * async.auto({\n *     users: api.getUsers.bind(api),\n *     payments: async.retryable(3, api.getPayments.bind(api))\n * }, function(err, results) {\n *     // do something with the results\n * });\n *\n */\nconst DEFAULT_TIMES = 5;\nconst DEFAULT_INTERVAL = 0;\n\nfunction retry(opts, task, callback) {\n    var options = {\n        times: DEFAULT_TIMES,\n        intervalFunc: constant(DEFAULT_INTERVAL)\n    };\n\n    if (arguments.length < 3 && typeof opts === 'function') {\n        callback = task || (0, _promiseCallback.promiseCallback)();\n        task = opts;\n    } else {\n        parseTimes(options, opts);\n        callback = callback || (0, _promiseCallback.promiseCallback)();\n    }\n\n    if (typeof task !== 'function') {\n        throw new Error(\"Invalid arguments for async.retry\");\n    }\n\n    var _task = (0, _wrapAsync2.default)(task);\n\n    var attempt = 1;\n    function retryAttempt() {\n        _task((err, ...args) => {\n            if (err === false) return;\n            if (err && attempt++ < options.times && (typeof options.errorFilter != 'function' || options.errorFilter(err))) {\n                setTimeout(retryAttempt, options.intervalFunc(attempt - 1));\n            } else {\n                callback(err, ...args);\n            }\n        });\n    }\n\n    retryAttempt();\n    return callback[_promiseCallback.PROMISE_SYMBOL];\n}\n\nfunction parseTimes(acc, t) {\n    if (typeof t === 'object') {\n        acc.times = +t.times || DEFAULT_TIMES;\n\n        acc.intervalFunc = typeof t.interval === 'function' ? t.interval : constant(+t.interval || DEFAULT_INTERVAL);\n\n        acc.errorFilter = t.errorFilter;\n    } else if (typeof t === 'number' || typeof t === 'string') {\n        acc.times = +t || DEFAULT_TIMES;\n    } else {\n        throw new Error(\"Invalid arguments for async.retry\");\n    }\n}\nmodule.exports = exports['default'];"]}