{"version":3,"sources":["cargo.js"],"names":["Object","defineProperty","exports","value","default","cargo","_queue","require","_queue2","_interopRequireDefault","obj","__esModule","worker","payload","module"],"mappings":"AAAA;;;;;;AAEAA,WAAOC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,aAAO;AADoC,KAA7C;AAGAD,YAAQE,OAAR,GAAkBC,KAAlB;;AAEA,QAAIC,SAASC,QAAQ,kBAAR,CAAb;;AAEA,QAAIC,UAAUC,uBAAuBH,MAAvB,CAAd;;AAEA,aAASG,sBAAT,CAAgCC,GAAhC,EAAqC;AAAE,aAAOA,OAAOA,IAAIC,UAAX,GAAwBD,GAAxB,GAA8B,EAAEN,SAASM,GAAX,EAArC;AAAwD;;AAE/F;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8CA,aAASL,KAAT,CAAeO,MAAf,EAAuBC,OAAvB,EAAgC;AAC9B,aAAO,CAAC,GAAGL,QAAQJ,OAAZ,EAAqBQ,MAArB,EAA6B,CAA7B,EAAgCC,OAAhC,CAAP;AACD;AACDC,WAAOZ,OAAP,GAAiBA,QAAQ,SAAR,CAAjB","file":"cargo.js","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = cargo;\n\nvar _queue = require('./internal/queue.js');\n\nvar _queue2 = _interopRequireDefault(_queue);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Creates a `cargo` object with the specified payload. Tasks added to the\n * cargo will be processed altogether (up to the `payload` limit). If the\n * `worker` is in progress, the task is queued until it becomes available. Once\n * the `worker` has completed some tasks, each callback of those tasks is\n * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)\n * for how `cargo` and `queue` work.\n *\n * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers\n * at a time, cargo passes an array of tasks to a single worker, repeating\n * when the worker is finished.\n *\n * @name cargo\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.queue]{@link module:ControlFlow.queue}\n * @category Control Flow\n * @param {AsyncFunction} worker - An asynchronous function for processing an array\n * of queued tasks. Invoked with `(tasks, callback)`.\n * @param {number} [payload=Infinity] - An optional `integer` for determining\n * how many tasks should be processed per round; if omitted, the default is\n * unlimited.\n * @returns {module:ControlFlow.QueueObject} A cargo object to manage the tasks. Callbacks can\n * attached as certain properties to listen for specific events during the\n * lifecycle of the cargo and inner queue.\n * @example\n *\n * // create a cargo object with payload 2\n * var cargo = async.cargo(function(tasks, callback) {\n *     for (var i=0; i<tasks.length; i++) {\n *         console.log('hello ' + tasks[i].name);\n *     }\n *     callback();\n * }, 2);\n *\n * // add some items\n * cargo.push({name: 'foo'}, function(err) {\n *     console.log('finished processing foo');\n * });\n * cargo.push({name: 'bar'}, function(err) {\n *     console.log('finished processing bar');\n * });\n * await cargo.push({name: 'baz'});\n * console.log('finished processing baz');\n */\nfunction cargo(worker, payload) {\n  return (0, _queue2.default)(worker, 1, payload);\n}\nmodule.exports = exports['default'];"]}