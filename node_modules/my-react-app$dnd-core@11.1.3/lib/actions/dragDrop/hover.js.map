{"version":3,"sources":["hover.js"],"names":["invariant","matchesType","HOVER","createHover","manager","hover","targetIdsArg","clientOffset","verifyTargetIdsIsArray","targetIds","slice","monitor","getMonitor","registry","getRegistry","checkInvariants","draggedItemType","getItemType","removeNonMatchingTargetIds","hoverAllTargets","type","payload","Array","isArray","isDragging","didDrop","i","length","targetId","lastIndexOf","target","getTarget","targetType","getTargetType","splice","forEach"],"mappings":";;;;AAAA,iBAASA,SAAT,QAA0B,sBAA1B;AACA,iBAASC,WAAT,QAA4B,yBAA5B;AACA,iBAASC,KAAT,QAAsB,SAAtB;AACA,eAAO,SAASC,WAAT,CAAqBC,OAArB,EAA8B;AACjC,mBAAO,SAASC,KAAT,CAAeC,YAAf,EAA6B,EAAEC,YAAF,KAAmB,EAAhD,EAAoD;AACvDC,uCAAuBF,YAAvB;AACA,sBAAMG,YAAYH,aAAaI,KAAb,CAAmB,CAAnB,CAAlB;AACA,sBAAMC,UAAUP,QAAQQ,UAAR,EAAhB;AACA,sBAAMC,WAAWT,QAAQU,WAAR,EAAjB;AACAC,gCAAgBN,SAAhB,EAA2BE,OAA3B,EAAoCE,QAApC;AACA,sBAAMG,kBAAkBL,QAAQM,WAAR,EAAxB;AACAC,2CAA2BT,SAA3B,EAAsCI,QAAtC,EAAgDG,eAAhD;AACAG,gCAAgBV,SAAhB,EAA2BE,OAA3B,EAAoCE,QAApC;AACA,uBAAO;AACHO,0BAAMlB,KADH;AAEHmB,6BAAS;AACLZ,iCADK;AAELF,sCAAcA,gBAAgB;AAFzB;AAFN,iBAAP;AAOH,aAhBD;AAiBH;AACD,iBAASC,sBAAT,CAAgCF,YAAhC,EAA8C;AAC1CN,sBAAUsB,MAAMC,OAAN,CAAcjB,YAAd,CAAV,EAAuC,oCAAvC;AACH;AACD,iBAASS,eAAT,CAAyBN,SAAzB,EAAoCE,OAApC,EAA6CE,QAA7C,EAAuD;AACnDb,sBAAUW,QAAQa,UAAR,EAAV,EAAgC,uCAAhC;AACAxB,sBAAU,CAACW,QAAQc,OAAR,EAAX,EAA8B,+BAA9B;AACA,iBAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIjB,UAAUkB,MAA9B,EAAsCD,GAAtC,EAA2C;AACvC,sBAAME,WAAWnB,UAAUiB,CAAV,CAAjB;AACA1B,0BAAUS,UAAUoB,WAAV,CAAsBD,QAAtB,MAAoCF,CAA9C,EAAiD,sDAAjD;AACA,sBAAMI,SAASjB,SAASkB,SAAT,CAAmBH,QAAnB,CAAf;AACA5B,0BAAU8B,MAAV,EAAkB,sCAAlB;AACH;AACJ;AACD,iBAASZ,0BAAT,CAAoCT,SAApC,EAA+CI,QAA/C,EAAyDG,eAAzD,EAA0E;AACtE;AACA;AACA;AACA,iBAAK,IAAIU,IAAIjB,UAAUkB,MAAV,GAAmB,CAAhC,EAAmCD,KAAK,CAAxC,EAA2CA,GAA3C,EAAgD;AAC5C,sBAAME,WAAWnB,UAAUiB,CAAV,CAAjB;AACA,sBAAMM,aAAanB,SAASoB,aAAT,CAAuBL,QAAvB,CAAnB;AACA,oBAAI,CAAC3B,YAAY+B,UAAZ,EAAwBhB,eAAxB,CAAL,EAA+C;AAC3CP,8BAAUyB,MAAV,CAAiBR,CAAjB,EAAoB,CAApB;AACH;AACJ;AACJ;AACD,iBAASP,eAAT,CAAyBV,SAAzB,EAAoCE,OAApC,EAA6CE,QAA7C,EAAuD;AACnD;AACAJ,sBAAU0B,OAAV,CAAkB,UAAUP,QAAV,EAAoB;AAClC,sBAAME,SAASjB,SAASkB,SAAT,CAAmBH,QAAnB,CAAf;AACAE,uBAAOzB,KAAP,CAAaM,OAAb,EAAsBiB,QAAtB;AACH,aAHD;AAIH","file":"hover.js","sourcesContent":["import { invariant } from '@react-dnd/invariant';\nimport { matchesType } from '../../utils/matchesType';\nimport { HOVER } from './types';\nexport function createHover(manager) {\n    return function hover(targetIdsArg, { clientOffset } = {}) {\n        verifyTargetIdsIsArray(targetIdsArg);\n        const targetIds = targetIdsArg.slice(0);\n        const monitor = manager.getMonitor();\n        const registry = manager.getRegistry();\n        checkInvariants(targetIds, monitor, registry);\n        const draggedItemType = monitor.getItemType();\n        removeNonMatchingTargetIds(targetIds, registry, draggedItemType);\n        hoverAllTargets(targetIds, monitor, registry);\n        return {\n            type: HOVER,\n            payload: {\n                targetIds,\n                clientOffset: clientOffset || null,\n            },\n        };\n    };\n}\nfunction verifyTargetIdsIsArray(targetIdsArg) {\n    invariant(Array.isArray(targetIdsArg), 'Expected targetIds to be an array.');\n}\nfunction checkInvariants(targetIds, monitor, registry) {\n    invariant(monitor.isDragging(), 'Cannot call hover while not dragging.');\n    invariant(!monitor.didDrop(), 'Cannot call hover after drop.');\n    for (let i = 0; i < targetIds.length; i++) {\n        const targetId = targetIds[i];\n        invariant(targetIds.lastIndexOf(targetId) === i, 'Expected targetIds to be unique in the passed array.');\n        const target = registry.getTarget(targetId);\n        invariant(target, 'Expected targetIds to be registered.');\n    }\n}\nfunction removeNonMatchingTargetIds(targetIds, registry, draggedItemType) {\n    // Remove those targetIds that don't match the targetType.  This\n    // fixes shallow isOver which would only be non-shallow because of\n    // non-matching targets.\n    for (let i = targetIds.length - 1; i >= 0; i--) {\n        const targetId = targetIds[i];\n        const targetType = registry.getTargetType(targetId);\n        if (!matchesType(targetType, draggedItemType)) {\n            targetIds.splice(i, 1);\n        }\n    }\n}\nfunction hoverAllTargets(targetIds, monitor, registry) {\n    // Finally call hover on all matching targets.\n    targetIds.forEach(function (targetId) {\n        const target = registry.getTarget(targetId);\n        target.hover(monitor, targetId);\n    });\n}\n"]}