{"version":3,"sources":["DragDropMonitorImpl.js"],"names":["invariant","matchesType","getSourceClientOffset","getDifferenceFromInitialOffset","areDirty","DragDropMonitorImpl","constructor","store","registry","subscribeToStateChange","listener","options","handlerIds","undefined","Array","isArray","prevStateId","getState","stateId","handleChange","state","currentStateId","canSkipListener","dirtyHandlerIds","subscribe","subscribeToOffsetChange","previousState","dragOffset","nextState","canDragSource","sourceId","source","getSource","isDragging","canDrag","canDropOnTarget","targetId","target","getTarget","didDrop","targetType","getTargetType","draggedItemType","getItemType","canDrop","Boolean","isDraggingSource","isSourcePublic","sourceType","getSourceType","isOverTarget","shallow","targetIds","getTargetIds","length","index","indexOf","dragOperation","itemType","getItem","item","getSourceId","getDropResult","dropResult","getInitialClientOffset","initialClientOffset","getInitialSourceClientOffset","initialSourceClientOffset","getClientOffset","clientOffset"],"mappings":"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","file":"DragDropMonitorImpl.js","sourcesContent":["import { invariant } from '@react-dnd/invariant';\nimport { matchesType } from './utils/matchesType';\nimport { getSourceClientOffset, getDifferenceFromInitialOffset, } from './utils/coords';\nimport { areDirty } from './utils/dirtiness';\nexport class DragDropMonitorImpl {\n    constructor(store, registry) {\n        this.store = store;\n        this.registry = registry;\n    }\n    subscribeToStateChange(listener, options = { handlerIds: undefined }) {\n        const { handlerIds } = options;\n        invariant(typeof listener === 'function', 'listener must be a function.');\n        invariant(typeof handlerIds === 'undefined' || Array.isArray(handlerIds), 'handlerIds, when specified, must be an array of strings.');\n        let prevStateId = this.store.getState().stateId;\n        const handleChange = () => {\n            const state = this.store.getState();\n            const currentStateId = state.stateId;\n            try {\n                const canSkipListener = currentStateId === prevStateId ||\n                    (currentStateId === prevStateId + 1 &&\n                        !areDirty(state.dirtyHandlerIds, handlerIds));\n                if (!canSkipListener) {\n                    listener();\n                }\n            }\n            finally {\n                prevStateId = currentStateId;\n            }\n        };\n        return this.store.subscribe(handleChange);\n    }\n    subscribeToOffsetChange(listener) {\n        invariant(typeof listener === 'function', 'listener must be a function.');\n        let previousState = this.store.getState().dragOffset;\n        const handleChange = () => {\n            const nextState = this.store.getState().dragOffset;\n            if (nextState === previousState) {\n                return;\n            }\n            previousState = nextState;\n            listener();\n        };\n        return this.store.subscribe(handleChange);\n    }\n    canDragSource(sourceId) {\n        if (!sourceId) {\n            return false;\n        }\n        const source = this.registry.getSource(sourceId);\n        invariant(source, 'Expected to find a valid source.');\n        if (this.isDragging()) {\n            return false;\n        }\n        return source.canDrag(this, sourceId);\n    }\n    canDropOnTarget(targetId) {\n        // undefined on initial render\n        if (!targetId) {\n            return false;\n        }\n        const target = this.registry.getTarget(targetId);\n        invariant(target, 'Expected to find a valid target.');\n        if (!this.isDragging() || this.didDrop()) {\n            return false;\n        }\n        const targetType = this.registry.getTargetType(targetId);\n        const draggedItemType = this.getItemType();\n        return (matchesType(targetType, draggedItemType) && target.canDrop(this, targetId));\n    }\n    isDragging() {\n        return Boolean(this.getItemType());\n    }\n    isDraggingSource(sourceId) {\n        // undefined on initial render\n        if (!sourceId) {\n            return false;\n        }\n        const source = this.registry.getSource(sourceId, true);\n        invariant(source, 'Expected to find a valid source.');\n        if (!this.isDragging() || !this.isSourcePublic()) {\n            return false;\n        }\n        const sourceType = this.registry.getSourceType(sourceId);\n        const draggedItemType = this.getItemType();\n        if (sourceType !== draggedItemType) {\n            return false;\n        }\n        return source.isDragging(this, sourceId);\n    }\n    isOverTarget(targetId, options = { shallow: false }) {\n        // undefined on initial render\n        if (!targetId) {\n            return false;\n        }\n        const { shallow } = options;\n        if (!this.isDragging()) {\n            return false;\n        }\n        const targetType = this.registry.getTargetType(targetId);\n        const draggedItemType = this.getItemType();\n        if (draggedItemType && !matchesType(targetType, draggedItemType)) {\n            return false;\n        }\n        const targetIds = this.getTargetIds();\n        if (!targetIds.length) {\n            return false;\n        }\n        const index = targetIds.indexOf(targetId);\n        if (shallow) {\n            return index === targetIds.length - 1;\n        }\n        else {\n            return index > -1;\n        }\n    }\n    getItemType() {\n        return this.store.getState().dragOperation.itemType;\n    }\n    getItem() {\n        return this.store.getState().dragOperation.item;\n    }\n    getSourceId() {\n        return this.store.getState().dragOperation.sourceId;\n    }\n    getTargetIds() {\n        return this.store.getState().dragOperation.targetIds;\n    }\n    getDropResult() {\n        return this.store.getState().dragOperation.dropResult;\n    }\n    didDrop() {\n        return this.store.getState().dragOperation.didDrop;\n    }\n    isSourcePublic() {\n        return Boolean(this.store.getState().dragOperation.isSourcePublic);\n    }\n    getInitialClientOffset() {\n        return this.store.getState().dragOffset.initialClientOffset;\n    }\n    getInitialSourceClientOffset() {\n        return this.store.getState().dragOffset.initialSourceClientOffset;\n    }\n    getClientOffset() {\n        return this.store.getState().dragOffset.clientOffset;\n    }\n    getSourceClientOffset() {\n        return getSourceClientOffset(this.store.getState().dragOffset);\n    }\n    getDifferenceFromInitialOffset() {\n        return getDifferenceFromInitialOffset(this.store.getState().dragOffset);\n    }\n}\n"]}