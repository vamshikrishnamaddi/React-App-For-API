Liferay.Loader.define("@my-react-app$tanstack/virtual-core@3.0.0-beta.18/build/umd/index.production", ['module', 'exports', 'require'], function (module, exports, require) {
  var define = undefined;
  var global = window;
  {
    function _objectWithoutProperties(obj, keys) {
      var target = {};

      for (var i in obj) {
        if (keys.indexOf(i) >= 0) continue;
        if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
        target[i] = obj[i];
      }

      return target;
    }

    var _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    /**
     * virtual-core
     *
     * Copyright (c) TanStack
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     */
    !function (e, t) {
      "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = "undefined" != typeof globalThis ? globalThis : e || self).VirtualCore = {});
    }(this, function (e) {
      "use strict";
      function t(e, t, s) {
        let n,
            o = [];return () => {
          let i;s.key && null != s.debug && s.debug() && (i = Date.now());const l = e();if (!(l.length !== o.length || l.some((e, t) => o[t] !== e))) return n;let r;if (o = l, s.key && null != s.debug && s.debug() && (r = Date.now()), n = t(...l), null == s || null == s.onChange || s.onChange(n), s.key && null != s.debug && s.debug()) {
            const e = Math.round(100 * (Date.now() - i)) / 100,
                  t = Math.round(100 * (Date.now() - r)) / 100,
                  o = (e, t) => {
              for (e = String(e); e.length < t;) e = " " + e;return e;
            };console.info("%câ± " + o(t, 5) + " /" + o(e, 5) + " ms", "\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(" + Math.max(0, Math.min(120 - 120 * (t / 16), 120)) + "deg 100% 31%);", null == s ? void 0 : s.key);
          }return n;
        };
      }const s = e => e,
            n = e => {
        const t = Math.max(e.startIndex - e.overscan, 0),
              s = Math.min(e.endIndex + e.overscan, e.count - 1),
              n = [];for (let e = t; e <= s; e++) n.push(e);return n;
      },
            o = { element: ["scrollLeft", "scrollTop"], window: ["scrollX", "scrollY"] },
            i = e => (t, s) => {
        if (!t.scrollElement) return;const n = o[e][0],
              i = o[e][1];let l = t.scrollElement[n],
            r = t.scrollElement[i];const h = () => {
          s(t.scrollElement[t.options.horizontal ? n : i]);
        };h();const a = e => {
          const s = e.currentTarget,
                o = s[n],
                a = s[i];(t.options.horizontal ? l - o : r - a) && h(), l = o, r = a;
        };return t.scrollElement.addEventListener("scroll", a, { capture: !1, passive: !0 }), () => {
          t.scrollElement.removeEventListener("scroll", a);
        };
      },
            l = i("element"),
            r = i("window"),
            h = (e, t) => e.getBoundingClientRect()[t.options.horizontal ? "width" : "height"];e.Virtualizer = class {
        constructor(e) {
          var o = this;this.unsubs = [], this.scrollElement = null, this.measurementsCache = [], this.itemMeasurementsCache = {}, this.pendingMeasuredCacheIndexes = [], this.measureElementCache = {}, this.range = { startIndex: 0, endIndex: 0 }, this.setOptions = e => {
            Object.entries(e).forEach(t => {
              let [s, n] = t;void 0 === n && delete e[s];
            }), this.options = _extends({ debug: !1, initialOffset: 0, overscan: 1, paddingStart: 0, paddingEnd: 0, scrollPaddingStart: 0, scrollPaddingEnd: 0, horizontal: !1, getItemKey: s, rangeExtractor: n, enableSmoothScroll: !0, onChange: () => {}, measureElement: h, initialRect: { width: 0, height: 0 } }, e);
          }, this.notify = () => {
            var e, t;null == (e = (t = this.options).onChange) || e.call(t, this);
          }, this.cleanup = () => {
            this.unsubs.filter(Boolean).forEach(e => e()), this.unsubs = [], this.scrollElement = null;
          }, this._didMount = () => () => {
            this.cleanup();
          }, this._willUpdate = () => {
            const e = this.options.getScrollElement();this.scrollElement !== e && (this.cleanup(), this.scrollElement = e, this._scrollToOffset(this.scrollOffset, !1), this.unsubs.push(this.options.observeElementRect(this, e => {
              this.scrollRect = e, this.calculateRange();
            })), this.unsubs.push(this.options.observeElementOffset(this, e => {
              this.scrollOffset = e, this.calculateRange();
            })));
          }, this.getSize = () => this.scrollRect[this.options.horizontal ? "width" : "height"], this.getMeasurements = t(() => [this.options.count, this.options.paddingStart, this.options.getItemKey, this.itemMeasurementsCache], (e, t, s, n) => {
            const o = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;this.pendingMeasuredCacheIndexes = [];const i = this.measurementsCache.slice(0, o);for (let l = o; l < e; l++) {
              const e = s(l),
                    o = n[e],
                    r = i[l - 1] ? i[l - 1].end : t,
                    h = "number" == typeof o ? o : this.options.estimateSize(l);i[l] = { index: l, start: r, size: h, end: r + h, key: e };
            }return this.measurementsCache = i, i;
          }, { key: !1, debug: () => this.options.debug }), this.calculateRange = t(() => [this.getMeasurements(), this.getSize(), this.scrollOffset], (e, t, s) => {
            const n = function (e) {
              let { measurements: t, outerSize: s, scrollOffset: n } = e;const o = t.length - 1,
                    i = ((e, t, s, n) => {
                for (; e <= t;) {
                  const o = (e + t) / 2 | 0,
                        i = s(o);if (i < n) e = o + 1;else {
                    if (!(i > n)) return o;t = o - 1;
                  }
                }return e > 0 ? e - 1 : 0;
              })(0, o, e => t[e].start, n);let l = i;for (; l < o && t[l].end < n + s;) l++;return { startIndex: i, endIndex: l };
            }({ measurements: e, outerSize: t, scrollOffset: s });return n.startIndex === this.range.startIndex && n.endIndex === this.range.endIndex || (this.range = n, this.notify()), this.range;
          }, { key: !1, debug: () => this.options.debug }), this.getIndexes = t(() => [this.options.rangeExtractor, this.range, this.options.overscan, this.options.count], (e, t, s, n) => e(_extends({}, t, { overscan: s, count: n })), { key: !1, debug: () => this.options.debug }), this.getVirtualItems = t(() => [this.getIndexes(), this.getMeasurements(), this.options.measureElement], (e, t, s) => {
            const n = e => t => {
              var n;const o = this.measurementsCache[e];if (!t) return;const i = s(t, this),
                    l = null != (n = this.itemMeasurementsCache[o.key]) ? n : o.size;i !== l && (o.start < this.scrollOffset && (this.destinationOffset || this._scrollToOffset(this.scrollOffset + (i - l), !1)), this.pendingMeasuredCacheIndexes.push(e), this.itemMeasurementsCache = _extends({}, this.itemMeasurementsCache, { [o.key]: i }), this.notify());
            },
                  o = [],
                  i = {};for (let s = 0, r = e.length; s < r; s++) {
              var l;const r = e[s],
                    h = _extends({}, t[r], { measureElement: i[r] = null != (l = this.measureElementCache[r]) ? l : n(r) });o.push(h);
            }return this.measureElementCache = i, o;
          }, { key: !1, debug: () => this.options.debug }), this.scrollToOffset = function (e, t) {
            let { align: s = "start", smoothScroll: n = o.options.enableSmoothScroll } = void 0 === t ? {} : t;const i = o.scrollOffset,
                  l = o.getSize();"auto" === s && (s = e <= i ? "start" : e >= i + l ? "end" : "start"), "start" === s ? o._scrollToOffset(e, n) : "end" === s ? o._scrollToOffset(e - l, n) : "center" === s && o._scrollToOffset(e - l / 2, n);
          }, this.scrollToIndex = function (e, t) {
            let _ref = void 0 === t ? {} : t,
                { align: s = "auto", smoothScroll: n = o.options.enableSmoothScroll } = _ref,
                i = _objectWithoutProperties(_ref, ["align", "smoothScroll"]);const l = o.getMeasurements(),
                  r = o.scrollOffset,
                  h = o.getSize(),
                  { count: a } = o.options,
                  c = l[Math.max(0, Math.min(e, a - 1))];if (!c) return;if ("auto" === s) if (c.end >= r + h - o.options.scrollPaddingEnd) s = "end";else {
              if (!(c.start <= r + o.options.scrollPaddingStart)) return;s = "start";
            }const u = "end" === s ? c.end + o.options.scrollPaddingEnd : c.start - o.options.scrollPaddingStart;o.scrollToOffset(u, _extends({ align: s, smoothScroll: n }, i));
          }, this.getTotalSize = () => {
            var e;return ((null == (e = this.getMeasurements()[this.options.count - 1]) ? void 0 : e.end) || this.options.paddingStart) + this.options.paddingEnd;
          }, this._scrollToOffset = (e, t) => {
            let s;clearTimeout(this.scrollCheckFrame), this.destinationOffset = e, this.options.scrollToFn(e, t, this);const n = () => {
              let e = this.scrollOffset;this.scrollCheckFrame = s = setTimeout(() => {
                this.scrollCheckFrame === s && (this.scrollOffset !== e ? (e = this.scrollOffset, n()) : this.destinationOffset = void 0);
              }, 100);
            };n();
          }, this.measure = () => {
            this.itemMeasurementsCache = {}, this.notify();
          }, this.setOptions(e), this.scrollRect = this.options.initialRect, this.scrollOffset = this.options.initialOffset, this.calculateRange();
        }
      }, e.defaultKeyExtractor = s, e.defaultRangeExtractor = n, e.elementScroll = (e, t, s) => {
        var n;null == (n = s.scrollElement) || null == n.scrollTo || n.scrollTo({ [s.options.horizontal ? "left" : "top"]: e, behavior: t ? "smooth" : void 0 });
      }, e.measureElement = h, e.memo = t, e.observeElementOffset = l, e.observeElementRect = (e, t) => {
        const s = new ResizeObserver(e => {
          var s, n;t({ width: null == (s = e[0]) ? void 0 : s.contentRect.width, height: null == (n = e[0]) ? void 0 : n.contentRect.height });
        });if (e.scrollElement) return t(e.scrollElement.getBoundingClientRect()), s.observe(e.scrollElement), () => {
          s.unobserve(e.scrollElement);
        };
      }, e.observeWindowOffset = r, e.observeWindowRect = (e, t) => {
        const s = ((e, t) => {
          let s = { height: -1, width: -1 };return n => {
            (e.options.horizontal ? n.width !== s.width : n.height !== s.height) && t(n), s = n;
          };
        })(e, t),
              n = () => s({ width: e.scrollElement.innerWidth, height: e.scrollElement.innerHeight });if (e.scrollElement) return n(), e.scrollElement.addEventListener("resize", n, { capture: !1, passive: !0 }), () => {
          e.scrollElement.removeEventListener("resize", n);
        };
      }, e.windowScroll = (e, t, s) => {
        var n;null == (n = s.scrollElement) || null == n.scrollTo || n.scrollTo({ [s.options.horizontal ? "left" : "top"]: e, behavior: t ? "smooth" : void 0 });
      }, Object.defineProperty(e, "__esModule", { value: !0 });
    });
    //# sourceMappingURL=index.production.js.map
  }
});
//# sourceMappingURL=index.production.js.map