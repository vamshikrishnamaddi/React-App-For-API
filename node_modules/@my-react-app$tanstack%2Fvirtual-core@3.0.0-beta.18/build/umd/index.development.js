Liferay.Loader.define('@my-react-app$tanstack/virtual-core@3.0.0-beta.18/build/umd/index.development', ['module', 'exports', 'require'], function (module, exports, require) {
  var define = undefined;
  var global = window;
  {
    function _objectWithoutProperties(obj, keys) {
      var target = {};

      for (var i in obj) {
        if (keys.indexOf(i) >= 0) continue;
        if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
        target[i] = obj[i];
      }

      return target;
    }

    var _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    /**
     * virtual-core
     *
     * Copyright (c) TanStack
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     */
    (function (global, factory) {
      typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.VirtualCore = {}));
    })(this, function (exports) {
      'use strict';

      function memo(getDeps, fn, opts) {
        let deps = [];
        let result;
        return () => {
          let depTime;
          if (opts.key && opts.debug != null && opts.debug()) depTime = Date.now();
          const newDeps = getDeps();
          const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => deps[index] !== dep);

          if (!depsChanged) {
            return result;
          }

          deps = newDeps;
          let resultTime;
          if (opts.key && opts.debug != null && opts.debug()) resultTime = Date.now();
          result = fn(...newDeps);
          opts == null ? void 0 : opts.onChange == null ? void 0 : opts.onChange(result);

          if (opts.key && opts.debug != null && opts.debug()) {
            const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;
            const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;


            const pad = (str, num) => {
              str = String(str);

              while (str.length < num) {
                str = ' ' + str;
              }

              return str;
            };

            console.info("%c\u23F1 " + pad(resultEndTime, 5) + " /" + pad(depEndTime, 5) + " ms", "\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(" + Math.max(0, Math.min(120 - 120 * (resultEndTime / 16), 120)) + "deg 100% 31%);", opts == null ? void 0 : opts.key);
          }

          return result;
        };
      }

      //
      const defaultKeyExtractor = index => index;
      const defaultRangeExtractor = range => {
        const start = Math.max(range.startIndex - range.overscan, 0);
        const end = Math.min(range.endIndex + range.overscan, range.count - 1);
        const arr = [];

        for (let i = start; i <= end; i++) {
          arr.push(i);
        }

        return arr;
      };

      const memoRectCallback = (instance, cb) => {
        let prev = {
          height: -1,
          width: -1
        };
        return rect => {
          if (instance.options.horizontal ? rect.width !== prev.width : rect.height !== prev.height) {
            cb(rect);
          }

          prev = rect;
        };
      };

      const scrollProps = {
        element: ['scrollLeft', 'scrollTop'],
        window: ['scrollX', 'scrollY']
      };

      const createOffsetObserver = mode => {
        return (instance, cb) => {
          if (!instance.scrollElement) {
            return;
          }

          const propX = scrollProps[mode][0];
          const propY = scrollProps[mode][1];
          let prevX = instance.scrollElement[propX];
          let prevY = instance.scrollElement[propY];

          const scroll = () => {
            cb(instance.scrollElement[instance.options.horizontal ? propX : propY]);
          };

          scroll();

          const onScroll = e => {
            const target = e.currentTarget;
            const scrollX = target[propX];
            const scrollY = target[propY];

            if (instance.options.horizontal ? prevX - scrollX : prevY - scrollY) {
              scroll();
            }

            prevX = scrollX;
            prevY = scrollY;
          };

          instance.scrollElement.addEventListener('scroll', onScroll, {
            capture: false,
            passive: true
          });
          return () => {
            instance.scrollElement.removeEventListener('scroll', onScroll);
          };
        };
      };

      const observeElementOffset = createOffsetObserver('element');
      const observeWindowOffset = createOffsetObserver('window');
      const measureElement = (element, instance) => {
        return element.getBoundingClientRect()[instance.options.horizontal ? 'width' : 'height'];
      };


      const findNearestBinarySearch = (low, high, getCurrentValue, value) => {
        while (low <= high) {
          const middle = (low + high) / 2 | 0;
          const currentValue = getCurrentValue(middle);

          if (currentValue < value) {
            low = middle + 1;
          } else if (currentValue > value) {
            high = middle - 1;
          } else {
            return middle;
          }
        }

        if (low > 0) {
          return low - 1;
        } else {
          return 0;
        }
      };

      function calculateRange(_ref2) {
        let {
          measurements,
          outerSize,
          scrollOffset
        } = _ref2;
        const count = measurements.length - 1;

        const startIndex = findNearestBinarySearch(0, count, index => measurements[index].start, scrollOffset);
        let endIndex = startIndex;

        while (endIndex < count && measurements[endIndex].end < scrollOffset + outerSize) {
          endIndex++;
        }

        return {
          startIndex,
          endIndex
        };
      }

      exports.Virtualizer = class Virtualizer {
        constructor(_opts) {
          var _this = this;

          this.unsubs = [];
          this.scrollElement = null;
          this.measurementsCache = [];
          this.itemMeasurementsCache = {};
          this.pendingMeasuredCacheIndexes = [];
          this.measureElementCache = {};
          this.range = {
            startIndex: 0,
            endIndex: 0
          };

          this.setOptions = opts => {
            Object.entries(opts).forEach(_ref => {
              let [key, value] = _ref;
              if (typeof value === 'undefined') delete opts[key];
            });
            this.options = _extends({
              debug: false,
              initialOffset: 0,
              overscan: 1,
              paddingStart: 0,
              paddingEnd: 0,
              scrollPaddingStart: 0,
              scrollPaddingEnd: 0,
              horizontal: false,
              getItemKey: defaultKeyExtractor,
              rangeExtractor: defaultRangeExtractor,
              enableSmoothScroll: true,
              onChange: () => {},
              measureElement,
              initialRect: {
                width: 0,
                height: 0
              }
            }, opts);
          };

          this.notify = () => {
            var _this$options$onChang, _this$options;

            (_this$options$onChang = (_this$options = this.options).onChange) == null ? void 0 : _this$options$onChang.call(_this$options, this);
          };

          this.cleanup = () => {
            this.unsubs.filter(Boolean).forEach(d => d());
            this.unsubs = [];
            this.scrollElement = null;
          };

          this._didMount = () => {
            return () => {
              this.cleanup();
            };
          };

          this._willUpdate = () => {
            const scrollElement = this.options.getScrollElement();

            if (this.scrollElement !== scrollElement) {
              this.cleanup();
              this.scrollElement = scrollElement;

              this._scrollToOffset(this.scrollOffset, false);

              this.unsubs.push(this.options.observeElementRect(this, rect => {
                this.scrollRect = rect;
                this.calculateRange();
              }));
              this.unsubs.push(this.options.observeElementOffset(this, offset => {
                this.scrollOffset = offset;
                this.calculateRange();
              }));
            }
          };

          this.getSize = () => {
            return this.scrollRect[this.options.horizontal ? 'width' : 'height'];
          };

          this.getMeasurements = memo(() => [this.options.count, this.options.paddingStart, this.options.getItemKey, this.itemMeasurementsCache], (count, paddingStart, getItemKey, measurementsCache) => {
            const min = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;
            this.pendingMeasuredCacheIndexes = [];
            const measurements = this.measurementsCache.slice(0, min);

            for (let i = min; i < count; i++) {
              const key = getItemKey(i);
              const measuredSize = measurementsCache[key];
              const start = measurements[i - 1] ? measurements[i - 1].end : paddingStart;
              const size = typeof measuredSize === 'number' ? measuredSize : this.options.estimateSize(i);

              measurements[i] = {
                index: i,
                start,
                size,
                end: start + size,
                key
              };
            }

            this.measurementsCache = measurements;
            return measurements;
          }, {
            key: 'getMeasurements',
            debug: () => this.options.debug
          });
          this.calculateRange = memo(() => [this.getMeasurements(), this.getSize(), this.scrollOffset], (measurements, outerSize, scrollOffset) => {
            const range = calculateRange({
              measurements,
              outerSize,
              scrollOffset
            });

            if (range.startIndex !== this.range.startIndex || range.endIndex !== this.range.endIndex) {
              this.range = range;
              this.notify();
            }

            return this.range;
          }, {
            key: 'calculateRange',
            debug: () => this.options.debug
          });
          this.getIndexes = memo(() => [this.options.rangeExtractor, this.range, this.options.overscan, this.options.count], (rangeExtractor, range, overscan, count) => {
            return rangeExtractor(_extends({}, range, {
              overscan,
              count: count
            }));
          }, {
            key: 'getIndexes',
            debug: () => this.options.debug
          });
          this.getVirtualItems = memo(() => [this.getIndexes(), this.getMeasurements(), this.options.measureElement], (indexes, measurements, measureElement) => {
            const makeMeasureElement = index => measurableItem => {
              var _this$itemMeasurement;

              const item = this.measurementsCache[index];

              if (!measurableItem) {
                return;
              }

              const measuredItemSize = measureElement(measurableItem, this);
              const itemSize = (_this$itemMeasurement = this.itemMeasurementsCache[item.key]) != null ? _this$itemMeasurement : item.size;

              if (measuredItemSize !== itemSize) {
                if (item.start < this.scrollOffset) {
                  if (this.options.debug) {
                    console.info('correction', measuredItemSize - itemSize);
                  }

                  if (!this.destinationOffset) {
                    this._scrollToOffset(this.scrollOffset + (measuredItemSize - itemSize), false);
                  }
                }

                this.pendingMeasuredCacheIndexes.push(index);
                this.itemMeasurementsCache = _extends({}, this.itemMeasurementsCache, {
                  [item.key]: measuredItemSize
                });
                this.notify();
              }
            };

            const virtualItems = [];
            const currentMeasureElements = {};

            for (let k = 0, len = indexes.length; k < len; k++) {
              var _this$measureElementC;

              const i = indexes[k];
              const measurement = measurements[i];
              const item = _extends({}, measurement, {
                measureElement: currentMeasureElements[i] = (_this$measureElementC = this.measureElementCache[i]) != null ? _this$measureElementC : makeMeasureElement(i)
              });
              virtualItems.push(item);
            }

            this.measureElementCache = currentMeasureElements;
            return virtualItems;
          }, {
            key: 'getIndexes',
            debug: () => this.options.debug
          });

          this.scrollToOffset = function (toOffset, _temp) {
            let {
              align = 'start',
              smoothScroll = _this.options.enableSmoothScroll
            } = _temp === void 0 ? {} : _temp;
            const offset = _this.scrollOffset;

            const size = _this.getSize();

            if (align === 'auto') {
              if (toOffset <= offset) {
                align = 'start';
              } else if (toOffset >= offset + size) {
                align = 'end';
              } else {
                align = 'start';
              }
            }

            if (align === 'start') {
              _this._scrollToOffset(toOffset, smoothScroll);
            } else if (align === 'end') {
              _this._scrollToOffset(toOffset - size, smoothScroll);
            } else if (align === 'center') {
              _this._scrollToOffset(toOffset - size / 2, smoothScroll);
            }
          };

          this.scrollToIndex = function (index, _temp2) {
            let _ref3 = _temp2 === void 0 ? {} : _temp2,
                {
              align = 'auto',
              smoothScroll = _this.options.enableSmoothScroll
            } = _ref3,
                rest = _objectWithoutProperties(_ref3, ['align', 'smoothScroll']);

            const measurements = _this.getMeasurements();

            const offset = _this.scrollOffset;

            const size = _this.getSize();

            const {
              count
            } = _this.options;
            const measurement = measurements[Math.max(0, Math.min(index, count - 1))];

            if (!measurement) {
              return;
            }

            if (align === 'auto') {
              if (measurement.end >= offset + size - _this.options.scrollPaddingEnd) {
                align = 'end';
              } else if (measurement.start <= offset + _this.options.scrollPaddingStart) {
                align = 'start';
              } else {
                return;
              }
            }

            const toOffset = align === 'end' ? measurement.end + _this.options.scrollPaddingEnd : measurement.start - _this.options.scrollPaddingStart;

            _this.scrollToOffset(toOffset, _extends({
              align,
              smoothScroll
            }, rest));
          };

          this.getTotalSize = () => {
            var _this$getMeasurements;

            return (((_this$getMeasurements = this.getMeasurements()[this.options.count - 1]) == null ? void 0 : _this$getMeasurements.end) || this.options.paddingStart) + this.options.paddingEnd;
          };

          this._scrollToOffset = (offset, canSmooth) => {
            clearTimeout(this.scrollCheckFrame);
            this.destinationOffset = offset;
            this.options.scrollToFn(offset, canSmooth, this);
            let scrollCheckFrame;

            const check = () => {
              let lastOffset = this.scrollOffset;
              this.scrollCheckFrame = scrollCheckFrame = setTimeout(() => {
                if (this.scrollCheckFrame !== scrollCheckFrame) {
                  return;
                }

                if (this.scrollOffset === lastOffset) {
                  this.destinationOffset = undefined;
                  return;
                }

                lastOffset = this.scrollOffset;
                check();
              }, 100);
            };

            check();
          };

          this.measure = () => {
            this.itemMeasurementsCache = {};
            this.notify();
          };

          this.setOptions(_opts);
          this.scrollRect = this.options.initialRect;
          this.scrollOffset = this.options.initialOffset;
          this.calculateRange();
        }

      };
      exports.defaultKeyExtractor = defaultKeyExtractor;
      exports.defaultRangeExtractor = defaultRangeExtractor;
      exports.elementScroll = (offset, canSmooth, instance) => {
        var _instance$scrollEleme2;
        (_instance$scrollEleme2 = instance.scrollElement) == null ? void 0 : _instance$scrollEleme2.scrollTo == null ? void 0 : _instance$scrollEleme2.scrollTo({
          [instance.options.horizontal ? 'left' : 'top']: offset,
          behavior: canSmooth ? 'smooth' : undefined
        });
      };
      exports.measureElement = measureElement;
      exports.memo = memo;
      exports.observeElementOffset = observeElementOffset;
      exports.observeElementRect = (instance, cb) => {
        const observer = new ResizeObserver(entries => {
          var _entries$, _entries$2;

          cb({
            width: (_entries$ = entries[0]) == null ? void 0 : _entries$.contentRect.width,
            height: (_entries$2 = entries[0]) == null ? void 0 : _entries$2.contentRect.height
          });
        });

        if (!instance.scrollElement) {
          return;
        }

        cb(instance.scrollElement.getBoundingClientRect());
        observer.observe(instance.scrollElement);
        return () => {
          observer.unobserve(instance.scrollElement);
        };
      };
      exports.observeWindowOffset = observeWindowOffset;
      exports.observeWindowRect = (instance, cb) => {
        const memoizedCallback = memoRectCallback(instance, cb);

        const onResize = () => memoizedCallback({
          width: instance.scrollElement.innerWidth,
          height: instance.scrollElement.innerHeight
        });

        if (!instance.scrollElement) {
          return;
        }

        onResize();
        instance.scrollElement.addEventListener('resize', onResize, {
          capture: false,
          passive: true
        });
        return () => {
          instance.scrollElement.removeEventListener('resize', onResize);
        };
      };
      exports.windowScroll = (offset, canSmooth, instance) => {
        var _instance$scrollEleme;
        (_instance$scrollEleme = instance.scrollElement) == null ? void 0 : _instance$scrollEleme.scrollTo == null ? void 0 : _instance$scrollEleme.scrollTo({
          [instance.options.horizontal ? 'left' : 'top']: offset,
          behavior: canSmooth ? 'smooth' : undefined
        });
      };

      Object.defineProperty(exports, '__esModule', { value: true });
    });
    //# sourceMappingURL=index.development.js.map
  }
});
//# sourceMappingURL=index.development.js.map