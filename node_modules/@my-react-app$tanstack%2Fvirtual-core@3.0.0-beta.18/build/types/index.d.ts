/**
 * virtual-core
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
declare type NoInfer<A extends any> = [A][A extends any ? 0 : never];
declare type PartialKeys<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
declare function memo<TDeps extends readonly any[], TResult>(getDeps: () => [...TDeps], fn: (...args: NoInfer<[...TDeps]>) => TResult, opts: {
    key: any;
    debug?: () => any;
    onChange?: (result: TResult) => void;
}): () => TResult;

declare type ScrollAlignment = 'start' | 'center' | 'end' | 'auto';
interface ScrollToOptions {
    align?: ScrollAlignment;
    smoothScroll?: boolean;
}
declare type ScrollToOffsetOptions = ScrollToOptions;
declare type ScrollToIndexOptions = ScrollToOptions;
interface Range {
    startIndex: number;
    endIndex: number;
    overscan: number;
    count: number;
}
declare type Key = number | string;
interface Item {
    key: Key;
    index: number;
    start: number;
    end: number;
    size: number;
}
interface Rect {
    width: number;
    height: number;
}
interface VirtualItem<TItemElement> extends Item {
    measureElement: (el: TItemElement | null) => void;
}
declare const defaultKeyExtractor: (index: number) => number;
declare const defaultRangeExtractor: (range: Range) => number[];
declare const observeElementRect: (instance: Virtualizer<any, any>, cb: (rect: Rect) => void) => (() => void) | undefined;
declare const observeWindowRect: (instance: Virtualizer<any, any>, cb: (rect: Rect) => void) => (() => void) | undefined;
declare const observeElementOffset: (instance: Virtualizer<any, any>, cb: (offset: number) => void) => (() => void) | undefined;
declare const observeWindowOffset: (instance: Virtualizer<any, any>, cb: (offset: number) => void) => (() => void) | undefined;
declare const measureElement: (element: unknown, instance: Virtualizer<any, any>) => number;
declare const windowScroll: (offset: number, canSmooth: boolean, instance: Virtualizer<any, any>) => void;
declare const elementScroll: (offset: number, canSmooth: boolean, instance: Virtualizer<any, any>) => void;
interface VirtualizerOptions<TScrollElement = unknown, TItemElement = unknown> {
    count: number;
    getScrollElement: () => TScrollElement;
    estimateSize: (index: number) => number;
    scrollToFn: (offset: number, canSmooth: boolean, instance: Virtualizer<TScrollElement, TItemElement>) => void;
    observeElementRect: (instance: Virtualizer<TScrollElement, TItemElement>, cb: (rect: Rect) => void) => void | (() => void);
    observeElementOffset: (instance: Virtualizer<TScrollElement, TItemElement>, cb: (offset: number) => void) => void | (() => void);
    debug?: any;
    initialRect?: Rect;
    onChange?: (instance: Virtualizer<TScrollElement, TItemElement>) => void;
    measureElement?: (el: TItemElement, instance: Virtualizer<TScrollElement, TItemElement>) => number;
    overscan?: number;
    horizontal?: boolean;
    paddingStart?: number;
    paddingEnd?: number;
    scrollPaddingStart?: number;
    scrollPaddingEnd?: number;
    initialOffset?: number;
    getItemKey?: (index: number) => Key;
    rangeExtractor?: (range: Range) => number[];
    enableSmoothScroll?: boolean;
}
declare class Virtualizer<TScrollElement = unknown, TItemElement = unknown> {
    private unsubs;
    options: Required<VirtualizerOptions<TScrollElement, TItemElement>>;
    scrollElement: TScrollElement | null;
    private measurementsCache;
    private itemMeasurementsCache;
    private pendingMeasuredCacheIndexes;
    private scrollRect;
    private scrollOffset;
    private destinationOffset;
    private scrollCheckFrame;
    private measureElementCache;
    private range;
    constructor(opts: VirtualizerOptions<TScrollElement, TItemElement>);
    setOptions: (opts: VirtualizerOptions<TScrollElement, TItemElement>) => void;
    private notify;
    private cleanup;
    _didMount: () => () => void;
    _willUpdate: () => void;
    private getSize;
    private getMeasurements;
    private calculateRange;
    private getIndexes;
    getVirtualItems: () => VirtualItem<TItemElement>[];
    scrollToOffset: (toOffset: number, { align, smoothScroll }?: ScrollToOffsetOptions) => void;
    scrollToIndex: (index: number, { align, smoothScroll, ...rest }?: ScrollToIndexOptions) => void;
    getTotalSize: () => number;
    private _scrollToOffset;
    measure: () => void;
}

export { NoInfer, PartialKeys, Range, ScrollToOptions, VirtualItem, Virtualizer, VirtualizerOptions, defaultKeyExtractor, defaultRangeExtractor, elementScroll, measureElement, memo, observeElementOffset, observeElementRect, observeWindowOffset, observeWindowRect, windowScroll };
