{"version":3,"sources":["../../src/utils.ts"],"names":["deps","opts","depTime","Date","newDeps","depsChanged","resultTime","result","fn","depEndTime","Math","resultEndTime","pad","str","String","console"],"mappings":";;;;;;;;;;;;;;;;;;AAIO,aAAA,IAAA,CAAA,OAAA,EAAA,EAAA,EAAA,IAAA,EAQU;AACf,UAAIA,OAAJ,EAAA;AACA,UAAA,MAAA;AAEA,aAAO,MAAM;AACX,YAAA,OAAA;AACA,YAAIC,KAAAA,GAAAA,IAAYA,KAAZA,KAAYA,IAAAA,IAAZA,IAAYA,KAAhB,KAAgBA,EAAhB,EAAgCC,UAAUC,KAAVD,GAAUC,EAAVD;AAEhC,cAAME,UAAN,SAAA;AAEA,cAAMC,cACJD,QAAAA,MAAAA,KAAmBJ,KAAnBI,MAAAA,IACAA,QAAAA,IAAAA,CAAa,CAAA,GAAA,EAAA,KAAA,KAA6BJ,KAAAA,KAAAA,MAF5C,GAEEI,CAFF;;AAIA,YAAI,CAAJ,WAAA,EAAkB;AAChB,iBAAA,MAAA;AACD;;AAEDJ,eAAAA,OAAAA;AAEA,YAAA,UAAA;AACA,YAAIC,KAAAA,GAAAA,IAAYA,KAAZA,KAAYA,IAAAA,IAAZA,IAAYA,KAAhB,KAAgBA,EAAhB,EAAgCK,aAAaH,KAAbG,GAAaH,EAAbG;AAEhCC,iBAASC,GAAG,GAAZD,OAASC,CAATD;AACAN,gBAAAA,IAAAA,GAAAA,KAAAA,CAAAA,GAAAA,KAAAA,QAAAA,IAAAA,IAAAA,GAAAA,KAAAA,CAAAA,GAAAA,KAAAA,QAAAA,CAAAA,MAAAA,CAAAA;;AAEA,YAAIA,KAAAA,GAAAA,IAAYA,KAAZA,KAAYA,IAAZA,IAAAA,IAAYA,KAAhB,KAAgBA,EAAhB,EAAgC;AAC9B,gBAAMQ,aAAaC,KAAAA,KAAAA,CAAW,CAACP,KAAAA,GAAAA,KAAD,OAAA,IAAXO,GAAAA,IAAnB,GAAA;AACA,gBAAMC,gBAAgBD,KAAAA,KAAAA,CAAW,CAACP,KAAAA,GAAAA,KAAD,UAAA,IAAXO,GAAAA,IAAtB,GAAA;;;AAGA,gBAAME,MAAM,CAAA,GAAA,EAAA,GAAA,KAAuC;AACjDC,kBAAMC,OAAND,GAAMC,CAAND;;AACA,mBAAOA,IAAAA,MAAAA,GAAP,GAAA,EAAyB;AACvBA,oBAAM,MAANA,GAAAA;AACD;;AACD,mBAAA,GAAA;AALF,WAAA;;AAQAE,kBAAAA,IAAAA,CAAAA,cACSH,IAAG,aAAHA,EADTG,CACSH,CADTG,GAAAA,IAAAA,GACmCH,IAAG,UAAHA,EADnCG,CACmCH,CADnCG,GAAAA,KAAAA,EAAAA,6FAKmBL,KAAAA,GAAAA,CAAAA,CAAAA,EAEXA,KAAAA,GAAAA,CAAS,MAATA,OAjBoBC,gBAA5B,EAiBQD,CAAAA,EAPRK,GAOQL,CAFWA,CALnBK,GAAAA,gBAAAA,EAAAA,QASEd,IATFc,GASEd,KAAAA,CATFc,GASEd,KATFc,GAAAA;AAWD;;AAED,eAAA,MAAA;AAhDF,OAAA;AAkDD","sourcesContent":["export type NoInfer<A extends any> = [A][A extends any ? 0 : never]\n\nexport type PartialKeys<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>\n\nexport function memo<TDeps extends readonly any[], TResult>(\n  getDeps: () => [...TDeps],\n  fn: (...args: NoInfer<[...TDeps]>) => TResult,\n  opts: {\n    key: any\n    debug?: () => any\n    onChange?: (result: TResult) => void\n  },\n): () => TResult {\n  let deps: any[] = []\n  let result: TResult | undefined\n\n  return () => {\n    let depTime: number\n    if (opts.key && opts.debug?.()) depTime = Date.now()\n\n    const newDeps = getDeps()\n\n    const depsChanged =\n      newDeps.length !== deps.length ||\n      newDeps.some((dep: any, index: number) => deps[index] !== dep)\n\n    if (!depsChanged) {\n      return result!\n    }\n\n    deps = newDeps\n\n    let resultTime: number\n    if (opts.key && opts.debug?.()) resultTime = Date.now()\n\n    result = fn(...newDeps)\n    opts?.onChange?.(result)\n\n    if (opts.key && opts.debug?.()) {\n      const depEndTime = Math.round((Date.now() - depTime!) * 100) / 100\n      const resultEndTime = Math.round((Date.now() - resultTime!) * 100) / 100\n      const resultFpsPercentage = resultEndTime / 16\n\n      const pad = (str: number | string, num: number) => {\n        str = String(str)\n        while (str.length < num) {\n          str = ' ' + str\n        }\n        return str\n      }\n\n      console.info(\n        `%c⏱ ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`,\n        `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(\n              0,\n              Math.min(120 - 120 * resultFpsPercentage, 120),\n            )}deg 100% 31%);`,\n        opts?.key,\n      )\n    }\n\n    return result!\n  }\n}\n"]}