{"version":3,"sources":["wrapConnectorHooks.js"],"names":["isValidElement","cloneWithRef","throwIfCompositeComponentElement","element","type","displayName","name","Error","wrapHookToRecognizeElement","hook","elementOrNode","options","node","ref","wrapConnectorHooks","hooks","wrappedHooks","Object","keys","forEach","key","endsWith","wrappedHook"],"mappings":";;;;AAAA,iBAASA,cAAT,QAA+B,OAA/B;AACA,iBAASC,YAAT,QAA6B,uBAA7B;AACA,iBAASC,gCAAT,CAA0CC,OAA1C,EAAmD;AAC/C;AACA;AACA,gBAAI,OAAOA,QAAQC,IAAf,KAAwB,QAA5B,EAAsC;AAClC;AACH;AACD,kBAAMC,cAAcF,QAAQC,IAAR,CAAaC,WAAb,IAA4BF,QAAQC,IAAR,CAAaE,IAAzC,IAAiD,eAArE;AACA,kBAAM,IAAIC,KAAJ,CAAU,yEACX,uBAAsBF,WAAY,mCADvB,GAEZ,sCAFE,CAAN;AAGH;AACD,iBAASG,0BAAT,CAAoCC,IAApC,EAA0C;AACtC,mBAAO,CAACC,gBAAgB,IAAjB,EAAuBC,UAAU,IAAjC,KAA0C;AAC7C;AACA,oBAAI,CAACX,eAAeU,aAAf,CAAL,EAAoC;AAChC,0BAAME,OAAOF,aAAb;AACAD,yBAAKG,IAAL,EAAWD,OAAX;AACA;AACA;AACA,2BAAOC,IAAP;AACH;AACD;AACA;AACA;AACA,sBAAMT,UAAUO,aAAhB;AACAR,iDAAiCC,OAAjC;AACA;AACA,sBAAMU,MAAMF,UAAWC,IAAD,IAAUH,KAAKG,IAAL,EAAWD,OAAX,CAApB,GAA0CF,IAAtD;AACA,uBAAOR,aAAaE,OAAb,EAAsBU,GAAtB,CAAP;AACH,aAjBD;AAkBH;AACD,eAAO,SAASC,kBAAT,CAA4BC,KAA5B,EAAmC;AACtC,kBAAMC,eAAe,EAArB;AACAC,mBAAOC,IAAP,CAAYH,KAAZ,EAAmBI,OAAnB,CAA4BC,GAAD,IAAS;AAChC,sBAAMX,OAAOM,MAAMK,GAAN,CAAb;AACA;AACA,oBAAIA,IAAIC,QAAJ,CAAa,KAAb,CAAJ,EAAyB;AACrBL,iCAAaI,GAAb,IAAoBL,MAAMK,GAAN,CAApB;AACH,iBAFD,MAGK;AACD,0BAAME,cAAcd,2BAA2BC,IAA3B,CAApB;AACAO,iCAAaI,GAAb,IAAoB,MAAME,WAA1B;AACH;AACJ,aAVD;AAWA,mBAAON,YAAP;AACH","file":"wrapConnectorHooks.js","sourcesContent":["import { isValidElement } from 'react';\nimport { cloneWithRef } from '../utils/cloneWithRef';\nfunction throwIfCompositeComponentElement(element) {\n    // Custom components can no longer be wrapped directly in React DnD 2.0\n    // so that we don't need to depend on findDOMNode() from react-dom.\n    if (typeof element.type === 'string') {\n        return;\n    }\n    const displayName = element.type.displayName || element.type.name || 'the component';\n    throw new Error('Only native element nodes can now be passed to React DnD connectors.' +\n        `You can either wrap ${displayName} into a <div>, or turn it into a ` +\n        'drag source or a drop target itself.');\n}\nfunction wrapHookToRecognizeElement(hook) {\n    return (elementOrNode = null, options = null) => {\n        // When passed a node, call the hook straight away.\n        if (!isValidElement(elementOrNode)) {\n            const node = elementOrNode;\n            hook(node, options);\n            // return the node so it can be chained (e.g. when within callback refs\n            // <div ref={node => connectDragSource(connectDropTarget(node))}/>\n            return node;\n        }\n        // If passed a ReactElement, clone it and attach this function as a ref.\n        // This helps us achieve a neat API where user doesn't even know that refs\n        // are being used under the hood.\n        const element = elementOrNode;\n        throwIfCompositeComponentElement(element);\n        // When no options are passed, use the hook directly\n        const ref = options ? (node) => hook(node, options) : hook;\n        return cloneWithRef(element, ref);\n    };\n}\nexport function wrapConnectorHooks(hooks) {\n    const wrappedHooks = {};\n    Object.keys(hooks).forEach((key) => {\n        const hook = hooks[key];\n        // ref objects should be passed straight through without wrapping\n        if (key.endsWith('Ref')) {\n            wrappedHooks[key] = hooks[key];\n        }\n        else {\n            const wrappedHook = wrapHookToRecognizeElement(hook);\n            wrappedHooks[key] = () => wrappedHook;\n        }\n    });\n    return wrappedHooks;\n}\n"]}