{"version":3,"sources":["wrapConnectorHooks.js"],"names":["Object","defineProperty","exports","value","wrapConnectorHooks","_react","require","_cloneWithRef","throwIfCompositeComponentElement","element","type","displayName","name","Error","concat","wrapHookToRecognizeElement","hook","elementOrNode","arguments","length","undefined","options","isValidElement","node","ref","cloneWithRef","hooks","wrappedHooks","keys","forEach","key","endsWith","wrappedHook"],"mappings":"AAAA;;;;;;AAEAA,WAAOC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,aAAO;AADoC,KAA7C;AAGAD,YAAQE,kBAAR,GAA6BA,kBAA7B;;AAEA,QAAIC,SAASC,QAAQ,oBAAR,CAAb;;AAEA,QAAIC,gBAAgBD,QAAQ,uBAAR,CAApB;;AAEA,aAASE,gCAAT,CAA0CC,OAA1C,EAAmD;AACjD;AACA;AACA,UAAI,OAAOA,QAAQC,IAAf,KAAwB,QAA5B,EAAsC;AACpC;AACD;;AAED,UAAIC,cAAcF,QAAQC,IAAR,CAAaC,WAAb,IAA4BF,QAAQC,IAAR,CAAaE,IAAzC,IAAiD,eAAnE;AACA,YAAM,IAAIC,KAAJ,CAAU,yEAAyE,uBAAuBC,MAAvB,CAA8BH,WAA9B,EAA2C,mCAA3C,CAAzE,GAA2J,sCAArK,CAAN;AACD;;AAED,aAASI,0BAAT,CAAoCC,IAApC,EAA0C;AACxC,aAAO,YAAY;AACjB,YAAIC,gBAAgBC,UAAUC,MAAV,GAAmB,CAAnB,IAAwBD,UAAU,CAAV,MAAiBE,SAAzC,GAAqDF,UAAU,CAAV,CAArD,GAAoE,IAAxF;AACA,YAAIG,UAAUH,UAAUC,MAAV,GAAmB,CAAnB,IAAwBD,UAAU,CAAV,MAAiBE,SAAzC,GAAqDF,UAAU,CAAV,CAArD,GAAoE,IAAlF;;AAEA;AACA,YAAI,CAAC,CAAC,GAAGb,OAAOiB,cAAX,EAA2BL,aAA3B,CAAL,EAAgD;AAC9C,cAAIM,OAAON,aAAX;AACAD,eAAKO,IAAL,EAAWF,OAAX,EAF8C,CAEzB;AACrB;;AAEA,iBAAOE,IAAP;AACD,SAXgB,CAWf;AACF;AACA;;;AAGA,YAAId,UAAUQ,aAAd;AACAT,yCAAiCC,OAAjC,EAjBiB,CAiB0B;;AAE3C,YAAIe,MAAMH,UAAU,UAAUE,IAAV,EAAgB;AAClC,iBAAOP,KAAKO,IAAL,EAAWF,OAAX,CAAP;AACD,SAFS,GAENL,IAFJ;AAGA,eAAO,CAAC,GAAGT,cAAckB,YAAlB,EAAgChB,OAAhC,EAAyCe,GAAzC,CAAP;AACD,OAvBD;AAwBD;;AAED,aAASpB,kBAAT,CAA4BsB,KAA5B,EAAmC;AACjC,UAAIC,eAAe,EAAnB;AACA3B,aAAO4B,IAAP,CAAYF,KAAZ,EAAmBG,OAAnB,CAA2B,UAAUC,GAAV,EAAe;AACxC,YAAId,OAAOU,MAAMI,GAAN,CAAX,CADwC,CACjB;;AAEvB,YAAIA,IAAIC,QAAJ,CAAa,KAAb,CAAJ,EAAyB;AACvBJ,uBAAaG,GAAb,IAAoBJ,MAAMI,GAAN,CAApB;AACD,SAFD,MAEO;AACL,cAAIE,cAAcjB,2BAA2BC,IAA3B,CAAlB;;AAEAW,uBAAaG,GAAb,IAAoB,YAAY;AAC9B,mBAAOE,WAAP;AACD,WAFD;AAGD;AACF,OAZD;AAaA,aAAOL,YAAP;AACD","file":"wrapConnectorHooks.js","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.wrapConnectorHooks = wrapConnectorHooks;\n\nvar _react = require(\"react\");\n\nvar _cloneWithRef = require(\"../utils/cloneWithRef\");\n\nfunction throwIfCompositeComponentElement(element) {\n  // Custom components can no longer be wrapped directly in React DnD 2.0\n  // so that we don't need to depend on findDOMNode() from react-dom.\n  if (typeof element.type === 'string') {\n    return;\n  }\n\n  var displayName = element.type.displayName || element.type.name || 'the component';\n  throw new Error('Only native element nodes can now be passed to React DnD connectors.' + \"You can either wrap \".concat(displayName, \" into a <div>, or turn it into a \") + 'drag source or a drop target itself.');\n}\n\nfunction wrapHookToRecognizeElement(hook) {\n  return function () {\n    var elementOrNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    // When passed a node, call the hook straight away.\n    if (!(0, _react.isValidElement)(elementOrNode)) {\n      var node = elementOrNode;\n      hook(node, options); // return the node so it can be chained (e.g. when within callback refs\n      // <div ref={node => connectDragSource(connectDropTarget(node))}/>\n\n      return node;\n    } // If passed a ReactElement, clone it and attach this function as a ref.\n    // This helps us achieve a neat API where user doesn't even know that refs\n    // are being used under the hood.\n\n\n    var element = elementOrNode;\n    throwIfCompositeComponentElement(element); // When no options are passed, use the hook directly\n\n    var ref = options ? function (node) {\n      return hook(node, options);\n    } : hook;\n    return (0, _cloneWithRef.cloneWithRef)(element, ref);\n  };\n}\n\nfunction wrapConnectorHooks(hooks) {\n  var wrappedHooks = {};\n  Object.keys(hooks).forEach(function (key) {\n    var hook = hooks[key]; // ref objects should be passed straight through without wrapping\n\n    if (key.endsWith('Ref')) {\n      wrappedHooks[key] = hooks[key];\n    } else {\n      var wrappedHook = wrapHookToRecognizeElement(hook);\n\n      wrappedHooks[key] = function () {\n        return wrappedHook;\n      };\n    }\n  });\n  return wrappedHooks;\n}"]}