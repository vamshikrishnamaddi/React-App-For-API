{"version":3,"sources":["react-dom-unstable-native-dependencies.development.js"],"names":["ReactDOM","require","_assign","validateFormat","format","undefined","Error","invariant","condition","a","b","c","d","e","f","error","args","argIndex","replace","name","framesToPop","window","dispatchEvent","document","createEvent","createElement","warningWithoutStack","_len","arguments","length","Array","_key","console","argsWithFormat","map","item","unshift","Function","prototype","apply","call","message","x","warningWithoutStack$1","getFiberCurrentPropsFromNode$1","getInstanceFromNode$1","getNodeFromInstance$1","setComponentTree","getFiberCurrentPropsFromNodeImpl","getInstanceFromNodeImpl","getNodeFromInstanceImpl","validateEventDispatches","event","dispatchListeners","_dispatchListeners","dispatchInstances","_dispatchInstances","listenersIsArr","isArray","listenersLen","instancesIsArr","instancesLen","executeDispatchesInOrderStopAtTrueImpl","i","isPropagationStopped","executeDispatchesInOrderStopAtTrue","ret","executeDirectDispatch","dispatchListener","dispatchInstance","currentTarget","res","hasDispatches","getParent","inst","return","tag","getLowestCommonAncestor","instA","instB","depthA","tempA","depthB","tempB","depth","alternate","isAncestor","getParentInstance","traverseTwoPhase","fn","arg","path","push","accumulateInto","current","next","concat","forEachAccumulated","arr","cb","scope","forEach","isInteractive","shouldPreventMouseEvent","type","props","disabled","getListener","registrationName","listener","stateNode","listenerAtPhase","propagationPhase","dispatchConfig","phasedRegistrationNames","accumulateDirectionalDispatches","phase","accumulateTwoPhaseDispatchesSingle","_targetInst","accumulateTwoPhaseDispatchesSingleSkipTarget","targetInst","parentInst","accumulateDispatches","ignoredDirection","accumulateDirectDispatchesSingle","accumulateTwoPhaseDispatches","events","accumulateTwoPhaseDispatchesSkipTarget","accumulateDirectDispatches","functionThatReturnsTrue","functionThatReturnsFalse","SyntheticEvent","nativeEvent","nativeEventTarget","preventDefault","stopPropagation","isDefaultPrevented","Interface","constructor","propName","hasOwnProperty","normalize","target","defaultPrevented","returnValue","cancelBubble","persist","isPersistent","destructor","Object","defineProperty","getPooledWarningPropertyDefinition","eventPhase","bubbles","cancelable","timeStamp","Date","now","isTrusted","extend","Super","E","Class","addEventPoolingTo","getVal","isFunction","configurable","set","val","action","warn","get","result","getPooledEvent","nativeInst","EventConstructor","eventPool","instance","pop","releasePooledEvent","getPooled","release","ResponderSyntheticEvent","touchHistory","TOP_TOUCH_START","TOP_TOUCH_MOVE","TOP_TOUCH_END","TOP_TOUCH_CANCEL","TOP_SCROLL","TOP_SELECTION_CHANGE","TOP_MOUSE_DOWN","TOP_MOUSE_MOVE","TOP_MOUSE_UP","isStartish","topLevelType","isMoveish","isEndish","startDependencies","moveDependencies","endDependencies","MAX_TOUCH_BANK","touchBank","numberActiveTouches","indexOfSingleActiveTouch","mostRecentTimeStamp","timestampForTouch","touch","timestamp","createTouchRecord","touchActive","startPageX","pageX","startPageY","pageY","startTimeStamp","currentPageX","currentPageY","currentTimeStamp","previousPageX","previousPageY","previousTimeStamp","resetTouchRecord","touchRecord","getTouchIdentifier","_ref","identifier","recordTouchStart","recordTouchMove","printTouch","printTouchBank","recordTouchEnd","JSON","stringify","printed","slice","ResponderTouchHistoryStore","recordTouchTrack","changedTouches","touches","touchTrackToCheck","activeRecord","accumulate","responderInst","trackedTouchCount","changeResponder","nextResponderInst","blockHostResponder","oldResponderInst","ResponderEventPlugin","GlobalResponderHandler","onChange","eventTypes","startShouldSetResponder","bubbled","captured","dependencies","scrollShouldSetResponder","selectionChangeShouldSetResponder","moveShouldSetResponder","responderStart","responderMove","responderEnd","responderRelease","responderTerminationRequest","responderGrant","responderReject","responderTerminate","setResponderAndExtractTransfer","shouldSetEventType","bubbleShouldSetFrom","skipOverBubbleShouldSetFrom","shouldSetEvent","wantsResponderInst","extracted","grantEvent","terminationRequestEvent","shouldSwitch","terminateEvent","rejectEvent","canTriggerTransfer","topLevelInst","responderIgnoreScroll","noResponderTouches","activeTouch","_getResponder","extractEvents","isResponderTouchStart","isResponderTouchMove","isResponderTouchEnd","incrementalTouch","gesture","isResponderTerminate","isResponderRelease","finalTouch","finalEvent","injection","injectGlobalResponderHandler","_ReactDOM$__SECRET_IN","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","Events","getInstanceFromNode","getNodeFromInstance","getFiberCurrentPropsFromNode","injectEventPluginsByName","ReactDOMUnstableNativeDependencies","freeze","module","exports"],"mappings":"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","file":"react-dom-unstable-native-dependencies.development.js","sourcesContent":["/** @license React v16.8.6\n * react-dom-unstable-native-dependencies.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nvar ReactDOM = require('react-dom');\nvar _assign = require('object-assign');\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar validateFormat = function () {};\n\n{\n  validateFormat = function (format) {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  };\n}\n\nfunction invariant(condition, format, a, b, c, d, e, f) {\n  validateFormat(format);\n\n  if (!condition) {\n    var error = void 0;\n    if (format === undefined) {\n      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(format.replace(/%s/g, function () {\n        return args[argIndex++];\n      }));\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n}\n\n// Relying on the `invariant()` implementation lets us\n// preserve the format and params in the www builds.\n\n{\n  // In DEV mode, we swap out invokeGuardedCallback for a special version\n  // that plays more nicely with the browser's DevTools. The idea is to preserve\n  // \"Pause on exceptions\" behavior. Because React wraps all user-provided\n  // functions in invokeGuardedCallback, and the production version of\n  // invokeGuardedCallback uses a try-catch, all user exceptions are treated\n  // like caught exceptions, and the DevTools won't pause unless the developer\n  // takes the extra step of enabling pause on caught exceptions. This is\n  // unintuitive, though, because even though React has caught the error, from\n  // the developer's perspective, the error is uncaught.\n  //\n  // To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n  // DOM node, and call the user-provided callback from inside an event handler\n  // for that fake event. If the callback throws, the error is \"captured\" using\n  // a global event handler. But because the error happens in a different\n  // event loop context, it does not interrupt the normal program flow.\n  // Effectively, this gives us try-catch behavior without actually using\n  // try-catch. Neat!\n\n  // Check that the browser supports the APIs we need to implement our special\n  // DEV version of invokeGuardedCallback\n  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {\n    var fakeNode = document.createElement('react');\n\n    \n  }\n}\n\n/**\n * Call a function while guarding against errors that happens within it.\n * Returns an error if it throws, otherwise null.\n *\n * In production, this is implemented using a try-catch. The reason we don't\n * use a try-catch directly is so that we can swap out a different\n * implementation in DEV mode.\n *\n * @param {String} name of the guard to use for logging or debugging\n * @param {Function} func The function to invoke\n * @param {*} context The context to use when calling the function\n * @param {...*} args Arguments for function\n */\n\n\n/**\n * Same as invokeGuardedCallback, but instead of returning an error, it stores\n * it in a global so it can be rethrown by `rethrowCaughtError` later.\n * TODO: See if caughtError and rethrowError can be unified.\n *\n * @param {String} name of the guard to use for logging or debugging\n * @param {Function} func The function to invoke\n * @param {*} context The context to use when calling the function\n * @param {...*} args Arguments for function\n */\n\n\n/**\n * During execution of guarded functions we will capture the first error which\n * we will rethrow to be handled by the top level error handler.\n */\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar warningWithoutStack = function () {};\n\n{\n  warningWithoutStack = function (condition, format) {\n    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    if (format === undefined) {\n      throw new Error('`warningWithoutStack(condition, format, ...args)` requires a warning ' + 'message argument');\n    }\n    if (args.length > 8) {\n      // Check before the condition to catch violations early.\n      throw new Error('warningWithoutStack() currently supports at most 8 arguments.');\n    }\n    if (condition) {\n      return;\n    }\n    if (typeof console !== 'undefined') {\n      var argsWithFormat = args.map(function (item) {\n        return '' + item;\n      });\n      argsWithFormat.unshift('Warning: ' + format);\n\n      // We intentionally don't use spread (or .apply) directly because it\n      // breaks IE9: https://github.com/facebook/react/issues/13610\n      Function.prototype.apply.call(console.error, console, argsWithFormat);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      var argIndex = 0;\n      var message = 'Warning: ' + format.replace(/%s/g, function () {\n        return args[argIndex++];\n      });\n      throw new Error(message);\n    } catch (x) {}\n  };\n}\n\nvar warningWithoutStack$1 = warningWithoutStack;\n\nvar getFiberCurrentPropsFromNode$1 = null;\nvar getInstanceFromNode$1 = null;\nvar getNodeFromInstance$1 = null;\n\nfunction setComponentTree(getFiberCurrentPropsFromNodeImpl, getInstanceFromNodeImpl, getNodeFromInstanceImpl) {\n  getFiberCurrentPropsFromNode$1 = getFiberCurrentPropsFromNodeImpl;\n  getInstanceFromNode$1 = getInstanceFromNodeImpl;\n  getNodeFromInstance$1 = getNodeFromInstanceImpl;\n  {\n    !(getNodeFromInstance$1 && getInstanceFromNode$1) ? warningWithoutStack$1(false, 'EventPluginUtils.setComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.') : void 0;\n  }\n}\n\nvar validateEventDispatches = void 0;\n{\n  validateEventDispatches = function (event) {\n    var dispatchListeners = event._dispatchListeners;\n    var dispatchInstances = event._dispatchInstances;\n\n    var listenersIsArr = Array.isArray(dispatchListeners);\n    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;\n\n    var instancesIsArr = Array.isArray(dispatchInstances);\n    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;\n\n    !(instancesIsArr === listenersIsArr && instancesLen === listenersLen) ? warningWithoutStack$1(false, 'EventPluginUtils: Invalid `event`.') : void 0;\n  };\n}\n\n/**\n * Standard/simple iteration through an event's collected dispatches.\n */\n\n\n/**\n * Standard/simple iteration through an event's collected dispatches, but stops\n * at the first dispatch execution returning true, and returns that id.\n *\n * @return {?string} id of the first dispatch execution who's listener returns\n * true, or null if no listener returned true.\n */\nfunction executeDispatchesInOrderStopAtTrueImpl(event) {\n  var dispatchListeners = event._dispatchListeners;\n  var dispatchInstances = event._dispatchInstances;\n  {\n    validateEventDispatches(event);\n  }\n  if (Array.isArray(dispatchListeners)) {\n    for (var i = 0; i < dispatchListeners.length; i++) {\n      if (event.isPropagationStopped()) {\n        break;\n      }\n      // Listeners and Instances are two parallel arrays that are always in sync.\n      if (dispatchListeners[i](event, dispatchInstances[i])) {\n        return dispatchInstances[i];\n      }\n    }\n  } else if (dispatchListeners) {\n    if (dispatchListeners(event, dispatchInstances)) {\n      return dispatchInstances;\n    }\n  }\n  return null;\n}\n\n/**\n * @see executeDispatchesInOrderStopAtTrueImpl\n */\nfunction executeDispatchesInOrderStopAtTrue(event) {\n  var ret = executeDispatchesInOrderStopAtTrueImpl(event);\n  event._dispatchInstances = null;\n  event._dispatchListeners = null;\n  return ret;\n}\n\n/**\n * Execution of a \"direct\" dispatch - there must be at most one dispatch\n * accumulated on the event or it is considered an error. It doesn't really make\n * sense for an event with multiple dispatches (bubbled) to keep track of the\n * return values at each dispatch execution, but it does tend to make sense when\n * dealing with \"direct\" dispatches.\n *\n * @return {*} The return value of executing the single dispatch.\n */\nfunction executeDirectDispatch(event) {\n  {\n    validateEventDispatches(event);\n  }\n  var dispatchListener = event._dispatchListeners;\n  var dispatchInstance = event._dispatchInstances;\n  !!Array.isArray(dispatchListener) ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : void 0;\n  event.currentTarget = dispatchListener ? getNodeFromInstance$1(dispatchInstance) : null;\n  var res = dispatchListener ? dispatchListener(event) : null;\n  event.currentTarget = null;\n  event._dispatchListeners = null;\n  event._dispatchInstances = null;\n  return res;\n}\n\n/**\n * @param {SyntheticEvent} event\n * @return {boolean} True iff number of dispatches accumulated is greater than 0.\n */\nfunction hasDispatches(event) {\n  return !!event._dispatchListeners;\n}\n\n// Before we know whether it is function or class\n // Root of a host tree. Could be nested inside another node.\n // A subtree. Could be an entry point to a different renderer.\nvar HostComponent = 5;\n\nfunction getParent(inst) {\n  do {\n    inst = inst.return;\n    // TODO: If this is a HostRoot we might want to bail out.\n    // That is depending on if we want nested subtrees (layers) to bubble\n    // events to their parent. We could also go through parentNode on the\n    // host node but that wouldn't work for React Native and doesn't let us\n    // do the portal feature.\n  } while (inst && inst.tag !== HostComponent);\n  if (inst) {\n    return inst;\n  }\n  return null;\n}\n\n/**\n * Return the lowest common ancestor of A and B, or null if they are in\n * different trees.\n */\nfunction getLowestCommonAncestor(instA, instB) {\n  var depthA = 0;\n  for (var tempA = instA; tempA; tempA = getParent(tempA)) {\n    depthA++;\n  }\n  var depthB = 0;\n  for (var tempB = instB; tempB; tempB = getParent(tempB)) {\n    depthB++;\n  }\n\n  // If A is deeper, crawl up.\n  while (depthA - depthB > 0) {\n    instA = getParent(instA);\n    depthA--;\n  }\n\n  // If B is deeper, crawl up.\n  while (depthB - depthA > 0) {\n    instB = getParent(instB);\n    depthB--;\n  }\n\n  // Walk in lockstep until we find a match.\n  var depth = depthA;\n  while (depth--) {\n    if (instA === instB || instA === instB.alternate) {\n      return instA;\n    }\n    instA = getParent(instA);\n    instB = getParent(instB);\n  }\n  return null;\n}\n\n/**\n * Return if A is an ancestor of B.\n */\nfunction isAncestor(instA, instB) {\n  while (instB) {\n    if (instA === instB || instA === instB.alternate) {\n      return true;\n    }\n    instB = getParent(instB);\n  }\n  return false;\n}\n\n/**\n * Return the parent instance of the passed-in instance.\n */\nfunction getParentInstance(inst) {\n  return getParent(inst);\n}\n\n/**\n * Simulates the traversal of a two-phase, capture/bubble event dispatch.\n */\nfunction traverseTwoPhase(inst, fn, arg) {\n  var path = [];\n  while (inst) {\n    path.push(inst);\n    inst = getParent(inst);\n  }\n  var i = void 0;\n  for (i = path.length; i-- > 0;) {\n    fn(path[i], 'captured', arg);\n  }\n  for (i = 0; i < path.length; i++) {\n    fn(path[i], 'bubbled', arg);\n  }\n}\n\n/**\n * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\n * should would receive a `mouseEnter` or `mouseLeave` event.\n *\n * Does not invoke the callback on the nearest common ancestor because nothing\n * \"entered\" or \"left\" that element.\n */\n\n/**\n * Registers plugins so that they can extract and dispatch events.\n *\n * @see {EventPluginHub}\n */\n\n/**\n * Ordered list of injected plugins.\n */\n\n\n/**\n * Mapping from event name to dispatch config\n */\n\n\n/**\n * Mapping from registration name to plugin module\n */\n\n\n/**\n * Mapping from registration name to event name\n */\n\n\n/**\n * Mapping from lowercase registration names to the properly cased version,\n * used to warn in the case of missing event handlers. Available\n * only in true.\n * @type {Object}\n */\n\n// Trust the developer to only use possibleRegistrationNames in true\n\n/**\n * Injects an ordering of plugins (by plugin name). This allows the ordering\n * to be decoupled from injection of the actual plugins so that ordering is\n * always deterministic regardless of packaging, on-the-fly injection, etc.\n *\n * @param {array} InjectedEventPluginOrder\n * @internal\n * @see {EventPluginHub.injection.injectEventPluginOrder}\n */\n\n\n/**\n * Injects plugins to be used by `EventPluginHub`. The plugin names must be\n * in the ordering injected by `injectEventPluginOrder`.\n *\n * Plugins can be injected as part of page initialization or on-the-fly.\n *\n * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n * @internal\n * @see {EventPluginHub.injection.injectEventPluginsByName}\n */\n\n/**\n * Accumulates items that must not be null or undefined into the first one. This\n * is used to conserve memory by avoiding array allocations, and thus sacrifices\n * API cleanness. Since `current` can be null before being passed in and not\n * null after this function, make sure to assign it back to `current`:\n *\n * `a = accumulateInto(a, b);`\n *\n * This API should be sparingly used. Try `accumulate` for something cleaner.\n *\n * @return {*|array<*>} An accumulation of items.\n */\n\nfunction accumulateInto(current, next) {\n  !(next != null) ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : void 0;\n\n  if (current == null) {\n    return next;\n  }\n\n  // Both are not empty. Warning: Never call x.concat(y) when you are not\n  // certain that x is an Array (x could be a string with concat method).\n  if (Array.isArray(current)) {\n    if (Array.isArray(next)) {\n      current.push.apply(current, next);\n      return current;\n    }\n    current.push(next);\n    return current;\n  }\n\n  if (Array.isArray(next)) {\n    // A bit too dangerous to mutate `next`.\n    return [current].concat(next);\n  }\n\n  return [current, next];\n}\n\n/**\n * @param {array} arr an \"accumulation\" of items which is either an Array or\n * a single item. Useful when paired with the `accumulate` module. This is a\n * simple utility that allows us to reason about a collection of items, but\n * handling the case when there is exactly one item (and we do not need to\n * allocate an array).\n * @param {function} cb Callback invoked with each element or a collection.\n * @param {?} [scope] Scope used as `this` in a callback.\n */\nfunction forEachAccumulated(arr, cb, scope) {\n  if (Array.isArray(arr)) {\n    arr.forEach(cb, scope);\n  } else if (arr) {\n    cb.call(scope, arr);\n  }\n}\n\nfunction isInteractive(tag) {\n  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';\n}\n\nfunction shouldPreventMouseEvent(name, type, props) {\n  switch (name) {\n    case 'onClick':\n    case 'onClickCapture':\n    case 'onDoubleClick':\n    case 'onDoubleClickCapture':\n    case 'onMouseDown':\n    case 'onMouseDownCapture':\n    case 'onMouseMove':\n    case 'onMouseMoveCapture':\n    case 'onMouseUp':\n    case 'onMouseUpCapture':\n      return !!(props.disabled && isInteractive(type));\n    default:\n      return false;\n  }\n}\n\n/**\n * This is a unified interface for event plugins to be installed and configured.\n *\n * Event plugins can implement the following properties:\n *\n *   `extractEvents` {function(string, DOMEventTarget, string, object): *}\n *     Required. When a top-level event is fired, this method is expected to\n *     extract synthetic events that will in turn be queued and dispatched.\n *\n *   `eventTypes` {object}\n *     Optional, plugins that fire events must publish a mapping of registration\n *     names that are used to register listeners. Values of this mapping must\n *     be objects that contain `registrationName` or `phasedRegistrationNames`.\n *\n *   `executeDispatch` {function(object, function, string)}\n *     Optional, allows plugins to override how an event gets dispatched. By\n *     default, the listener is simply invoked.\n *\n * Each plugin that is injected into `EventsPluginHub` is immediately operable.\n *\n * @public\n */\n\n/**\n * Methods for injecting dependencies.\n */\n\n\n/**\n * @param {object} inst The instance, which is the source of events.\n * @param {string} registrationName Name of listener (e.g. `onClick`).\n * @return {?function} The stored callback.\n */\nfunction getListener(inst, registrationName) {\n  var listener = void 0;\n\n  // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not\n  // live here; needs to be moved to a better place soon\n  var stateNode = inst.stateNode;\n  if (!stateNode) {\n    // Work in progress (ex: onload events in incremental mode).\n    return null;\n  }\n  var props = getFiberCurrentPropsFromNode$1(stateNode);\n  if (!props) {\n    // Work in progress.\n    return null;\n  }\n  listener = props[registrationName];\n  if (shouldPreventMouseEvent(registrationName, inst.type, props)) {\n    return null;\n  }\n  !(!listener || typeof listener === 'function') ? invariant(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.', registrationName, typeof listener) : void 0;\n  return listener;\n}\n\n/**\n * Some event types have a notion of different registration names for different\n * \"phases\" of propagation. This finds listeners by a given phase.\n */\nfunction listenerAtPhase(inst, event, propagationPhase) {\n  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n  return getListener(inst, registrationName);\n}\n\n/**\n * A small set of propagation patterns, each of which will accept a small amount\n * of information, and generate a set of \"dispatch ready event objects\" - which\n * are sets of events that have already been annotated with a set of dispatched\n * listener functions/ids. The API is designed this way to discourage these\n * propagation strategies from actually executing the dispatches, since we\n * always want to collect the entire set of dispatches before executing even a\n * single one.\n */\n\n/**\n * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n * here, allows us to not have to bind or create functions for each event.\n * Mutating the event's members allows us to not have to create a wrapping\n * \"dispatch\" object that pairs the event with the listener.\n */\nfunction accumulateDirectionalDispatches(inst, phase, event) {\n  {\n    !inst ? warningWithoutStack$1(false, 'Dispatching inst must not be null') : void 0;\n  }\n  var listener = listenerAtPhase(inst, event, phase);\n  if (listener) {\n    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n  }\n}\n\n/**\n * Collect dispatches (must be entirely collected before dispatching - see unit\n * tests). Lazily allocate the array to conserve memory.  We must loop through\n * each event and perform the traversal for each one. We cannot perform a\n * single traversal for the entire collection of events because each event may\n * have a different target.\n */\nfunction accumulateTwoPhaseDispatchesSingle(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.\n */\nfunction accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    var targetInst = event._targetInst;\n    var parentInst = targetInst ? getParentInstance(targetInst) : null;\n    traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Accumulates without regard to direction, does not look for phased\n * registration names. Same as `accumulateDirectDispatchesSingle` but without\n * requiring that the `dispatchMarker` be the same as the dispatched ID.\n */\nfunction accumulateDispatches(inst, ignoredDirection, event) {\n  if (inst && event && event.dispatchConfig.registrationName) {\n    var registrationName = event.dispatchConfig.registrationName;\n    var listener = getListener(inst, registrationName);\n    if (listener) {\n      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n    }\n  }\n}\n\n/**\n * Accumulates dispatches on an `SyntheticEvent`, but only for the\n * `dispatchMarker`.\n * @param {SyntheticEvent} event\n */\nfunction accumulateDirectDispatchesSingle(event) {\n  if (event && event.dispatchConfig.registrationName) {\n    accumulateDispatches(event._targetInst, null, event);\n  }\n}\n\nfunction accumulateTwoPhaseDispatches(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n}\n\nfunction accumulateTwoPhaseDispatchesSkipTarget(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\n}\n\n\n\nfunction accumulateDirectDispatches(events) {\n  forEachAccumulated(events, accumulateDirectDispatchesSingle);\n}\n\n/* eslint valid-typeof: 0 */\n\nvar EVENT_POOL_SIZE = 10;\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar EventInterface = {\n  type: null,\n  target: null,\n  // currentTarget is set when dispatching; no use in copying it here\n  currentTarget: function () {\n    return null;\n  },\n  eventPhase: null,\n  bubbles: null,\n  cancelable: null,\n  timeStamp: function (event) {\n    return event.timeStamp || Date.now();\n  },\n  defaultPrevented: null,\n  isTrusted: null\n};\n\nfunction functionThatReturnsTrue() {\n  return true;\n}\n\nfunction functionThatReturnsFalse() {\n  return false;\n}\n\n/**\n * Synthetic events are dispatched by event plugins, typically in response to a\n * top-level event delegation handler.\n *\n * These systems should generally use pooling to reduce the frequency of garbage\n * collection. The system should check `isPersistent` to determine whether the\n * event should be released into the pool after being dispatched. Users that\n * need a persisted event should invoke `persist`.\n *\n * Synthetic events (and subclasses) implement the DOM Level 3 Events API by\n * normalizing browser quirks. Subclasses do not necessarily have to implement a\n * DOM interface; custom application-specific events can also subclass this.\n *\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {*} targetInst Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @param {DOMEventTarget} nativeEventTarget Target node.\n */\nfunction SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {\n  {\n    // these have a getter/setter for warnings\n    delete this.nativeEvent;\n    delete this.preventDefault;\n    delete this.stopPropagation;\n    delete this.isDefaultPrevented;\n    delete this.isPropagationStopped;\n  }\n\n  this.dispatchConfig = dispatchConfig;\n  this._targetInst = targetInst;\n  this.nativeEvent = nativeEvent;\n\n  var Interface = this.constructor.Interface;\n  for (var propName in Interface) {\n    if (!Interface.hasOwnProperty(propName)) {\n      continue;\n    }\n    {\n      delete this[propName]; // this has a getter/setter for warnings\n    }\n    var normalize = Interface[propName];\n    if (normalize) {\n      this[propName] = normalize(nativeEvent);\n    } else {\n      if (propName === 'target') {\n        this.target = nativeEventTarget;\n      } else {\n        this[propName] = nativeEvent[propName];\n      }\n    }\n  }\n\n  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;\n  if (defaultPrevented) {\n    this.isDefaultPrevented = functionThatReturnsTrue;\n  } else {\n    this.isDefaultPrevented = functionThatReturnsFalse;\n  }\n  this.isPropagationStopped = functionThatReturnsFalse;\n  return this;\n}\n\n_assign(SyntheticEvent.prototype, {\n  preventDefault: function () {\n    this.defaultPrevented = true;\n    var event = this.nativeEvent;\n    if (!event) {\n      return;\n    }\n\n    if (event.preventDefault) {\n      event.preventDefault();\n    } else if (typeof event.returnValue !== 'unknown') {\n      event.returnValue = false;\n    }\n    this.isDefaultPrevented = functionThatReturnsTrue;\n  },\n\n  stopPropagation: function () {\n    var event = this.nativeEvent;\n    if (!event) {\n      return;\n    }\n\n    if (event.stopPropagation) {\n      event.stopPropagation();\n    } else if (typeof event.cancelBubble !== 'unknown') {\n      // The ChangeEventPlugin registers a \"propertychange\" event for\n      // IE. This event does not support bubbling or cancelling, and\n      // any references to cancelBubble throw \"Member not found\".  A\n      // typeof check of \"unknown\" circumvents this issue (and is also\n      // IE specific).\n      event.cancelBubble = true;\n    }\n\n    this.isPropagationStopped = functionThatReturnsTrue;\n  },\n\n  /**\n   * We release all dispatched `SyntheticEvent`s after each event loop, adding\n   * them back into the pool. This allows a way to hold onto a reference that\n   * won't be added back into the pool.\n   */\n  persist: function () {\n    this.isPersistent = functionThatReturnsTrue;\n  },\n\n  /**\n   * Checks if this event should be released back into the pool.\n   *\n   * @return {boolean} True if this should not be released, false otherwise.\n   */\n  isPersistent: functionThatReturnsFalse,\n\n  /**\n   * `PooledClass` looks for `destructor` on each instance it releases.\n   */\n  destructor: function () {\n    var Interface = this.constructor.Interface;\n    for (var propName in Interface) {\n      {\n        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));\n      }\n    }\n    this.dispatchConfig = null;\n    this._targetInst = null;\n    this.nativeEvent = null;\n    this.isDefaultPrevented = functionThatReturnsFalse;\n    this.isPropagationStopped = functionThatReturnsFalse;\n    this._dispatchListeners = null;\n    this._dispatchInstances = null;\n    {\n      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));\n      Object.defineProperty(this, 'isDefaultPrevented', getPooledWarningPropertyDefinition('isDefaultPrevented', functionThatReturnsFalse));\n      Object.defineProperty(this, 'isPropagationStopped', getPooledWarningPropertyDefinition('isPropagationStopped', functionThatReturnsFalse));\n      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', function () {}));\n      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', function () {}));\n    }\n  }\n});\n\nSyntheticEvent.Interface = EventInterface;\n\n/**\n * Helper to reduce boilerplate when creating subclasses.\n */\nSyntheticEvent.extend = function (Interface) {\n  var Super = this;\n\n  var E = function () {};\n  E.prototype = Super.prototype;\n  var prototype = new E();\n\n  function Class() {\n    return Super.apply(this, arguments);\n  }\n  _assign(prototype, Class.prototype);\n  Class.prototype = prototype;\n  Class.prototype.constructor = Class;\n\n  Class.Interface = _assign({}, Super.Interface, Interface);\n  Class.extend = Super.extend;\n  addEventPoolingTo(Class);\n\n  return Class;\n};\n\naddEventPoolingTo(SyntheticEvent);\n\n/**\n * Helper to nullify syntheticEvent instance properties when destructing\n *\n * @param {String} propName\n * @param {?object} getVal\n * @return {object} defineProperty object\n */\nfunction getPooledWarningPropertyDefinition(propName, getVal) {\n  var isFunction = typeof getVal === 'function';\n  return {\n    configurable: true,\n    set: set,\n    get: get\n  };\n\n  function set(val) {\n    var action = isFunction ? 'setting the method' : 'setting the property';\n    warn(action, 'This is effectively a no-op');\n    return val;\n  }\n\n  function get() {\n    var action = isFunction ? 'accessing the method' : 'accessing the property';\n    var result = isFunction ? 'This is a no-op function' : 'This is set to null';\n    warn(action, result);\n    return getVal;\n  }\n\n  function warn(action, result) {\n    var warningCondition = false;\n    !warningCondition ? warningWithoutStack$1(false, \"This synthetic event is reused for performance reasons. If you're seeing this, \" + \"you're %s `%s` on a released/nullified synthetic event. %s. \" + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result) : void 0;\n  }\n}\n\nfunction getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {\n  var EventConstructor = this;\n  if (EventConstructor.eventPool.length) {\n    var instance = EventConstructor.eventPool.pop();\n    EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);\n    return instance;\n  }\n  return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);\n}\n\nfunction releasePooledEvent(event) {\n  var EventConstructor = this;\n  !(event instanceof EventConstructor) ? invariant(false, 'Trying to release an event instance into a pool of a different type.') : void 0;\n  event.destructor();\n  if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {\n    EventConstructor.eventPool.push(event);\n  }\n}\n\nfunction addEventPoolingTo(EventConstructor) {\n  EventConstructor.eventPool = [];\n  EventConstructor.getPooled = getPooledEvent;\n  EventConstructor.release = releasePooledEvent;\n}\n\n/**\n * `touchHistory` isn't actually on the native event, but putting it in the\n * interface will ensure that it is cleaned up when pooled/destroyed. The\n * `ResponderEventPlugin` will populate it appropriately.\n */\nvar ResponderSyntheticEvent = SyntheticEvent.extend({\n  touchHistory: function (nativeEvent) {\n    return null; // Actually doesn't even look at the native event.\n  }\n});\n\n// Note: ideally these would be imported from DOMTopLevelEventTypes,\n// but our build system currently doesn't let us do that from a fork.\n\nvar TOP_TOUCH_START = 'touchstart';\nvar TOP_TOUCH_MOVE = 'touchmove';\nvar TOP_TOUCH_END = 'touchend';\nvar TOP_TOUCH_CANCEL = 'touchcancel';\nvar TOP_SCROLL = 'scroll';\nvar TOP_SELECTION_CHANGE = 'selectionchange';\nvar TOP_MOUSE_DOWN = 'mousedown';\nvar TOP_MOUSE_MOVE = 'mousemove';\nvar TOP_MOUSE_UP = 'mouseup';\n\nfunction isStartish(topLevelType) {\n  return topLevelType === TOP_TOUCH_START || topLevelType === TOP_MOUSE_DOWN;\n}\n\nfunction isMoveish(topLevelType) {\n  return topLevelType === TOP_TOUCH_MOVE || topLevelType === TOP_MOUSE_MOVE;\n}\n\nfunction isEndish(topLevelType) {\n  return topLevelType === TOP_TOUCH_END || topLevelType === TOP_TOUCH_CANCEL || topLevelType === TOP_MOUSE_UP;\n}\n\nvar startDependencies = [TOP_TOUCH_START, TOP_MOUSE_DOWN];\nvar moveDependencies = [TOP_TOUCH_MOVE, TOP_MOUSE_MOVE];\nvar endDependencies = [TOP_TOUCH_CANCEL, TOP_TOUCH_END, TOP_MOUSE_UP];\n\n/**\n * Tracks the position and time of each active touch by `touch.identifier`. We\n * should typically only see IDs in the range of 1-20 because IDs get recycled\n * when touches end and start again.\n */\n\n\nvar MAX_TOUCH_BANK = 20;\nvar touchBank = [];\nvar touchHistory = {\n  touchBank: touchBank,\n  numberActiveTouches: 0,\n  // If there is only one active touch, we remember its location. This prevents\n  // us having to loop through all of the touches all the time in the most\n  // common case.\n  indexOfSingleActiveTouch: -1,\n  mostRecentTimeStamp: 0\n};\n\nfunction timestampForTouch(touch) {\n  // The legacy internal implementation provides \"timeStamp\", which has been\n  // renamed to \"timestamp\". Let both work for now while we iron it out\n  // TODO (evv): rename timeStamp to timestamp in internal code\n  return touch.timeStamp || touch.timestamp;\n}\n\n/**\n * TODO: Instead of making gestures recompute filtered velocity, we could\n * include a built in velocity computation that can be reused globally.\n */\nfunction createTouchRecord(touch) {\n  return {\n    touchActive: true,\n    startPageX: touch.pageX,\n    startPageY: touch.pageY,\n    startTimeStamp: timestampForTouch(touch),\n    currentPageX: touch.pageX,\n    currentPageY: touch.pageY,\n    currentTimeStamp: timestampForTouch(touch),\n    previousPageX: touch.pageX,\n    previousPageY: touch.pageY,\n    previousTimeStamp: timestampForTouch(touch)\n  };\n}\n\nfunction resetTouchRecord(touchRecord, touch) {\n  touchRecord.touchActive = true;\n  touchRecord.startPageX = touch.pageX;\n  touchRecord.startPageY = touch.pageY;\n  touchRecord.startTimeStamp = timestampForTouch(touch);\n  touchRecord.currentPageX = touch.pageX;\n  touchRecord.currentPageY = touch.pageY;\n  touchRecord.currentTimeStamp = timestampForTouch(touch);\n  touchRecord.previousPageX = touch.pageX;\n  touchRecord.previousPageY = touch.pageY;\n  touchRecord.previousTimeStamp = timestampForTouch(touch);\n}\n\nfunction getTouchIdentifier(_ref) {\n  var identifier = _ref.identifier;\n\n  !(identifier != null) ? invariant(false, 'Touch object is missing identifier.') : void 0;\n  {\n    !(identifier <= MAX_TOUCH_BANK) ? warningWithoutStack$1(false, 'Touch identifier %s is greater than maximum supported %s which causes ' + 'performance issues backfilling array locations for all of the indices.', identifier, MAX_TOUCH_BANK) : void 0;\n  }\n  return identifier;\n}\n\nfunction recordTouchStart(touch) {\n  var identifier = getTouchIdentifier(touch);\n  var touchRecord = touchBank[identifier];\n  if (touchRecord) {\n    resetTouchRecord(touchRecord, touch);\n  } else {\n    touchBank[identifier] = createTouchRecord(touch);\n  }\n  touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n}\n\nfunction recordTouchMove(touch) {\n  var touchRecord = touchBank[getTouchIdentifier(touch)];\n  if (touchRecord) {\n    touchRecord.touchActive = true;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.error('Cannot record touch move without a touch start.\\n' + 'Touch Move: %s\\n', 'Touch Bank: %s', printTouch(touch), printTouchBank());\n  }\n}\n\nfunction recordTouchEnd(touch) {\n  var touchRecord = touchBank[getTouchIdentifier(touch)];\n  if (touchRecord) {\n    touchRecord.touchActive = false;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.error('Cannot record touch end without a touch start.\\n' + 'Touch End: %s\\n', 'Touch Bank: %s', printTouch(touch), printTouchBank());\n  }\n}\n\nfunction printTouch(touch) {\n  return JSON.stringify({\n    identifier: touch.identifier,\n    pageX: touch.pageX,\n    pageY: touch.pageY,\n    timestamp: timestampForTouch(touch)\n  });\n}\n\nfunction printTouchBank() {\n  var printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));\n  if (touchBank.length > MAX_TOUCH_BANK) {\n    printed += ' (original size: ' + touchBank.length + ')';\n  }\n  return printed;\n}\n\nvar ResponderTouchHistoryStore = {\n  recordTouchTrack: function (topLevelType, nativeEvent) {\n    if (isMoveish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchMove);\n    } else if (isStartish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchStart);\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n      if (touchHistory.numberActiveTouches === 1) {\n        touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier;\n      }\n    } else if (isEndish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchEnd);\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n      if (touchHistory.numberActiveTouches === 1) {\n        for (var i = 0; i < touchBank.length; i++) {\n          var touchTrackToCheck = touchBank[i];\n          if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {\n            touchHistory.indexOfSingleActiveTouch = i;\n            break;\n          }\n        }\n        {\n          var activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];\n          !(activeRecord != null && activeRecord.touchActive) ? warningWithoutStack$1(false, 'Cannot find single active touch.') : void 0;\n        }\n      }\n    }\n  },\n\n\n  touchHistory: touchHistory\n};\n\n/**\n * Accumulates items that must not be null or undefined.\n *\n * This is used to conserve memory by avoiding array allocations.\n *\n * @return {*|array<*>} An accumulation of items.\n */\nfunction accumulate(current, next) {\n  !(next != null) ? invariant(false, 'accumulate(...): Accumulated items must be not be null or undefined.') : void 0;\n\n  if (current == null) {\n    return next;\n  }\n\n  // Both are not empty. Warning: Never call x.concat(y) when you are not\n  // certain that x is an Array (x could be a string with concat method).\n  if (Array.isArray(current)) {\n    return current.concat(next);\n  }\n\n  if (Array.isArray(next)) {\n    return [current].concat(next);\n  }\n\n  return [current, next];\n}\n\n/**\n * Instance of element that should respond to touch/move types of interactions,\n * as indicated explicitly by relevant callbacks.\n */\nvar responderInst = null;\n\n/**\n * Count of current touches. A textInput should become responder iff the\n * selection changes while there is a touch on the screen.\n */\nvar trackedTouchCount = 0;\n\nvar changeResponder = function (nextResponderInst, blockHostResponder) {\n  var oldResponderInst = responderInst;\n  responderInst = nextResponderInst;\n  if (ResponderEventPlugin.GlobalResponderHandler !== null) {\n    ResponderEventPlugin.GlobalResponderHandler.onChange(oldResponderInst, nextResponderInst, blockHostResponder);\n  }\n};\n\nvar eventTypes = {\n  /**\n   * On a `touchStart`/`mouseDown`, is it desired that this element become the\n   * responder?\n   */\n  startShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: 'onStartShouldSetResponder',\n      captured: 'onStartShouldSetResponderCapture'\n    },\n    dependencies: startDependencies\n  },\n\n  /**\n   * On a `scroll`, is it desired that this element become the responder? This\n   * is usually not needed, but should be used to retroactively infer that a\n   * `touchStart` had occurred during momentum scroll. During a momentum scroll,\n   * a touch start will be immediately followed by a scroll event if the view is\n   * currently scrolling.\n   *\n   * TODO: This shouldn't bubble.\n   */\n  scrollShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: 'onScrollShouldSetResponder',\n      captured: 'onScrollShouldSetResponderCapture'\n    },\n    dependencies: [TOP_SCROLL]\n  },\n\n  /**\n   * On text selection change, should this element become the responder? This\n   * is needed for text inputs or other views with native selection, so the\n   * JS view can claim the responder.\n   *\n   * TODO: This shouldn't bubble.\n   */\n  selectionChangeShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: 'onSelectionChangeShouldSetResponder',\n      captured: 'onSelectionChangeShouldSetResponderCapture'\n    },\n    dependencies: [TOP_SELECTION_CHANGE]\n  },\n\n  /**\n   * On a `touchMove`/`mouseMove`, is it desired that this element become the\n   * responder?\n   */\n  moveShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: 'onMoveShouldSetResponder',\n      captured: 'onMoveShouldSetResponderCapture'\n    },\n    dependencies: moveDependencies\n  },\n\n  /**\n   * Direct responder events dispatched directly to responder. Do not bubble.\n   */\n  responderStart: {\n    registrationName: 'onResponderStart',\n    dependencies: startDependencies\n  },\n  responderMove: {\n    registrationName: 'onResponderMove',\n    dependencies: moveDependencies\n  },\n  responderEnd: {\n    registrationName: 'onResponderEnd',\n    dependencies: endDependencies\n  },\n  responderRelease: {\n    registrationName: 'onResponderRelease',\n    dependencies: endDependencies\n  },\n  responderTerminationRequest: {\n    registrationName: 'onResponderTerminationRequest',\n    dependencies: []\n  },\n  responderGrant: {\n    registrationName: 'onResponderGrant',\n    dependencies: []\n  },\n  responderReject: {\n    registrationName: 'onResponderReject',\n    dependencies: []\n  },\n  responderTerminate: {\n    registrationName: 'onResponderTerminate',\n    dependencies: []\n  }\n};\n\n/**\n *\n * Responder System:\n * ----------------\n *\n * - A global, solitary \"interaction lock\" on a view.\n * - If a node becomes the responder, it should convey visual feedback\n *   immediately to indicate so, either by highlighting or moving accordingly.\n * - To be the responder means, that touches are exclusively important to that\n *   responder view, and no other view.\n * - While touches are still occurring, the responder lock can be transferred to\n *   a new view, but only to increasingly \"higher\" views (meaning ancestors of\n *   the current responder).\n *\n * Responder being granted:\n * ------------------------\n *\n * - Touch starts, moves, and scrolls can cause an ID to become the responder.\n * - We capture/bubble `startShouldSetResponder`/`moveShouldSetResponder` to\n *   the \"appropriate place\".\n * - If nothing is currently the responder, the \"appropriate place\" is the\n *   initiating event's `targetID`.\n * - If something *is* already the responder, the \"appropriate place\" is the\n *   first common ancestor of the event target and the current `responderInst`.\n * - Some negotiation happens: See the timing diagram below.\n * - Scrolled views automatically become responder. The reasoning is that a\n *   platform scroll view that isn't built on top of the responder system has\n *   began scrolling, and the active responder must now be notified that the\n *   interaction is no longer locked to it - the system has taken over.\n *\n * - Responder being released:\n *   As soon as no more touches that *started* inside of descendants of the\n *   *current* responderInst, an `onResponderRelease` event is dispatched to the\n *   current responder, and the responder lock is released.\n *\n * TODO:\n * - on \"end\", a callback hook for `onResponderEndShouldRemainResponder` that\n *   determines if the responder lock should remain.\n * - If a view shouldn't \"remain\" the responder, any active touches should by\n *   default be considered \"dead\" and do not influence future negotiations or\n *   bubble paths. It should be as if those touches do not exist.\n * -- For multitouch: Usually a translate-z will choose to \"remain\" responder\n *  after one out of many touches ended. For translate-y, usually the view\n *  doesn't wish to \"remain\" responder after one of many touches end.\n * - Consider building this on top of a `stopPropagation` model similar to\n *   `W3C` events.\n * - Ensure that `onResponderTerminate` is called on touch cancels, whether or\n *   not `onResponderTerminationRequest` returns `true` or `false`.\n *\n */\n\n/*                                             Negotiation Performed\n                                             +-----------------------+\n                                            /                         \\\nProcess low level events to    +     Current Responder      +   wantsResponderID\ndetermine who to perform negot-|   (if any exists at all)   |\niation/transition              | Otherwise just pass through|\n-------------------------------+----------------------------+------------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +-------------+           |                            |\n     | onTouchStart|           |                            |\n     +------+------+     none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onStartShouldSetResponder|----->|onResponderStart (cur)  |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderReject\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | |   onResponder          | |\n            +------------------->|      TerminationRequest| |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | |   onResponderTerminate |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderStart|\n                               |                            | +----------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +-------------+           |                            |\n     | onTouchMove |           |                            |\n     +------+------+     none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onMoveShouldSetResponder |----->|onResponderMove (cur)   |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderRejec|\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | |   onResponder          | |\n            +------------------->|      TerminationRequest| |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | |   onResponderTerminate |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderMove |\n                               |                            | +----------------+\n                               |                            |\n                               |                            |\n      Some active touch started|                            |\n      inside current responder | +------------------------+ |\n      +------------------------->|      onResponderEnd    | |\n      |                        | +------------------------+ |\n  +---+---------+              |                            |\n  | onTouchEnd  |              |                            |\n  +---+---------+              |                            |\n      |                        | +------------------------+ |\n      +------------------------->|     onResponderEnd     | |\n      No active touches started| +-----------+------------+ |\n      inside current responder |             |              |\n                               |             v              |\n                               | +------------------------+ |\n                               | |    onResponderRelease  | |\n                               | +------------------------+ |\n                               |                            |\n                               +                            + */\n\n/**\n * A note about event ordering in the `EventPluginHub`.\n *\n * Suppose plugins are injected in the following order:\n *\n * `[R, S, C]`\n *\n * To help illustrate the example, assume `S` is `SimpleEventPlugin` (for\n * `onClick` etc) and `R` is `ResponderEventPlugin`.\n *\n * \"Deferred-Dispatched Events\":\n *\n * - The current event plugin system will traverse the list of injected plugins,\n *   in order, and extract events by collecting the plugin's return value of\n *   `extractEvents()`.\n * - These events that are returned from `extractEvents` are \"deferred\n *   dispatched events\".\n * - When returned from `extractEvents`, deferred-dispatched events contain an\n *   \"accumulation\" of deferred dispatches.\n * - These deferred dispatches are accumulated/collected before they are\n *   returned, but processed at a later time by the `EventPluginHub` (hence the\n *   name deferred).\n *\n * In the process of returning their deferred-dispatched events, event plugins\n * themselves can dispatch events on-demand without returning them from\n * `extractEvents`. Plugins might want to do this, so that they can use event\n * dispatching as a tool that helps them decide which events should be extracted\n * in the first place.\n *\n * \"On-Demand-Dispatched Events\":\n *\n * - On-demand-dispatched events are not returned from `extractEvents`.\n * - On-demand-dispatched events are dispatched during the process of returning\n *   the deferred-dispatched events.\n * - They should not have side effects.\n * - They should be avoided, and/or eventually be replaced with another\n *   abstraction that allows event plugins to perform multiple \"rounds\" of event\n *   extraction.\n *\n * Therefore, the sequence of event dispatches becomes:\n *\n * - `R`s on-demand events (if any)   (dispatched by `R` on-demand)\n * - `S`s on-demand events (if any)   (dispatched by `S` on-demand)\n * - `C`s on-demand events (if any)   (dispatched by `C` on-demand)\n * - `R`s extracted events (if any)   (dispatched by `EventPluginHub`)\n * - `S`s extracted events (if any)   (dispatched by `EventPluginHub`)\n * - `C`s extracted events (if any)   (dispatched by `EventPluginHub`)\n *\n * In the case of `ResponderEventPlugin`: If the `startShouldSetResponder`\n * on-demand dispatch returns `true` (and some other details are satisfied) the\n * `onResponderGrant` deferred dispatched event is returned from\n * `extractEvents`. The sequence of dispatch executions in this case\n * will appear as follows:\n *\n * - `startShouldSetResponder` (`ResponderEventPlugin` dispatches on-demand)\n * - `touchStartCapture`       (`EventPluginHub` dispatches as usual)\n * - `touchStart`              (`EventPluginHub` dispatches as usual)\n * - `responderGrant/Reject`   (`EventPluginHub` dispatches as usual)\n */\n\nfunction setResponderAndExtractTransfer(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n  var shouldSetEventType = isStartish(topLevelType) ? eventTypes.startShouldSetResponder : isMoveish(topLevelType) ? eventTypes.moveShouldSetResponder : topLevelType === TOP_SELECTION_CHANGE ? eventTypes.selectionChangeShouldSetResponder : eventTypes.scrollShouldSetResponder;\n\n  // TODO: stop one short of the current responder.\n  var bubbleShouldSetFrom = !responderInst ? targetInst : getLowestCommonAncestor(responderInst, targetInst);\n\n  // When capturing/bubbling the \"shouldSet\" event, we want to skip the target\n  // (deepest ID) if it happens to be the current responder. The reasoning:\n  // It's strange to get an `onMoveShouldSetResponder` when you're *already*\n  // the responder.\n  var skipOverBubbleShouldSetFrom = bubbleShouldSetFrom === responderInst;\n  var shouldSetEvent = ResponderSyntheticEvent.getPooled(shouldSetEventType, bubbleShouldSetFrom, nativeEvent, nativeEventTarget);\n  shouldSetEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n  if (skipOverBubbleShouldSetFrom) {\n    accumulateTwoPhaseDispatchesSkipTarget(shouldSetEvent);\n  } else {\n    accumulateTwoPhaseDispatches(shouldSetEvent);\n  }\n  var wantsResponderInst = executeDispatchesInOrderStopAtTrue(shouldSetEvent);\n  if (!shouldSetEvent.isPersistent()) {\n    shouldSetEvent.constructor.release(shouldSetEvent);\n  }\n\n  if (!wantsResponderInst || wantsResponderInst === responderInst) {\n    return null;\n  }\n  var extracted = void 0;\n  var grantEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderGrant, wantsResponderInst, nativeEvent, nativeEventTarget);\n  grantEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n\n  accumulateDirectDispatches(grantEvent);\n  var blockHostResponder = executeDirectDispatch(grantEvent) === true;\n  if (responderInst) {\n    var terminationRequestEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderTerminationRequest, responderInst, nativeEvent, nativeEventTarget);\n    terminationRequestEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n    accumulateDirectDispatches(terminationRequestEvent);\n    var shouldSwitch = !hasDispatches(terminationRequestEvent) || executeDirectDispatch(terminationRequestEvent);\n    if (!terminationRequestEvent.isPersistent()) {\n      terminationRequestEvent.constructor.release(terminationRequestEvent);\n    }\n\n    if (shouldSwitch) {\n      var terminateEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderTerminate, responderInst, nativeEvent, nativeEventTarget);\n      terminateEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(terminateEvent);\n      extracted = accumulate(extracted, [grantEvent, terminateEvent]);\n      changeResponder(wantsResponderInst, blockHostResponder);\n    } else {\n      var rejectEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderReject, wantsResponderInst, nativeEvent, nativeEventTarget);\n      rejectEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(rejectEvent);\n      extracted = accumulate(extracted, rejectEvent);\n    }\n  } else {\n    extracted = accumulate(extracted, grantEvent);\n    changeResponder(wantsResponderInst, blockHostResponder);\n  }\n  return extracted;\n}\n\n/**\n * A transfer is a negotiation between a currently set responder and the next\n * element to claim responder status. Any start event could trigger a transfer\n * of responderInst. Any move event could trigger a transfer.\n *\n * @param {string} topLevelType Record from `BrowserEventConstants`.\n * @return {boolean} True if a transfer of responder could possibly occur.\n */\nfunction canTriggerTransfer(topLevelType, topLevelInst, nativeEvent) {\n  return topLevelInst && (\n  // responderIgnoreScroll: We are trying to migrate away from specifically\n  // tracking native scroll events here and responderIgnoreScroll indicates we\n  // will send topTouchCancel to handle canceling touch events instead\n  topLevelType === TOP_SCROLL && !nativeEvent.responderIgnoreScroll || trackedTouchCount > 0 && topLevelType === TOP_SELECTION_CHANGE || isStartish(topLevelType) || isMoveish(topLevelType));\n}\n\n/**\n * Returns whether or not this touch end event makes it such that there are no\n * longer any touches that started inside of the current `responderInst`.\n *\n * @param {NativeEvent} nativeEvent Native touch end event.\n * @return {boolean} Whether or not this touch end event ends the responder.\n */\nfunction noResponderTouches(nativeEvent) {\n  var touches = nativeEvent.touches;\n  if (!touches || touches.length === 0) {\n    return true;\n  }\n  for (var i = 0; i < touches.length; i++) {\n    var activeTouch = touches[i];\n    var target = activeTouch.target;\n    if (target !== null && target !== undefined && target !== 0) {\n      // Is the original touch location inside of the current responder?\n      var targetInst = getInstanceFromNode$1(target);\n      if (isAncestor(responderInst, targetInst)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nvar ResponderEventPlugin = {\n  /* For unit testing only */\n  _getResponder: function () {\n    return responderInst;\n  },\n\n  eventTypes: eventTypes,\n\n  /**\n   * We must be resilient to `targetInst` being `null` on `touchMove` or\n   * `touchEnd`. On certain platforms, this means that a native scroll has\n   * assumed control and the original touch targets are destroyed.\n   */\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    if (isStartish(topLevelType)) {\n      trackedTouchCount += 1;\n    } else if (isEndish(topLevelType)) {\n      if (trackedTouchCount >= 0) {\n        trackedTouchCount -= 1;\n      } else {\n        console.error('Ended a touch event which was not counted in `trackedTouchCount`.');\n        return null;\n      }\n    }\n\n    ResponderTouchHistoryStore.recordTouchTrack(topLevelType, nativeEvent);\n\n    var extracted = canTriggerTransfer(topLevelType, targetInst, nativeEvent) ? setResponderAndExtractTransfer(topLevelType, targetInst, nativeEvent, nativeEventTarget) : null;\n    // Responder may or may not have transferred on a new touch start/move.\n    // Regardless, whoever is the responder after any potential transfer, we\n    // direct all touch start/move/ends to them in the form of\n    // `onResponderMove/Start/End`. These will be called for *every* additional\n    // finger that move/start/end, dispatched directly to whoever is the\n    // current responder at that moment, until the responder is \"released\".\n    //\n    // These multiple individual change touch events are are always bookended\n    // by `onResponderGrant`, and one of\n    // (`onResponderRelease/onResponderTerminate`).\n    var isResponderTouchStart = responderInst && isStartish(topLevelType);\n    var isResponderTouchMove = responderInst && isMoveish(topLevelType);\n    var isResponderTouchEnd = responderInst && isEndish(topLevelType);\n    var incrementalTouch = isResponderTouchStart ? eventTypes.responderStart : isResponderTouchMove ? eventTypes.responderMove : isResponderTouchEnd ? eventTypes.responderEnd : null;\n\n    if (incrementalTouch) {\n      var gesture = ResponderSyntheticEvent.getPooled(incrementalTouch, responderInst, nativeEvent, nativeEventTarget);\n      gesture.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(gesture);\n      extracted = accumulate(extracted, gesture);\n    }\n\n    var isResponderTerminate = responderInst && topLevelType === TOP_TOUCH_CANCEL;\n    var isResponderRelease = responderInst && !isResponderTerminate && isEndish(topLevelType) && noResponderTouches(nativeEvent);\n    var finalTouch = isResponderTerminate ? eventTypes.responderTerminate : isResponderRelease ? eventTypes.responderRelease : null;\n    if (finalTouch) {\n      var finalEvent = ResponderSyntheticEvent.getPooled(finalTouch, responderInst, nativeEvent, nativeEventTarget);\n      finalEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(finalEvent);\n      extracted = accumulate(extracted, finalEvent);\n      changeResponder(null);\n    }\n\n    return extracted;\n  },\n\n  GlobalResponderHandler: null,\n\n  injection: {\n    /**\n     * @param {{onChange: (ReactID, ReactID) => void} GlobalResponderHandler\n     * Object that handles any change in responder. Use this to inject\n     * integration with an existing touch handling system etc.\n     */\n    injectGlobalResponderHandler: function (GlobalResponderHandler) {\n      ResponderEventPlugin.GlobalResponderHandler = GlobalResponderHandler;\n    }\n  }\n};\n\n// Inject react-dom's ComponentTree into this module.\n// Keep in sync with ReactDOM.js and ReactTestUtils.js:\nvar _ReactDOM$__SECRET_IN = ReactDOM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Events;\nvar getInstanceFromNode = _ReactDOM$__SECRET_IN[0];\nvar getNodeFromInstance = _ReactDOM$__SECRET_IN[1];\nvar getFiberCurrentPropsFromNode = _ReactDOM$__SECRET_IN[2];\nvar injectEventPluginsByName = _ReactDOM$__SECRET_IN[3];\n\n\nsetComponentTree(getFiberCurrentPropsFromNode, getInstanceFromNode, getNodeFromInstance);\n\n\n\nvar ReactDOMUnstableNativeDependencies = Object.freeze({\n\tResponderEventPlugin: ResponderEventPlugin,\n\tResponderTouchHistoryStore: ResponderTouchHistoryStore,\n\tinjectEventPluginsByName: injectEventPluginsByName\n});\n\nvar unstableNativeDependencies = ReactDOMUnstableNativeDependencies;\n\nmodule.exports = unstableNativeDependencies;\n  })();\n}\n"]}