{"version":3,"sources":["scheduler-tracing.development.js"],"names":["Object","defineProperty","exports","value","DEFAULT_THREAD_ID","interactionIDCounter","threadIDCounter","__interactionsRef","__subscriberRef","current","Set","unstable_getThreadID","unstable_trace","name","timestamp","callback","threadID","arguments","length","undefined","interaction","__count","id","prevInteractions","interactions","add","subscriber","returnValue","onInteractionTraced","onWorkStarted","onWorkStopped","onInteractionScheduledWorkCompleted","subscribers","unstable_subscribe","size","onWorkCanceled","onWorkScheduled","unstable_unsubscribe","delete","didCatchError","caughtError","forEach","error","unstable_clear","unstable_getCurrent","unstable_wrap","wrappedInteractions","hasRun","wrapped","apply","cancel"],"mappings":"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","file":"scheduler-tracing.development.js","sourcesContent":["/** @license React v0.13.6\n * scheduler-tracing.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:\n\n\n// In some cases, StrictMode should also double-render lifecycles.\n// This can be confusing for tests though,\n// And it can be bad for performance in production.\n// This feature flag can be used to control the behavior:\n\n\n// To preserve the \"Pause on caught exceptions\" behavior of the debugger, we\n// replay the begin phase of a failed component inside invokeGuardedCallback.\n\n\n// Warn about deprecated, async-unsafe lifecycles; relates to RFC #6:\n\n\n// Gather advanced timing metrics for Profiler subtrees.\n\n\n// Trace which interactions trigger each commit.\nvar enableSchedulerTracing = true;\n\n// Only used in www builds.\n // TODO: true? Here it might just be false.\n\n// Only used in www builds.\n\n\n// Only used in www builds.\n\n\n// React Fire: prevent the value and checked attributes from syncing\n// with their related DOM properties\n\n\n// These APIs will no longer be \"unstable\" in the upcoming 16.7 release,\n// Control this behavior with a flag to support 16.6 minor releases in the meanwhile.\n\nvar DEFAULT_THREAD_ID = 0;\n\n// Counters used to generate unique IDs.\nvar interactionIDCounter = 0;\nvar threadIDCounter = 0;\n\n// Set of currently traced interactions.\n// Interactions \"stack\"â€“\n// Meaning that newly traced interactions are appended to the previously active set.\n// When an interaction goes out of scope, the previous set (if any) is restored.\nexports.__interactionsRef = null;\n\n// Listener(s) to notify when interactions begin and end.\nexports.__subscriberRef = null;\n\nif (enableSchedulerTracing) {\n  exports.__interactionsRef = {\n    current: new Set()\n  };\n  exports.__subscriberRef = {\n    current: null\n  };\n}\n\nfunction unstable_clear(callback) {\n  if (!enableSchedulerTracing) {\n    return callback();\n  }\n\n  var prevInteractions = exports.__interactionsRef.current;\n  exports.__interactionsRef.current = new Set();\n\n  try {\n    return callback();\n  } finally {\n    exports.__interactionsRef.current = prevInteractions;\n  }\n}\n\nfunction unstable_getCurrent() {\n  if (!enableSchedulerTracing) {\n    return null;\n  } else {\n    return exports.__interactionsRef.current;\n  }\n}\n\nfunction unstable_getThreadID() {\n  return ++threadIDCounter;\n}\n\nfunction unstable_trace(name, timestamp, callback) {\n  var threadID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_THREAD_ID;\n\n  if (!enableSchedulerTracing) {\n    return callback();\n  }\n\n  var interaction = {\n    __count: 1,\n    id: interactionIDCounter++,\n    name: name,\n    timestamp: timestamp\n  };\n\n  var prevInteractions = exports.__interactionsRef.current;\n\n  // Traced interactions should stack/accumulate.\n  // To do that, clone the current interactions.\n  // The previous set will be restored upon completion.\n  var interactions = new Set(prevInteractions);\n  interactions.add(interaction);\n  exports.__interactionsRef.current = interactions;\n\n  var subscriber = exports.__subscriberRef.current;\n  var returnValue = void 0;\n\n  try {\n    if (subscriber !== null) {\n      subscriber.onInteractionTraced(interaction);\n    }\n  } finally {\n    try {\n      if (subscriber !== null) {\n        subscriber.onWorkStarted(interactions, threadID);\n      }\n    } finally {\n      try {\n        returnValue = callback();\n      } finally {\n        exports.__interactionsRef.current = prevInteractions;\n\n        try {\n          if (subscriber !== null) {\n            subscriber.onWorkStopped(interactions, threadID);\n          }\n        } finally {\n          interaction.__count--;\n\n          // If no async work was scheduled for this interaction,\n          // Notify subscribers that it's completed.\n          if (subscriber !== null && interaction.__count === 0) {\n            subscriber.onInteractionScheduledWorkCompleted(interaction);\n          }\n        }\n      }\n    }\n  }\n\n  return returnValue;\n}\n\nfunction unstable_wrap(callback) {\n  var threadID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_THREAD_ID;\n\n  if (!enableSchedulerTracing) {\n    return callback;\n  }\n\n  var wrappedInteractions = exports.__interactionsRef.current;\n\n  var subscriber = exports.__subscriberRef.current;\n  if (subscriber !== null) {\n    subscriber.onWorkScheduled(wrappedInteractions, threadID);\n  }\n\n  // Update the pending async work count for the current interactions.\n  // Update after calling subscribers in case of error.\n  wrappedInteractions.forEach(function (interaction) {\n    interaction.__count++;\n  });\n\n  var hasRun = false;\n\n  function wrapped() {\n    var prevInteractions = exports.__interactionsRef.current;\n    exports.__interactionsRef.current = wrappedInteractions;\n\n    subscriber = exports.__subscriberRef.current;\n\n    try {\n      var returnValue = void 0;\n\n      try {\n        if (subscriber !== null) {\n          subscriber.onWorkStarted(wrappedInteractions, threadID);\n        }\n      } finally {\n        try {\n          returnValue = callback.apply(undefined, arguments);\n        } finally {\n          exports.__interactionsRef.current = prevInteractions;\n\n          if (subscriber !== null) {\n            subscriber.onWorkStopped(wrappedInteractions, threadID);\n          }\n        }\n      }\n\n      return returnValue;\n    } finally {\n      if (!hasRun) {\n        // We only expect a wrapped function to be executed once,\n        // But in the event that it's executed more than onceâ€“\n        // Only decrement the outstanding interaction counts once.\n        hasRun = true;\n\n        // Update pending async counts for all wrapped interactions.\n        // If this was the last scheduled async work for any of them,\n        // Mark them as completed.\n        wrappedInteractions.forEach(function (interaction) {\n          interaction.__count--;\n\n          if (subscriber !== null && interaction.__count === 0) {\n            subscriber.onInteractionScheduledWorkCompleted(interaction);\n          }\n        });\n      }\n    }\n  }\n\n  wrapped.cancel = function cancel() {\n    subscriber = exports.__subscriberRef.current;\n\n    try {\n      if (subscriber !== null) {\n        subscriber.onWorkCanceled(wrappedInteractions, threadID);\n      }\n    } finally {\n      // Update pending async counts for all wrapped interactions.\n      // If this was the last scheduled async work for any of them,\n      // Mark them as completed.\n      wrappedInteractions.forEach(function (interaction) {\n        interaction.__count--;\n\n        if (subscriber && interaction.__count === 0) {\n          subscriber.onInteractionScheduledWorkCompleted(interaction);\n        }\n      });\n    }\n  };\n\n  return wrapped;\n}\n\nvar subscribers = null;\nif (enableSchedulerTracing) {\n  subscribers = new Set();\n}\n\nfunction unstable_subscribe(subscriber) {\n  if (enableSchedulerTracing) {\n    subscribers.add(subscriber);\n\n    if (subscribers.size === 1) {\n      exports.__subscriberRef.current = {\n        onInteractionScheduledWorkCompleted: onInteractionScheduledWorkCompleted,\n        onInteractionTraced: onInteractionTraced,\n        onWorkCanceled: onWorkCanceled,\n        onWorkScheduled: onWorkScheduled,\n        onWorkStarted: onWorkStarted,\n        onWorkStopped: onWorkStopped\n      };\n    }\n  }\n}\n\nfunction unstable_unsubscribe(subscriber) {\n  if (enableSchedulerTracing) {\n    subscribers.delete(subscriber);\n\n    if (subscribers.size === 0) {\n      exports.__subscriberRef.current = null;\n    }\n  }\n}\n\nfunction onInteractionTraced(interaction) {\n  var didCatchError = false;\n  var caughtError = null;\n\n  subscribers.forEach(function (subscriber) {\n    try {\n      subscriber.onInteractionTraced(interaction);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onInteractionScheduledWorkCompleted(interaction) {\n  var didCatchError = false;\n  var caughtError = null;\n\n  subscribers.forEach(function (subscriber) {\n    try {\n      subscriber.onInteractionScheduledWorkCompleted(interaction);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onWorkScheduled(interactions, threadID) {\n  var didCatchError = false;\n  var caughtError = null;\n\n  subscribers.forEach(function (subscriber) {\n    try {\n      subscriber.onWorkScheduled(interactions, threadID);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onWorkStarted(interactions, threadID) {\n  var didCatchError = false;\n  var caughtError = null;\n\n  subscribers.forEach(function (subscriber) {\n    try {\n      subscriber.onWorkStarted(interactions, threadID);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onWorkStopped(interactions, threadID) {\n  var didCatchError = false;\n  var caughtError = null;\n\n  subscribers.forEach(function (subscriber) {\n    try {\n      subscriber.onWorkStopped(interactions, threadID);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onWorkCanceled(interactions, threadID) {\n  var didCatchError = false;\n  var caughtError = null;\n\n  subscribers.forEach(function (subscriber) {\n    try {\n      subscriber.onWorkCanceled(interactions, threadID);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nexports.unstable_clear = unstable_clear;\nexports.unstable_getCurrent = unstable_getCurrent;\nexports.unstable_getThreadID = unstable_getThreadID;\nexports.unstable_trace = unstable_trace;\nexports.unstable_wrap = unstable_wrap;\nexports.unstable_subscribe = unstable_subscribe;\nexports.unstable_unsubscribe = unstable_unsubscribe;\n  })();\n}\n"]}