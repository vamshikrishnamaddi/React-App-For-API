{"version":3,"sources":["scheduler.development.js"],"names":["Object","defineProperty","exports","value","enableSchedulerDebugging","ImmediatePriority","UserBlockingPriority","NormalPriority","LowPriority","IdlePriority","firstCallbackNode","currentDidTimeout","isSchedulerPaused","currentPriorityLevel","currentEventStartTime","currentExpirationTime","isExecutingCallback","isHostCallbackScheduled","hasNativePerformanceNow","performance","now","ensureHostCallbackIsScheduled","expirationTime","cancelHostCallback","requestHostCallback","flushWork","flushFirstCallback","flushedNode","next","lastCallbackNode","previous","callback","priorityLevel","previousPriorityLevel","previousExpirationTime","continuationCallback","continuationNode","nextAfterContinuation","node","flushImmediateWork","didTimeout","previousDidTimeout","currentTime","unstable_now","shouldYieldToHost","unstable_runWithPriority","eventHandler","previousEventStartTime","unstable_next","unstable_wrapCallback","parentPriorityLevel","apply","arguments","unstable_scheduleCallback","deprecated_options","startTime","timeout","newNode","unstable_continueExecution","unstable_getFirstCallbackNode","unstable_cancelCallback","callbackNode","unstable_getCurrentPriorityLevel","unstable_shouldYield","localDate","Date","localSetTimeout","setTimeout","undefined","localClearTimeout","clearTimeout","localRequestAnimationFrame","requestAnimationFrame","localCancelAnimationFrame","cancelAnimationFrame","rAFID","rAFTimeoutID","requestAnimationFrameWithTimeout","timestamp","Performance","globalValue","window","global","_schedMock","globalImpl","MessageChannel","_callback","_flushCallback","cb","ms","console","error","scheduledHostCallback","isMessageEventScheduled","timeoutTime","isAnimationFrameScheduled","isFlushingHostCallback","frameDeadline","previousFrameTime","activeFrameTime","channel","port","port2","port1","onmessage","event","prevScheduledCallback","prevTimeoutTime","animationTick","rafTime","nextFrameTime","postMessage","absoluteTimeout","unstable_ImmediatePriority","unstable_UserBlockingPriority","unstable_NormalPriority","unstable_IdlePriority","unstable_LowPriority","unstable_pauseExecution"],"mappings":"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","file":"scheduler.development.js","sourcesContent":["/** @license React v0.13.6\n * scheduler.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar enableSchedulerDebugging = false;\n\n/* eslint-disable no-var */\n\n// TODO: Use symbols?\nvar ImmediatePriority = 1;\nvar UserBlockingPriority = 2;\nvar NormalPriority = 3;\nvar LowPriority = 4;\nvar IdlePriority = 5;\n\n// Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n// Math.pow(2, 30) - 1\n// 0b111111111111111111111111111111\nvar maxSigned31BitInt = 1073741823;\n\n// Times out immediately\nvar IMMEDIATE_PRIORITY_TIMEOUT = -1;\n// Eventually times out\nvar USER_BLOCKING_PRIORITY = 250;\nvar NORMAL_PRIORITY_TIMEOUT = 5000;\nvar LOW_PRIORITY_TIMEOUT = 10000;\n// Never times out\nvar IDLE_PRIORITY = maxSigned31BitInt;\n\n// Callbacks are stored as a circular, doubly linked list.\nvar firstCallbackNode = null;\n\nvar currentDidTimeout = false;\n// Pausing the scheduler is useful for debugging.\nvar isSchedulerPaused = false;\n\nvar currentPriorityLevel = NormalPriority;\nvar currentEventStartTime = -1;\nvar currentExpirationTime = -1;\n\n// This is set when a callback is being executed, to prevent re-entrancy.\nvar isExecutingCallback = false;\n\nvar isHostCallbackScheduled = false;\n\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\n\nfunction ensureHostCallbackIsScheduled() {\n  if (isExecutingCallback) {\n    // Don't schedule work yet; wait until the next time we yield.\n    return;\n  }\n  // Schedule the host callback using the earliest expiration in the list.\n  var expirationTime = firstCallbackNode.expirationTime;\n  if (!isHostCallbackScheduled) {\n    isHostCallbackScheduled = true;\n  } else {\n    // Cancel the existing host callback.\n    cancelHostCallback();\n  }\n  requestHostCallback(flushWork, expirationTime);\n}\n\nfunction flushFirstCallback() {\n  var flushedNode = firstCallbackNode;\n\n  // Remove the node from the list before calling the callback. That way the\n  // list is in a consistent state even if the callback throws.\n  var next = firstCallbackNode.next;\n  if (firstCallbackNode === next) {\n    // This is the last callback in the list.\n    firstCallbackNode = null;\n    next = null;\n  } else {\n    var lastCallbackNode = firstCallbackNode.previous;\n    firstCallbackNode = lastCallbackNode.next = next;\n    next.previous = lastCallbackNode;\n  }\n\n  flushedNode.next = flushedNode.previous = null;\n\n  // Now it's safe to call the callback.\n  var callback = flushedNode.callback;\n  var expirationTime = flushedNode.expirationTime;\n  var priorityLevel = flushedNode.priorityLevel;\n  var previousPriorityLevel = currentPriorityLevel;\n  var previousExpirationTime = currentExpirationTime;\n  currentPriorityLevel = priorityLevel;\n  currentExpirationTime = expirationTime;\n  var continuationCallback;\n  try {\n    continuationCallback = callback();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n    currentExpirationTime = previousExpirationTime;\n  }\n\n  // A callback may return a continuation. The continuation should be scheduled\n  // with the same priority and expiration as the just-finished callback.\n  if (typeof continuationCallback === 'function') {\n    var continuationNode = {\n      callback: continuationCallback,\n      priorityLevel: priorityLevel,\n      expirationTime: expirationTime,\n      next: null,\n      previous: null\n    };\n\n    // Insert the new callback into the list, sorted by its expiration. This is\n    // almost the same as the code in `scheduleCallback`, except the callback\n    // is inserted into the list *before* callbacks of equal expiration instead\n    // of after.\n    if (firstCallbackNode === null) {\n      // This is the first callback in the list.\n      firstCallbackNode = continuationNode.next = continuationNode.previous = continuationNode;\n    } else {\n      var nextAfterContinuation = null;\n      var node = firstCallbackNode;\n      do {\n        if (node.expirationTime >= expirationTime) {\n          // This callback expires at or after the continuation. We will insert\n          // the continuation *before* this callback.\n          nextAfterContinuation = node;\n          break;\n        }\n        node = node.next;\n      } while (node !== firstCallbackNode);\n\n      if (nextAfterContinuation === null) {\n        // No equal or lower priority callback was found, which means the new\n        // callback is the lowest priority callback in the list.\n        nextAfterContinuation = firstCallbackNode;\n      } else if (nextAfterContinuation === firstCallbackNode) {\n        // The new callback is the highest priority callback in the list.\n        firstCallbackNode = continuationNode;\n        ensureHostCallbackIsScheduled();\n      }\n\n      var previous = nextAfterContinuation.previous;\n      previous.next = nextAfterContinuation.previous = continuationNode;\n      continuationNode.next = nextAfterContinuation;\n      continuationNode.previous = previous;\n    }\n  }\n}\n\nfunction flushImmediateWork() {\n  if (\n  // Confirm we've exited the outer most event handler\n  currentEventStartTime === -1 && firstCallbackNode !== null && firstCallbackNode.priorityLevel === ImmediatePriority) {\n    isExecutingCallback = true;\n    try {\n      do {\n        flushFirstCallback();\n      } while (\n      // Keep flushing until there are no more immediate callbacks\n      firstCallbackNode !== null && firstCallbackNode.priorityLevel === ImmediatePriority);\n    } finally {\n      isExecutingCallback = false;\n      if (firstCallbackNode !== null) {\n        // There's still work remaining. Request another callback.\n        ensureHostCallbackIsScheduled();\n      } else {\n        isHostCallbackScheduled = false;\n      }\n    }\n  }\n}\n\nfunction flushWork(didTimeout) {\n  // Exit right away if we're currently paused\n\n  if (enableSchedulerDebugging && isSchedulerPaused) {\n    return;\n  }\n\n  isExecutingCallback = true;\n  var previousDidTimeout = currentDidTimeout;\n  currentDidTimeout = didTimeout;\n  try {\n    if (didTimeout) {\n      // Flush all the expired callbacks without yielding.\n      while (firstCallbackNode !== null && !(enableSchedulerDebugging && isSchedulerPaused)) {\n        // TODO Wrap in feature flag\n        // Read the current time. Flush all the callbacks that expire at or\n        // earlier than that time. Then read the current time again and repeat.\n        // This optimizes for as few performance.now calls as possible.\n        var currentTime = exports.unstable_now();\n        if (firstCallbackNode.expirationTime <= currentTime) {\n          do {\n            flushFirstCallback();\n          } while (firstCallbackNode !== null && firstCallbackNode.expirationTime <= currentTime && !(enableSchedulerDebugging && isSchedulerPaused));\n          continue;\n        }\n        break;\n      }\n    } else {\n      // Keep flushing callbacks until we run out of time in the frame.\n      if (firstCallbackNode !== null) {\n        do {\n          if (enableSchedulerDebugging && isSchedulerPaused) {\n            break;\n          }\n          flushFirstCallback();\n        } while (firstCallbackNode !== null && !shouldYieldToHost());\n      }\n    }\n  } finally {\n    isExecutingCallback = false;\n    currentDidTimeout = previousDidTimeout;\n    if (firstCallbackNode !== null) {\n      // There's still work remaining. Request another callback.\n      ensureHostCallbackIsScheduled();\n    } else {\n      isHostCallbackScheduled = false;\n    }\n    // Before exiting, flush all the immediate work that was scheduled.\n    flushImmediateWork();\n  }\n}\n\nfunction unstable_runWithPriority(priorityLevel, eventHandler) {\n  switch (priorityLevel) {\n    case ImmediatePriority:\n    case UserBlockingPriority:\n    case NormalPriority:\n    case LowPriority:\n    case IdlePriority:\n      break;\n    default:\n      priorityLevel = NormalPriority;\n  }\n\n  var previousPriorityLevel = currentPriorityLevel;\n  var previousEventStartTime = currentEventStartTime;\n  currentPriorityLevel = priorityLevel;\n  currentEventStartTime = exports.unstable_now();\n\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n    currentEventStartTime = previousEventStartTime;\n\n    // Before exiting, flush all the immediate work that was scheduled.\n    flushImmediateWork();\n  }\n}\n\nfunction unstable_next(eventHandler) {\n  var priorityLevel = void 0;\n  switch (currentPriorityLevel) {\n    case ImmediatePriority:\n    case UserBlockingPriority:\n    case NormalPriority:\n      // Shift down to normal priority\n      priorityLevel = NormalPriority;\n      break;\n    default:\n      // Anything lower than normal priority should remain at the current level.\n      priorityLevel = currentPriorityLevel;\n      break;\n  }\n\n  var previousPriorityLevel = currentPriorityLevel;\n  var previousEventStartTime = currentEventStartTime;\n  currentPriorityLevel = priorityLevel;\n  currentEventStartTime = exports.unstable_now();\n\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n    currentEventStartTime = previousEventStartTime;\n\n    // Before exiting, flush all the immediate work that was scheduled.\n    flushImmediateWork();\n  }\n}\n\nfunction unstable_wrapCallback(callback) {\n  var parentPriorityLevel = currentPriorityLevel;\n  return function () {\n    // This is a fork of runWithPriority, inlined for performance.\n    var previousPriorityLevel = currentPriorityLevel;\n    var previousEventStartTime = currentEventStartTime;\n    currentPriorityLevel = parentPriorityLevel;\n    currentEventStartTime = exports.unstable_now();\n\n    try {\n      return callback.apply(this, arguments);\n    } finally {\n      currentPriorityLevel = previousPriorityLevel;\n      currentEventStartTime = previousEventStartTime;\n      flushImmediateWork();\n    }\n  };\n}\n\nfunction unstable_scheduleCallback(callback, deprecated_options) {\n  var startTime = currentEventStartTime !== -1 ? currentEventStartTime : exports.unstable_now();\n\n  var expirationTime;\n  if (typeof deprecated_options === 'object' && deprecated_options !== null && typeof deprecated_options.timeout === 'number') {\n    // FIXME: Remove this branch once we lift expiration times out of React.\n    expirationTime = startTime + deprecated_options.timeout;\n  } else {\n    switch (currentPriorityLevel) {\n      case ImmediatePriority:\n        expirationTime = startTime + IMMEDIATE_PRIORITY_TIMEOUT;\n        break;\n      case UserBlockingPriority:\n        expirationTime = startTime + USER_BLOCKING_PRIORITY;\n        break;\n      case IdlePriority:\n        expirationTime = startTime + IDLE_PRIORITY;\n        break;\n      case LowPriority:\n        expirationTime = startTime + LOW_PRIORITY_TIMEOUT;\n        break;\n      case NormalPriority:\n      default:\n        expirationTime = startTime + NORMAL_PRIORITY_TIMEOUT;\n    }\n  }\n\n  var newNode = {\n    callback: callback,\n    priorityLevel: currentPriorityLevel,\n    expirationTime: expirationTime,\n    next: null,\n    previous: null\n  };\n\n  // Insert the new callback into the list, ordered first by expiration, then\n  // by insertion. So the new callback is inserted any other callback with\n  // equal expiration.\n  if (firstCallbackNode === null) {\n    // This is the first callback in the list.\n    firstCallbackNode = newNode.next = newNode.previous = newNode;\n    ensureHostCallbackIsScheduled();\n  } else {\n    var next = null;\n    var node = firstCallbackNode;\n    do {\n      if (node.expirationTime > expirationTime) {\n        // The new callback expires before this one.\n        next = node;\n        break;\n      }\n      node = node.next;\n    } while (node !== firstCallbackNode);\n\n    if (next === null) {\n      // No callback with a later expiration was found, which means the new\n      // callback has the latest expiration in the list.\n      next = firstCallbackNode;\n    } else if (next === firstCallbackNode) {\n      // The new callback has the earliest expiration in the entire list.\n      firstCallbackNode = newNode;\n      ensureHostCallbackIsScheduled();\n    }\n\n    var previous = next.previous;\n    previous.next = next.previous = newNode;\n    newNode.next = next;\n    newNode.previous = previous;\n  }\n\n  return newNode;\n}\n\nfunction unstable_pauseExecution() {\n  isSchedulerPaused = true;\n}\n\nfunction unstable_continueExecution() {\n  isSchedulerPaused = false;\n  if (firstCallbackNode !== null) {\n    ensureHostCallbackIsScheduled();\n  }\n}\n\nfunction unstable_getFirstCallbackNode() {\n  return firstCallbackNode;\n}\n\nfunction unstable_cancelCallback(callbackNode) {\n  var next = callbackNode.next;\n  if (next === null) {\n    // Already cancelled.\n    return;\n  }\n\n  if (next === callbackNode) {\n    // This is the only scheduled callback. Clear the list.\n    firstCallbackNode = null;\n  } else {\n    // Remove the callback from its position in the list.\n    if (callbackNode === firstCallbackNode) {\n      firstCallbackNode = next;\n    }\n    var previous = callbackNode.previous;\n    previous.next = next;\n    next.previous = previous;\n  }\n\n  callbackNode.next = callbackNode.previous = null;\n}\n\nfunction unstable_getCurrentPriorityLevel() {\n  return currentPriorityLevel;\n}\n\nfunction unstable_shouldYield() {\n  return !currentDidTimeout && (firstCallbackNode !== null && firstCallbackNode.expirationTime < currentExpirationTime || shouldYieldToHost());\n}\n\n// The remaining code is essentially a polyfill for requestIdleCallback. It\n// works by scheduling a requestAnimationFrame, storing the time for the start\n// of the frame, then scheduling a postMessage which gets scheduled after paint.\n// Within the postMessage handler do as much work as possible until time + frame\n// rate. By separating the idle call into a separate event tick we ensure that\n// layout, paint and other browser work is counted against the available time.\n// The frame rate is dynamically adjusted.\n\n// We capture a local reference to any global, in case it gets polyfilled after\n// this module is initially evaluated. We want to be using a\n// consistent implementation.\nvar localDate = Date;\n\n// This initialization code may run even on server environments if a component\n// just imports ReactDOM (e.g. for findDOMNode). Some environments might not\n// have setTimeout or clearTimeout. However, we always expect them to be defined\n// on the client. https://github.com/facebook/react/pull/13088\nvar localSetTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;\nvar localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;\n\n// We don't expect either of these to necessarily be defined, but we will error\n// later if they are missing on the client.\nvar localRequestAnimationFrame = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : undefined;\nvar localCancelAnimationFrame = typeof cancelAnimationFrame === 'function' ? cancelAnimationFrame : undefined;\n\n// requestAnimationFrame does not run when the tab is in the background. If\n// we're backgrounded we prefer for that work to happen so that the page\n// continues to load in the background. So we also schedule a 'setTimeout' as\n// a fallback.\n// TODO: Need a better heuristic for backgrounded work.\nvar ANIMATION_FRAME_TIMEOUT = 100;\nvar rAFID;\nvar rAFTimeoutID;\nvar requestAnimationFrameWithTimeout = function (callback) {\n  // schedule rAF and also a setTimeout\n  rAFID = localRequestAnimationFrame(function (timestamp) {\n    // cancel the setTimeout\n    localClearTimeout(rAFTimeoutID);\n    callback(timestamp);\n  });\n  rAFTimeoutID = localSetTimeout(function () {\n    // cancel the requestAnimationFrame\n    localCancelAnimationFrame(rAFID);\n    callback(exports.unstable_now());\n  }, ANIMATION_FRAME_TIMEOUT);\n};\n\nif (hasNativePerformanceNow) {\n  var Performance = performance;\n  exports.unstable_now = function () {\n    return Performance.now();\n  };\n} else {\n  exports.unstable_now = function () {\n    return localDate.now();\n  };\n}\n\nvar requestHostCallback;\nvar cancelHostCallback;\nvar shouldYieldToHost;\n\nvar globalValue = null;\nif (typeof window !== 'undefined') {\n  globalValue = window;\n} else if (typeof global !== 'undefined') {\n  globalValue = global;\n}\n\nif (globalValue && globalValue._schedMock) {\n  // Dynamic injection, only for testing purposes.\n  var globalImpl = globalValue._schedMock;\n  requestHostCallback = globalImpl[0];\n  cancelHostCallback = globalImpl[1];\n  shouldYieldToHost = globalImpl[2];\n  exports.unstable_now = globalImpl[3];\n} else if (\n// If Scheduler runs in a non-DOM environment, it falls back to a naive\n// implementation using setTimeout.\ntypeof window === 'undefined' ||\n// Check if MessageChannel is supported, too.\ntypeof MessageChannel !== 'function') {\n  // If this accidentally gets imported in a non-browser environment, e.g. JavaScriptCore,\n  // fallback to a naive implementation.\n  var _callback = null;\n  var _flushCallback = function (didTimeout) {\n    if (_callback !== null) {\n      try {\n        _callback(didTimeout);\n      } finally {\n        _callback = null;\n      }\n    }\n  };\n  requestHostCallback = function (cb, ms) {\n    if (_callback !== null) {\n      // Protect against re-entrancy.\n      setTimeout(requestHostCallback, 0, cb);\n    } else {\n      _callback = cb;\n      setTimeout(_flushCallback, 0, false);\n    }\n  };\n  cancelHostCallback = function () {\n    _callback = null;\n  };\n  shouldYieldToHost = function () {\n    return false;\n  };\n} else {\n  if (typeof console !== 'undefined') {\n    // TODO: Remove fb.me link\n    if (typeof localRequestAnimationFrame !== 'function') {\n      console.error(\"This browser doesn't support requestAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n    }\n    if (typeof localCancelAnimationFrame !== 'function') {\n      console.error(\"This browser doesn't support cancelAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n    }\n  }\n\n  var scheduledHostCallback = null;\n  var isMessageEventScheduled = false;\n  var timeoutTime = -1;\n\n  var isAnimationFrameScheduled = false;\n\n  var isFlushingHostCallback = false;\n\n  var frameDeadline = 0;\n  // We start out assuming that we run at 30fps but then the heuristic tracking\n  // will adjust this value to a faster fps if we get more frequent animation\n  // frames.\n  var previousFrameTime = 33;\n  var activeFrameTime = 33;\n\n  shouldYieldToHost = function () {\n    return frameDeadline <= exports.unstable_now();\n  };\n\n  // We use the postMessage trick to defer idle work until after the repaint.\n  var channel = new MessageChannel();\n  var port = channel.port2;\n  channel.port1.onmessage = function (event) {\n    isMessageEventScheduled = false;\n\n    var prevScheduledCallback = scheduledHostCallback;\n    var prevTimeoutTime = timeoutTime;\n    scheduledHostCallback = null;\n    timeoutTime = -1;\n\n    var currentTime = exports.unstable_now();\n\n    var didTimeout = false;\n    if (frameDeadline - currentTime <= 0) {\n      // There's no time left in this idle period. Check if the callback has\n      // a timeout and whether it's been exceeded.\n      if (prevTimeoutTime !== -1 && prevTimeoutTime <= currentTime) {\n        // Exceeded the timeout. Invoke the callback even though there's no\n        // time left.\n        didTimeout = true;\n      } else {\n        // No timeout.\n        if (!isAnimationFrameScheduled) {\n          // Schedule another animation callback so we retry later.\n          isAnimationFrameScheduled = true;\n          requestAnimationFrameWithTimeout(animationTick);\n        }\n        // Exit without invoking the callback.\n        scheduledHostCallback = prevScheduledCallback;\n        timeoutTime = prevTimeoutTime;\n        return;\n      }\n    }\n\n    if (prevScheduledCallback !== null) {\n      isFlushingHostCallback = true;\n      try {\n        prevScheduledCallback(didTimeout);\n      } finally {\n        isFlushingHostCallback = false;\n      }\n    }\n  };\n\n  var animationTick = function (rafTime) {\n    if (scheduledHostCallback !== null) {\n      // Eagerly schedule the next animation callback at the beginning of the\n      // frame. If the scheduler queue is not empty at the end of the frame, it\n      // will continue flushing inside that callback. If the queue *is* empty,\n      // then it will exit immediately. Posting the callback at the start of the\n      // frame ensures it's fired within the earliest possible frame. If we\n      // waited until the end of the frame to post the callback, we risk the\n      // browser skipping a frame and not firing the callback until the frame\n      // after that.\n      requestAnimationFrameWithTimeout(animationTick);\n    } else {\n      // No pending work. Exit.\n      isAnimationFrameScheduled = false;\n      return;\n    }\n\n    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n    if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\n      if (nextFrameTime < 8) {\n        // Defensive coding. We don't support higher frame rates than 120hz.\n        // If the calculated frame time gets lower than 8, it is probably a bug.\n        nextFrameTime = 8;\n      }\n      // If one frame goes long, then the next one can be short to catch up.\n      // If two frames are short in a row, then that's an indication that we\n      // actually have a higher frame rate than what we're currently optimizing.\n      // We adjust our heuristic dynamically accordingly. For example, if we're\n      // running on 120hz display or 90hz VR display.\n      // Take the max of the two in case one of them was an anomaly due to\n      // missed frame deadlines.\n      activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\n    } else {\n      previousFrameTime = nextFrameTime;\n    }\n    frameDeadline = rafTime + activeFrameTime;\n    if (!isMessageEventScheduled) {\n      isMessageEventScheduled = true;\n      port.postMessage(undefined);\n    }\n  };\n\n  requestHostCallback = function (callback, absoluteTimeout) {\n    scheduledHostCallback = callback;\n    timeoutTime = absoluteTimeout;\n    if (isFlushingHostCallback || absoluteTimeout < 0) {\n      // Don't wait for the next frame. Continue working ASAP, in a new event.\n      port.postMessage(undefined);\n    } else if (!isAnimationFrameScheduled) {\n      // If rAF didn't already schedule one, we need to schedule a frame.\n      // TODO: If this rAF doesn't materialize because the browser throttles, we\n      // might want to still have setTimeout trigger rIC as a backup to ensure\n      // that we keep performing work.\n      isAnimationFrameScheduled = true;\n      requestAnimationFrameWithTimeout(animationTick);\n    }\n  };\n\n  cancelHostCallback = function () {\n    scheduledHostCallback = null;\n    isMessageEventScheduled = false;\n    timeoutTime = -1;\n  };\n}\n\nexports.unstable_ImmediatePriority = ImmediatePriority;\nexports.unstable_UserBlockingPriority = UserBlockingPriority;\nexports.unstable_NormalPriority = NormalPriority;\nexports.unstable_IdlePriority = IdlePriority;\nexports.unstable_LowPriority = LowPriority;\nexports.unstable_runWithPriority = unstable_runWithPriority;\nexports.unstable_next = unstable_next;\nexports.unstable_scheduleCallback = unstable_scheduleCallback;\nexports.unstable_cancelCallback = unstable_cancelCallback;\nexports.unstable_wrapCallback = unstable_wrapCallback;\nexports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\nexports.unstable_shouldYield = unstable_shouldYield;\nexports.unstable_continueExecution = unstable_continueExecution;\nexports.unstable_pauseExecution = unstable_pauseExecution;\nexports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\n  })();\n}\n"]}