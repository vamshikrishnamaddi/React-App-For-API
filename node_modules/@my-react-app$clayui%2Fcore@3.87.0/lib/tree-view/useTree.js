"use strict";

Liferay.Loader.define("@my-react-app$clayui/core@3.87.0/lib/tree-view/useTree", ['module', 'exports', 'require', '@my-react-app$clayui/shared', 'my-react-app$react', './useLayout', './useMultipleSelection'], function (module, exports, require) {
  var define = undefined;
  var global = window;
  {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createImmutableTree = createImmutableTree;
    exports.useTree = useTree;

    var _shared = require("@my-react-app$clayui/shared");

    var _react = require("my-react-app$react");

    var _useLayout = require("./useLayout");

    var _useMultipleSelection = require("./useMultipleSelection");

    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);enumerableOnly && (symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }return keys;
    }

    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }return target;
    }

    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }return obj;
    }

    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }

    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
    }

    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) return _arrayLikeToArray(arr);
    }

    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }

    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }

    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }return arr2;
    }

    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];if (_i == null) return;var _arr = [];var _n = true;var _d = false;var _s, _e;try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;_e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }return _arr;
    }

    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }

    function useTree(props) {
      var _props$defaultItems;

      var _useInternalState = (0, _shared.useInternalState)({
        defaultName: 'defaultItems',
        defaultValue: (_props$defaultItems = props.defaultItems) !== null && _props$defaultItems !== void 0 ? _props$defaultItems : [],
        handleName: 'onItemsChange',
        name: 'items',
        onChange: props.onItemsChange,
        value: props.items
      }),
          _useInternalState2 = _slicedToArray(_useInternalState, 2),
          items = _useInternalState2[0],
          setItems = _useInternalState2[1];

      var cursors = (0, _react.useRef)(new Map());
      var layout = (0, _useLayout.useLayout)();
      var selection = (0, _useMultipleSelection.useMultipleSelection)({
        defaultSelectedKeys: props.defaultSelectedKeys,
        indeterminate: props.indeterminate,
        items: items,
        layoutKeys: layout.layoutKeys,
        nestedKey: props.nestedKey,
        onSelectionChange: props.onSelectionChange,
        selectedKeys: props.selectedKeys,
        selectionMode: props.selectionMode
      });

      var _useInternalState3 = (0, _shared.useInternalState)({
        defaultName: 'defaultExpandedKeys',
        defaultValue: function defaultValue() {
          var defaultExpandedKeys = props.defaultExpandedKeys,
              indeterminate = props.indeterminate,
              nestedKey = props.nestedKey,
              selectionHydrationMode = props.selectionHydrationMode,
              selectionMode = props.selectionMode;

          if (selectionHydrationMode === 'hydrate-first' && items && selection.selectedKeys.size) {
            var expand = expandSelectedItems(items, nestedKey, // TODO try to make it configurable or be able to infer the name of
            // the property from the key passed in the React rendering.
            'id', selection.selectedKeys);

            if (selectionMode === 'multiple-recursive' && indeterminate) {
              selection.replaceIndeterminateKeys(expand.filter(function (key) {
                return !selection.selectedKeys.has(key);
              }));
            }

            return new Set(defaultExpandedKeys ? Array.from(defaultExpandedKeys).concat(expand) : expand);
          }

          return defaultExpandedKeys !== null && defaultExpandedKeys !== void 0 ? defaultExpandedKeys : new Set();
        },
        handleName: 'onExpandedChange',
        name: 'expandedKeys',
        onChange: props.onExpandedChange,
        value: props.expandedKeys
      }),
          _useInternalState4 = _slicedToArray(_useInternalState3, 2),
          expandedKeys = _useInternalState4[0],
          setExpandedKeys = _useInternalState4[1];

      (0, _react.useEffect)(function () {
        var defaultExpandedKeys = props.defaultExpandedKeys,
            indeterminate = props.indeterminate,
            nestedKey = props.nestedKey,
            selectionHydrationMode = props.selectionHydrationMode,
            selectionMode = props.selectionMode;

        if (selectionHydrationMode === 'render-first' && items && selection.selectedKeys.size) {
          var expand = expandSelectedItems(items, nestedKey, // TODO try to make it configurable or be able to infer the name of
          // the property from the key passed in the React rendering.
          'id', selection.selectedKeys);

          if (selectionMode === 'multiple-recursive' && indeterminate) {
            selection.replaceIndeterminateKeys(expand.filter(function (key) {
              return !selection.selectedKeys.has(key);
            }));
          }

          setExpandedKeys(new Set(defaultExpandedKeys ? Array.from(defaultExpandedKeys).concat(expand) : expand));
        }
      }, []);
      var close = (0, _react.useCallback)(function (key) {
        var expanded = new Set(expandedKeys);

        if (expanded.has(key)) {
          expanded.delete(key);
          setExpandedKeys(expanded);
          return true;
        }

        return false;
      }, [expandedKeys]);
      var remove = (0, _react.useCallback)(function (path) {
        var tree = createImmutableTree(items, props.nestedKey);
        tree.produce({
          op: 'remove',
          path: path
        });
        setItems(tree.applyPatches());
      }, [items]);
      var replace = (0, _react.useCallback)(function (path, item) {
        var tree = createImmutableTree(items, props.nestedKey);
        tree.produce({
          item: item,
          op: 'replace',
          path: path
        });
        setItems(tree.applyPatches());
      }, [items]);
      var reorder = (0, _react.useCallback)(function (from, path) {
        var tree = createImmutableTree(items, props.nestedKey);
        tree.produce({
          from: from,
          op: 'move',
          path: path
        });
        setItems(tree.applyPatches());
      }, [items]);
      var insert = (0, _react.useCallback)(function (path, value) {
        var tree = createImmutableTree(items, props.nestedKey);
        tree.produce({
          op: 'add',
          path: path,
          value: value
        });
        setItems(tree.applyPatches());
      }, [items]);
      var toggle = (0, _react.useCallback)(function (key) {
        var expanded = new Set(expandedKeys);

        if (expanded.has(key)) {
          expanded.delete(key);
        } else {
          expanded.add(key);
        }

        setExpandedKeys(expanded);
      }, [expandedKeys]);
      var open = (0, _react.useCallback)(function (key) {
        var expanded = new Set(expandedKeys);

        if (!expanded.has(key)) {
          expanded.add(key);
          setExpandedKeys(expanded);
          return true;
        }

        return false;
      }, [expandedKeys]);
      return {
        close: close,
        cursors: cursors,
        expandedKeys: expandedKeys,
        insert: insert,
        items: items,
        layout: layout,
        open: open,
        remove: remove,
        reorder: reorder,
        replace: replace,
        selection: selection,
        toggle: toggle
      };
    }

    function expandSelectedItems(items, nestedKey, key, selectedKeys) {
      var expand = [];
      var currentSelected = 0;
      visit(nestedKey, key, function (item, path) {
        if (selectedKeys.has(item[key])) {
          currentSelected++;
          expand.push.apply(expand, _toConsumableArray(path));
        }

        return selectedKeys.size === currentSelected;
      }).iter(items);
      return expand;
    }

    function visit(nestedKey, key, callback) {
      var hasContinue = false;

      function iter(items) {
        var currentPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

        if (hasContinue) {
          return;
        }

        var queue = _toConsumableArray(items);

        while (queue.length) {
          var _item2 = queue.shift();

          var _path = currentPath.concat(_item2[key]);

          hasContinue = callback(_item2, _path);

          if (hasContinue) {
            break;
          }

          if (_item2[nestedKey]) {
            iter(_item2[nestedKey], _path);
          }
        }
      }

      return {
        iter: iter
      };
    } // Operation of `move` value to the same document structure, removing from
    // `from` and then adding to `path`.
    // RFC 6902 (JSON Patch) 4.4


    function createImmutableTree(initialTree, nestedKey) {
      var patches = [];

      var immutableTree = _toConsumableArray(initialTree);

      function pointer(tree, index, item) {
        return [].concat(_toConsumableArray(tree.slice(0, index)), [item], _toConsumableArray(tree.slice(index + 1)));
      }

      function nodeByPath(path) {
        var queue = _toConsumableArray(path);

        var rootIndex = queue.shift(); // In an operation of moving an item from the root, it affects the indexes
        // by having to delete first and then add. This is the same behavior
        // as below.

        if (!immutableTree[rootIndex]) {
          rootIndex -= 1;
        }

        var item = _objectSpread({}, immutableTree[rootIndex]);

        var parent = null;
        var index = rootIndex;
        immutableTree = pointer(immutableTree, index, item);

        while (queue.length) {
          index = queue.shift();

          if (Array.isArray(item[nestedKey]) && item[nestedKey].length) {
            // This fixes the index when there is a case to move an item
            // that can be at the same level of the hierarchy inside the
            // other item at the same level, this causes the array size to
            // change and the index value to become stale.
            //
            // 1. Item A
            //   1. Item B
            //   2. Item C
            //   3. Item D
            //
            // Op:
            // from=[1, 1] path=[1, 3]
            //
            // 1. Item A
            //   ~1. Item B~ <- Remove item to move
            //   1. Item C
            //   2. Item D
            if (index > item[nestedKey].length - 1) {
              index -= 1;
            } // The Index may still not exist after it's fixed because the
            // index is to move the item below the last item.


            if (item[nestedKey][index]) {
              parent = item;
              item = _objectSpread({}, item[nestedKey][index]);
              parent[nestedKey] = pointer(parent[nestedKey], index, item);
              continue;
            }
          }

          if (!item[nestedKey]) {
            item[nestedKey] = [];
          }

          parent = item;
        }

        return {
          index: index,
          item: item,
          parent: parent
        };
      }

      function applyPatches() {
        patches.forEach(function (patch) {
          switch (patch.op) {
            case 'add':
              {
                var _path2 = patch.path,
                    _value = patch.value;
                var node = nodeByPath(_path2);

                if (node.parent) {
                  if (node.parent[nestedKey]) {
                    node.parent[nestedKey] = [].concat(_toConsumableArray(node.parent[nestedKey]), _toConsumableArray(_value));
                  } else {
                    node.parent[nestedKey] = _value;
                  }
                }

                break;
              }
            // Applies the operation on the tree, the move is functionally
            // identical to a "remove" operation on the `from` location and
            // immediately followed by the "add" operation at the target
            // location with the value that was removed.

            case 'move':
              {
                var _from = patch.from,
                    _path3 = patch.path;
                var nodeToRemove = nodeByPath(_from);

                if (nodeToRemove.parent) {
                  nodeToRemove.parent[nestedKey] = nodeToRemove.parent[nestedKey].filter(function (_item, index) {
                    return index !== nodeToRemove.index;
                  });
                } else {
                  immutableTree = immutableTree.filter(function (_item, index) {
                    return index !== nodeToRemove.index;
                  });
                }

                var pathToAdd = nodeByPath(_path3); // It has the same parent the index can change

                var isSameParent = _toConsumableArray(_from).slice(0, -1).join('') === _toConsumableArray(_path3).slice(0, -1).join('');

                var index = _path3[_path3.length - 1]; // If moving an item within the same parent and the drop position of
                // the item is greater than the origin it affects the position
                // because the item is always removed first, we just fix the position
                // by decreasing.

                if (isSameParent && nodeToRemove.index < pathToAdd.index) {
                  index -= 1;
                }

                if (pathToAdd.parent) {
                  pathToAdd.parent[nestedKey] = [].concat(_toConsumableArray(pathToAdd.parent[nestedKey].slice(0, index)), [nodeToRemove.item], _toConsumableArray(pathToAdd.parent[nestedKey].slice(index)));
                } else {
                  immutableTree = [].concat(_toConsumableArray(immutableTree.slice(0, index)), [nodeToRemove.item], _toConsumableArray(immutableTree.slice(index)));
                }

                break;
              }

            case 'remove':
              {
                var _path4 = patch.path;

                var _nodeToRemove = nodeByPath(_path4);

                if (_nodeToRemove.parent) {
                  _nodeToRemove.parent[nestedKey] = _nodeToRemove.parent[nestedKey].filter(function (_item, index) {
                    return index !== _nodeToRemove.index;
                  });
                } else {
                  immutableTree = immutableTree.filter(function (_item, index) {
                    return index !== _nodeToRemove.index;
                  });
                }

                break;
              }

            case 'replace':
              {
                var _item3 = patch.item,
                    _path5 = patch.path;
                var nodeToReplace = nodeByPath(_path5);

                if (nodeToReplace.parent) {
                  nodeToReplace.parent[nestedKey] = nodeToReplace.parent[nestedKey].filter(function (_item, index) {
                    return index !== nodeToReplace.index;
                  });
                  nodeToReplace.parent[nestedKey].splice(nodeToReplace.index, 0, _item3);
                } else {
                  immutableTree.splice(nodeToReplace.index, 1);
                  immutableTree.splice(nodeToReplace.index, 0, _item3);
                }

                break;
              }

            default:
              break;
          }
        });
        return immutableTree;
      }

      return {
        applyPatches: applyPatches,
        nodeByPath: nodeByPath,
        produce: function produce(patch) {
          patches.push(patch);
        }
      };
    }
  }
});
//# sourceMappingURL=useTree.js.map