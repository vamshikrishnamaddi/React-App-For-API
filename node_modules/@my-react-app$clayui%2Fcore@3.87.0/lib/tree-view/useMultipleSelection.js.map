{"version":3,"sources":["useMultipleSelection.js"],"names":["Object","defineProperty","exports","value","useMultipleSelection","_shared","require","_react","_collection","_useTree","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","Array","from","isArray","_arrayLikeToArray","_slicedToArray","i","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","o","minLen","n","prototype","toString","call","slice","constructor","name","test","len","length","arr2","_i","_arr","_n","_d","_s","_e","next","done","push","err","props","_props$defaultSelecte","selectionMode","indeterminateKeys","useRef","Set","_useInternalState","useInternalState","defaultName","defaultValue","defaultSelectedKeys","handleName","onChange","onSelectionChange","selectedKeys","_useInternalState2","setSelectionKeys","isUncontrolled","useMemo","indeterminates","current","filter","key","keyMap","layoutKeys","get","children","unselected","some","has","toggleParentSelection","useCallback","hasIndeterminate","selecteds","parentKey","parentKeyMap","isIndeterminate","indeterminate","add","delete","toggleLazyChildrenSelection","item","currentKey","select","nestedKey","forEach","index","getKey","id","toggleChildrenSelection","lazyChild","_props$items","tree","createImmutableTree","items","node","nodeByPath","loc","size","childrenKeyMap","toggleSelection","options","_ref","_ref$parentSelection","parentSelection","mode","_selecteds","replaceIndeterminateKeys","keys"],"mappings":"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","file":"useMultipleSelection.js","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useMultipleSelection = useMultipleSelection;\n\nvar _shared = require(\"@clayui/shared\");\n\nvar _react = require(\"react\");\n\nvar _collection = require(\"../collection\");\n\nvar _useTree = require(\"./useTree\");\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n/**\n * The selection hook implementation handles the responsibility of optimizing\n * the tree selection in more complex scenarios like multiple recursive\n * selection, recursively selecting in two directions from the point where the\n * item is in the tree.\n *\n * Root\n * ├─ Item 0\n * ├─ Item 1\n * │  ├─ Item 2 <- Select this item.\n * │  │  ├─ Item 3\n * │  │  ├─ Item 4\n * │  ├─ Item 5\n *\n * Selecting the item must recursively navigate up and down from the item's\n * point in the tree to the end at each end, the selection rules are different\n * when navigating up and down.\n *\n * {\n *  'Item 1': {\n *    children: ['Item 2', 'Item 5'],\n *    parentKey: 'Root'\n *  }\n * }\n *\n * Navigation in the tree is supported by a hashmap structure with linked list\n * that avoids the operation of traversing the tree in search of all parent and\n * childs items. Navigation done this way lets you go from 1 to 1.\n *\n * Assembling the `layoutKeys` structure is also optimized to avoid traversing\n * the entire tree and blocking rendering until the operation is finished,\n * instead, the hook embodies the concept of building the structure in\n * React flow, i.e. when the item component is rendered, the record is added\n * to `layoutKeys` and and keeping the structure up to date is free because the\n * method is called on component mount and unmount. The trade-off is that we\n * don't get the complete mirror of the tree in the hashmap but only what is\n * rendered, this decreases the amount of data when there is a big tree but we\n * have problems recursively selecting to down.\n *\n * Root [0]\n * ├─ Item 0 [0, 0]\n * ├─ Item 1 [0, 1]\n * │  ├─ Item 2 [0, 1, 0]\n * │  │  ├─ Item 3 [0, 1, 0, 0]\n * │  │  ├─ Item 4 [0, 1, 0, 1]\n * │  ├─ Item 5 [0, 1, 1]\n *\n * The implementation solves this with a fallback approach of identifying if\n * the item has unrendered children and using the tree to navigate but using\n * the item path to avoid traversing the entire tree.\n */\nfunction useMultipleSelection(props) {\n  var _props$defaultSelecte;\n\n  var selectionMode = props.selectionMode;\n  var indeterminateKeys = (0, _react.useRef)(new Set());\n\n  var _useInternalState = (0, _shared.useInternalState)({\n    defaultName: 'defaultSelectedKeys',\n    defaultValue: (_props$defaultSelecte = props.defaultSelectedKeys) !== null && _props$defaultSelecte !== void 0 ? _props$defaultSelecte : new Set(),\n    handleName: 'onSelectionChange',\n    name: 'selectedKeys',\n    onChange: props.onSelectionChange,\n    value: props.selectedKeys\n  }),\n      _useInternalState2 = _slicedToArray(_useInternalState, 3),\n      selectedKeys = _useInternalState2[0],\n      setSelectionKeys = _useInternalState2[1],\n      isUncontrolled = _useInternalState2[2];\n  /**\n   * We are using `useMemo` to do indeterminate state revalidation in the\n   * render cycle instead of in the `useEffect` which happens after rendering.\n   */\n\n\n  (0, _react.useMemo)(function () {\n    if (props.selectionMode === 'multiple-recursive' && !isUncontrolled) {\n      var indeterminates = Array.from(indeterminateKeys.current);\n      indeterminateKeys.current = new Set(indeterminates.filter(function (key) {\n        var keyMap = props.layoutKeys.current.get(key);\n\n        var children = _toConsumableArray(keyMap.children);\n\n        var unselected = children.some(function (key) {\n          return !selectedKeys.has(key);\n        });\n\n        if (unselected) {\n          if (children.some(function (key) {\n            return selectedKeys.has(key) || indeterminateKeys.current.has(key);\n          })) {\n            return true;\n          } else {\n            return false;\n          }\n        } else {\n          return false;\n        }\n      }));\n    }\n  }, [selectedKeys]);\n  var toggleParentSelection = (0, _react.useCallback)(function (hasIndeterminate, keyMap, selecteds) {\n    if (!keyMap.parentKey) {\n      return;\n    }\n\n    var parentKeyMap = props.layoutKeys.current.get(keyMap.parentKey); // Support variable for indeterminate state during recursive flow when\n    // visual indeterminate state is disabled.\n\n    var isIndeterminate = false; // Root\n    // ├─ Item 0\n    // ├─ Item 1 <- Current recursion flow\n    // │  ├─ (Indeterminate) Item 2\n    // │  │  ├─ (Checked) Item 3 <- Start\n    // │  │  ├─ Item 4\n    //\n    // As the method works recursively from the item's point in the tree\n    // to up, if the item's parent was already marked as indeterminate, from\n    // here we start to mark all the parents as indeterminate to avoid\n    // unnecessary operations.\n\n    if (hasIndeterminate) {\n      if (props.indeterminate) {\n        indeterminateKeys.current.add(keyMap.parentKey);\n      }\n\n      isIndeterminate = true;\n      selecteds.delete(keyMap.parentKey);\n    } else {\n      var children = _toConsumableArray(parentKeyMap.children); // Instead of using `every` method to check if all items are\n      // selected, we look for any not selected, which means we don't have\n      // all the items selected and we don't always need to go through the\n      // entire array.\n\n\n      var unselected = children.some(function (key) {\n        return !selecteds.has(key);\n      });\n\n      if (unselected) {\n        // An item can only be indeterminate when there is at least\n        // one selected or indeterminate item in its tree. We don't need\n        // to sweep the tree because we have the recursive effect.\n        if (children.some(function (key) {\n          return selecteds.has(key) || indeterminateKeys.current.has(key);\n        })) {\n          if (props.indeterminate) {\n            indeterminateKeys.current.add(keyMap.parentKey);\n          }\n\n          isIndeterminate = true;\n        } else {\n          indeterminateKeys.current.delete(keyMap.parentKey);\n          isIndeterminate = false;\n        }\n\n        selecteds.delete(keyMap.parentKey);\n      } else {\n        indeterminateKeys.current.delete(keyMap.parentKey);\n        isIndeterminate = false;\n        selecteds.add(keyMap.parentKey);\n      }\n    }\n\n    toggleParentSelection(isIndeterminate, parentKeyMap, selecteds);\n  }, [props.layoutKeys, indeterminateKeys, props.indeterminate]);\n  var toggleLazyChildrenSelection = (0, _react.useCallback)(function (item, currentKey, selecteds, select) {\n    var children = item[props.nestedKey];\n\n    if (!children) {\n      return;\n    }\n\n    children.forEach(function (item, index) {\n      // TODO: The `key` property of the component that the developer\n      // can set is not being considered.\n      var key = (0, _collection.getKey)(index, item.id, currentKey);\n\n      if (select) {\n        selecteds.add(key);\n      } else {\n        selecteds.delete(key);\n      }\n\n      toggleLazyChildrenSelection(item, key, selecteds, select);\n    });\n  }, [props.nestedKey]);\n  /**\n   * The recursive selection of children of an item is done using the\n   * `layoutKeys` structure which is the representation of the items rendered\n   * in the DOM, when the child is not rendered in the DOM the method uses the\n   * fallback of the tree to continue the recursion from where it left off.\n   */\n\n  var toggleChildrenSelection = (0, _react.useCallback)(function (keyMap, currentKey, selecteds, select) {\n    if (keyMap.lazyChild) {\n      var _props$items;\n\n      var tree = (0, _useTree.createImmutableTree)((_props$items = props.items) !== null && _props$items !== void 0 ? _props$items : [], props.nestedKey);\n      var node = tree.nodeByPath(keyMap.loc);\n      return toggleLazyChildrenSelection(node.item, currentKey, selecteds, select);\n    }\n\n    if (!keyMap.children.size) {\n      return;\n    }\n\n    keyMap.children.forEach(function (key) {\n      if (select) {\n        selecteds.add(key);\n      } else {\n        selecteds.delete(key);\n      }\n\n      var childrenKeyMap = props.layoutKeys.current.get(key);\n      toggleChildrenSelection(childrenKeyMap, key, selecteds, select);\n    });\n  }, [toggleLazyChildrenSelection, props.layoutKeys, props.items, props.nestedKey]);\n  var toggleSelection = (0, _react.useCallback)(function (key, options) {\n    var _ref = options !== null && options !== void 0 ? options : {},\n        _ref$parentSelection = _ref.parentSelection,\n        parentSelection = _ref$parentSelection === void 0 ? true : _ref$parentSelection,\n        mode = _ref.selectionMode;\n\n    switch (mode !== null && mode !== void 0 ? mode : selectionMode) {\n      case 'multiple':\n        {\n          var selecteds = new Set(selectedKeys);\n\n          if (selecteds.has(key)) {\n            selecteds.delete(key);\n          } else {\n            selecteds.add(key);\n          }\n\n          setSelectionKeys(selecteds);\n          break;\n        }\n\n      case 'multiple-recursive':\n        {\n          var _selecteds = new Set(selectedKeys);\n\n          var keyMap = props.layoutKeys.current.get(key);\n\n          if (_selecteds.has(key)) {\n            _selecteds.delete(key);\n          } else if (!indeterminateKeys.current.has(key)) {\n            _selecteds.add(key);\n          } // Resets the indeterminate state because its selected state\n          // will change.\n\n\n          indeterminateKeys.current.delete(key);\n          toggleChildrenSelection(keyMap, key, _selecteds, _selecteds.has(key));\n\n          if (parentSelection) {\n            toggleParentSelection(false, keyMap, _selecteds);\n          }\n\n          setSelectionKeys(_selecteds);\n          break;\n        }\n\n      default:\n        {\n          if (selectedKeys.has(key)) {\n            setSelectionKeys(new Set());\n          } else {\n            setSelectionKeys(new Set([key]));\n          }\n\n          break;\n        }\n    }\n  }, [props.layoutKeys, indeterminateKeys, selectedKeys, selectionMode, toggleChildrenSelection, toggleParentSelection]);\n  var isIndeterminate = (0, _react.useCallback)(function (key) {\n    return indeterminateKeys.current.has(key);\n  }, [indeterminateKeys]);\n  var replaceIndeterminateKeys = (0, _react.useCallback)(function (keys) {\n    indeterminateKeys.current = new Set(keys);\n  }, [indeterminateKeys]);\n  return {\n    isIndeterminate: isIndeterminate,\n    replaceIndeterminateKeys: replaceIndeterminateKeys,\n    selectedKeys: selectedKeys,\n    toggleSelection: toggleSelection\n  };\n}"]}