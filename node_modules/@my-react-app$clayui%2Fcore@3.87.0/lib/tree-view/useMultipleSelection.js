"use strict";

Liferay.Loader.define("@my-react-app$clayui/core@3.87.0/lib/tree-view/useMultipleSelection", ['module', 'exports', 'require', '@my-react-app$clayui/shared', 'my-react-app$react', '../collection', './useTree'], function (module, exports, require) {
  var define = undefined;
  var global = window;
  {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.useMultipleSelection = useMultipleSelection;

    var _shared = require("@my-react-app$clayui/shared");

    var _react = require("my-react-app$react");

    var _collection = require("../collection");

    var _useTree = require("./useTree");

    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }

    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
    }

    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) return _arrayLikeToArray(arr);
    }

    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }

    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }

    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }return arr2;
    }

    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];if (_i == null) return;var _arr = [];var _n = true;var _d = false;var _s, _e;try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;_e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }return _arr;
    }

    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }

    /**
     * The selection hook implementation handles the responsibility of optimizing
     * the tree selection in more complex scenarios like multiple recursive
     * selection, recursively selecting in two directions from the point where the
     * item is in the tree.
     *
     * Root
     * ├─ Item 0
     * ├─ Item 1
     * │  ├─ Item 2 <- Select this item.
     * │  │  ├─ Item 3
     * │  │  ├─ Item 4
     * │  ├─ Item 5
     *
     * Selecting the item must recursively navigate up and down from the item's
     * point in the tree to the end at each end, the selection rules are different
     * when navigating up and down.
     *
     * {
     *  'Item 1': {
     *    children: ['Item 2', 'Item 5'],
     *    parentKey: 'Root'
     *  }
     * }
     *
     * Navigation in the tree is supported by a hashmap structure with linked list
     * that avoids the operation of traversing the tree in search of all parent and
     * childs items. Navigation done this way lets you go from 1 to 1.
     *
     * Assembling the `layoutKeys` structure is also optimized to avoid traversing
     * the entire tree and blocking rendering until the operation is finished,
     * instead, the hook embodies the concept of building the structure in
     * React flow, i.e. when the item component is rendered, the record is added
     * to `layoutKeys` and and keeping the structure up to date is free because the
     * method is called on component mount and unmount. The trade-off is that we
     * don't get the complete mirror of the tree in the hashmap but only what is
     * rendered, this decreases the amount of data when there is a big tree but we
     * have problems recursively selecting to down.
     *
     * Root [0]
     * ├─ Item 0 [0, 0]
     * ├─ Item 1 [0, 1]
     * │  ├─ Item 2 [0, 1, 0]
     * │  │  ├─ Item 3 [0, 1, 0, 0]
     * │  │  ├─ Item 4 [0, 1, 0, 1]
     * │  ├─ Item 5 [0, 1, 1]
     *
     * The implementation solves this with a fallback approach of identifying if
     * the item has unrendered children and using the tree to navigate but using
     * the item path to avoid traversing the entire tree.
     */
    function useMultipleSelection(props) {
      var _props$defaultSelecte;

      var selectionMode = props.selectionMode;
      var indeterminateKeys = (0, _react.useRef)(new Set());

      var _useInternalState = (0, _shared.useInternalState)({
        defaultName: 'defaultSelectedKeys',
        defaultValue: (_props$defaultSelecte = props.defaultSelectedKeys) !== null && _props$defaultSelecte !== void 0 ? _props$defaultSelecte : new Set(),
        handleName: 'onSelectionChange',
        name: 'selectedKeys',
        onChange: props.onSelectionChange,
        value: props.selectedKeys
      }),
          _useInternalState2 = _slicedToArray(_useInternalState, 3),
          selectedKeys = _useInternalState2[0],
          setSelectionKeys = _useInternalState2[1],
          isUncontrolled = _useInternalState2[2];
      /**
       * We are using `useMemo` to do indeterminate state revalidation in the
       * render cycle instead of in the `useEffect` which happens after rendering.
       */

      (0, _react.useMemo)(function () {
        if (props.selectionMode === 'multiple-recursive' && !isUncontrolled) {
          var indeterminates = Array.from(indeterminateKeys.current);
          indeterminateKeys.current = new Set(indeterminates.filter(function (key) {
            var keyMap = props.layoutKeys.current.get(key);

            var children = _toConsumableArray(keyMap.children);

            var unselected = children.some(function (key) {
              return !selectedKeys.has(key);
            });

            if (unselected) {
              if (children.some(function (key) {
                return selectedKeys.has(key) || indeterminateKeys.current.has(key);
              })) {
                return true;
              } else {
                return false;
              }
            } else {
              return false;
            }
          }));
        }
      }, [selectedKeys]);
      var toggleParentSelection = (0, _react.useCallback)(function (hasIndeterminate, keyMap, selecteds) {
        if (!keyMap.parentKey) {
          return;
        }

        var parentKeyMap = props.layoutKeys.current.get(keyMap.parentKey); // Support variable for indeterminate state during recursive flow when
        // visual indeterminate state is disabled.

        var isIndeterminate = false; // Root
        // ├─ Item 0
        // ├─ Item 1 <- Current recursion flow
        // │  ├─ (Indeterminate) Item 2
        // │  │  ├─ (Checked) Item 3 <- Start
        // │  │  ├─ Item 4
        //
        // As the method works recursively from the item's point in the tree
        // to up, if the item's parent was already marked as indeterminate, from
        // here we start to mark all the parents as indeterminate to avoid
        // unnecessary operations.

        if (hasIndeterminate) {
          if (props.indeterminate) {
            indeterminateKeys.current.add(keyMap.parentKey);
          }

          isIndeterminate = true;
          selecteds.delete(keyMap.parentKey);
        } else {
          var children = _toConsumableArray(parentKeyMap.children); // Instead of using `every` method to check if all items are
          // selected, we look for any not selected, which means we don't have
          // all the items selected and we don't always need to go through the
          // entire array.


          var unselected = children.some(function (key) {
            return !selecteds.has(key);
          });

          if (unselected) {
            // An item can only be indeterminate when there is at least
            // one selected or indeterminate item in its tree. We don't need
            // to sweep the tree because we have the recursive effect.
            if (children.some(function (key) {
              return selecteds.has(key) || indeterminateKeys.current.has(key);
            })) {
              if (props.indeterminate) {
                indeterminateKeys.current.add(keyMap.parentKey);
              }

              isIndeterminate = true;
            } else {
              indeterminateKeys.current.delete(keyMap.parentKey);
              isIndeterminate = false;
            }

            selecteds.delete(keyMap.parentKey);
          } else {
            indeterminateKeys.current.delete(keyMap.parentKey);
            isIndeterminate = false;
            selecteds.add(keyMap.parentKey);
          }
        }

        toggleParentSelection(isIndeterminate, parentKeyMap, selecteds);
      }, [props.layoutKeys, indeterminateKeys, props.indeterminate]);
      var toggleLazyChildrenSelection = (0, _react.useCallback)(function (item, currentKey, selecteds, select) {
        var children = item[props.nestedKey];

        if (!children) {
          return;
        }

        children.forEach(function (item, index) {
          // TODO: The `key` property of the component that the developer
          // can set is not being considered.
          var key = (0, _collection.getKey)(index, item.id, currentKey);

          if (select) {
            selecteds.add(key);
          } else {
            selecteds.delete(key);
          }

          toggleLazyChildrenSelection(item, key, selecteds, select);
        });
      }, [props.nestedKey]);
      /**
       * The recursive selection of children of an item is done using the
       * `layoutKeys` structure which is the representation of the items rendered
       * in the DOM, when the child is not rendered in the DOM the method uses the
       * fallback of the tree to continue the recursion from where it left off.
       */

      var toggleChildrenSelection = (0, _react.useCallback)(function (keyMap, currentKey, selecteds, select) {
        if (keyMap.lazyChild) {
          var _props$items;

          var tree = (0, _useTree.createImmutableTree)((_props$items = props.items) !== null && _props$items !== void 0 ? _props$items : [], props.nestedKey);
          var node = tree.nodeByPath(keyMap.loc);
          return toggleLazyChildrenSelection(node.item, currentKey, selecteds, select);
        }

        if (!keyMap.children.size) {
          return;
        }

        keyMap.children.forEach(function (key) {
          if (select) {
            selecteds.add(key);
          } else {
            selecteds.delete(key);
          }

          var childrenKeyMap = props.layoutKeys.current.get(key);
          toggleChildrenSelection(childrenKeyMap, key, selecteds, select);
        });
      }, [toggleLazyChildrenSelection, props.layoutKeys, props.items, props.nestedKey]);
      var toggleSelection = (0, _react.useCallback)(function (key, options) {
        var _ref = options !== null && options !== void 0 ? options : {},
            _ref$parentSelection = _ref.parentSelection,
            parentSelection = _ref$parentSelection === void 0 ? true : _ref$parentSelection,
            mode = _ref.selectionMode;

        switch (mode !== null && mode !== void 0 ? mode : selectionMode) {
          case 'multiple':
            {
              var selecteds = new Set(selectedKeys);

              if (selecteds.has(key)) {
                selecteds.delete(key);
              } else {
                selecteds.add(key);
              }

              setSelectionKeys(selecteds);
              break;
            }

          case 'multiple-recursive':
            {
              var _selecteds = new Set(selectedKeys);

              var keyMap = props.layoutKeys.current.get(key);

              if (_selecteds.has(key)) {
                _selecteds.delete(key);
              } else if (!indeterminateKeys.current.has(key)) {
                _selecteds.add(key);
              } // Resets the indeterminate state because its selected state
              // will change.


              indeterminateKeys.current.delete(key);
              toggleChildrenSelection(keyMap, key, _selecteds, _selecteds.has(key));

              if (parentSelection) {
                toggleParentSelection(false, keyMap, _selecteds);
              }

              setSelectionKeys(_selecteds);
              break;
            }

          default:
            {
              if (selectedKeys.has(key)) {
                setSelectionKeys(new Set());
              } else {
                setSelectionKeys(new Set([key]));
              }

              break;
            }
        }
      }, [props.layoutKeys, indeterminateKeys, selectedKeys, selectionMode, toggleChildrenSelection, toggleParentSelection]);
      var isIndeterminate = (0, _react.useCallback)(function (key) {
        return indeterminateKeys.current.has(key);
      }, [indeterminateKeys]);
      var replaceIndeterminateKeys = (0, _react.useCallback)(function (keys) {
        indeterminateKeys.current = new Set(keys);
      }, [indeterminateKeys]);
      return {
        isIndeterminate: isIndeterminate,
        replaceIndeterminateKeys: replaceIndeterminateKeys,
        selectedKeys: selectedKeys,
        toggleSelection: toggleSelection
      };
    }
  }
});
//# sourceMappingURL=useMultipleSelection.js.map