"use strict";

Liferay.Loader.define("@my-react-app$clayui/core@3.87.0/lib/tree-view/useLayout", ['module', 'exports', 'require', 'my-react-app$react'], function (module, exports, require) {
  var define = undefined;
  var global = window;
  {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.useLayout = useLayout;

    var _react = require("my-react-app$react");

    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }

    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }

    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
    }

    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) return _arrayLikeToArray(arr);
    }

    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }return arr2;
    }

    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);enumerableOnly && (symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }return keys;
    }

    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }return target;
    }

    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }return obj;
    }

    function useLayout() {
      var layoutKeys = (0, _react.useRef)(new Map());
      /**
       * The method creates the mirror of the tree in a hashmap structure with a
       * linked list using `parentKey` and `children`. Adding data to the structure
       * is reactive to item component rendering and disassembly. Only the rendered
       * items are in the structure, if a component is moved, removed, or added the
       * structure is updated automatically.
       *
       * useEffect(() => createPartialLayoutItem(...), []);
       *
       * The design of this method is to be coupled to `useEffect` which has the
       * mount and unmount behavior, also handles lifecycle and call order,
       * `useEffect` in nested components are called bottom-up instead of top-down
       * as in rendering.
       */

      var createPartialLayoutItem = (0, _react.useCallback)(function (key, lazyChild, loc, parentKey) {
        var keyMap = layoutKeys.current.get(key);

        if (!keyMap) {
          layoutKeys.current.set(key, {
            children: new Set(),
            lazyChild: lazyChild,
            loc: loc,
            parentKey: parentKey
          });
        } else if (keyMap.parentKey !== parentKey) {
          layoutKeys.current.set(key, _objectSpread(_objectSpread({}, keyMap), {}, {
            parentKey: parentKey
          }));
        }

        if (parentKey) {
          var _keyMap = layoutKeys.current.get(parentKey);

          if (_keyMap) {
            layoutKeys.current.set(parentKey, _objectSpread(_objectSpread({}, _keyMap), {}, {
              children: new Set([].concat(_toConsumableArray(_keyMap.children), [key])),
              lazyChild: false
            }));
          } else {
            // Pre-initializes the parent layout, as this is linked to
            // React rendering, the mount is used inside `useEffect`
            // this causes callbacks from the last rendering to be
            // called first than parents, starting from the bottom up.
            //
            // We just add an initial value then update the parentKey
            // when the corresponding one is called.
            layoutKeys.current.set(parentKey, {
              children: new Set([key]),
              lazyChild: false,
              loc: loc.slice(0, -1),
              parentKey: undefined
            });
          }
        }

        return function unmount() {
          layoutKeys.current.delete(key);

          if (parentKey && layoutKeys.current.has(parentKey)) {
            var _keyMap2 = layoutKeys.current.get(parentKey);

            var children = new Set(_keyMap2.children);
            children.delete(key);
            layoutKeys.current.set(parentKey, _objectSpread(_objectSpread({}, _keyMap2), {}, {
              children: children,
              lazyChild: children.size === 0
            }));
          }
        };
      }, [layoutKeys]);
      var patchItem = (0, _react.useCallback)(function (key, loc) {
        var keyMap = layoutKeys.current.get(key);

        if (keyMap) {
          layoutKeys.current.set(key, _objectSpread(_objectSpread({}, keyMap), {}, {
            loc: loc
          }));
        }
      }, [layoutKeys]);
      return {
        createPartialLayoutItem: createPartialLayoutItem,
        layoutKeys: layoutKeys,
        patchItem: patchItem
      };
    }
  }
});
//# sourceMappingURL=useLayout.js.map