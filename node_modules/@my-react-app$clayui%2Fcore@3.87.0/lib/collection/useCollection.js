"use strict";

Liferay.Loader.define("@my-react-app$clayui/core@3.87.0/lib/collection/useCollection", ['module', 'exports', 'require', 'my-react-app$react', './utils'], function (module, exports, require) {
  var define = undefined;
  var global = window;
  {
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
        return typeof obj;
      } : function (obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      }, _typeof(obj);
    }

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.useCollection = useCollection;

    var _react = _interopRequireWildcard(require("my-react-app$react"));

    var _utils = require("./utils");

    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function") return null;var cacheBabelInterop = new WeakMap();var cacheNodeInterop = new WeakMap();return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }

    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return { default: obj };
      }var cache = _getRequireWildcardCache(nodeInterop);if (cache && cache.has(obj)) {
        return cache.get(obj);
      }var newObj = {};var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }newObj.default = obj;if (cache) {
        cache.set(obj, newObj);
      }return newObj;
    }

    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }

    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }

    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
    }

    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) return _arrayLikeToArray(arr);
    }

    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }return arr2;
    }

    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);enumerableOnly && (symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }return keys;
    }

    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }return target;
    }

    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }return obj;
    }

    var CollectionContext = /*#__PURE__*/_react.default.createContext({});

    var SECTION_NAMES = ['Group', 'Section'];

    function useCollection(_ref) {
      var children = _ref.children,
          exclude = _ref.exclude,
          filter = _ref.filter,
          filterKey = _ref.filterKey,
          ItemContainer = _ref.itemContainer,
          items = _ref.items,
          parentKey = _ref.parentKey,
          _ref$passthroughKey = _ref.passthroughKey,
          passthroughKey = _ref$passthroughKey === void 0 ? true : _ref$passthroughKey,
          publicApi = _ref.publicApi,
          _ref$suppressTextValu = _ref.suppressTextValueWarning,
          suppressTextValueWarning = _ref$suppressTextValu === void 0 ? true : _ref$suppressTextValu;

      var _useContext = (0, _react.useContext)(CollectionContext),
          parentLayout = _useContext.layout;

      var layoutRef = (0, _react.useRef)(new Map());
      var layout = parentLayout !== null && parentLayout !== void 0 ? parentLayout : layoutRef;
      var performFilter = (0, _react.useCallback)(function (child) {
        if (!filter) {
          return false;
        }

        if (typeof child.props.children === 'string') {
          return !filter(child.props.children);
        }

        if (filterKey && child.props[filterKey]) {
          return !filter(child.props[filterKey]);
        }

        return false;
      }, [filter]);
      var performItemRender = (0, _react.useCallback)(function (child, key, index, item) {
        if (child.type.displayName === 'Item') {
          layout.current.set(key, getTextValue(key, child, suppressTextValueWarning));
        }

        if (performFilter(child)) {
          return;
        }

        if (ItemContainer) {
          return (/*#__PURE__*/_react.default.createElement(ItemContainer, {
              index: index,
              item: item,
              key: key,
              keyValue: key
            }, child)
          );
        }

        var hasChildNeedPassthroughKey = child.type.passthroughKey;
        return (/*#__PURE__*/_react.default.cloneElement(child, _objectSpread({
            key: key
          }, passthroughKey || hasChildNeedPassthroughKey ? {
            index: index,
            keyValue: key
          } : {}))
        );
      }, [performFilter]);
      var performCollection = (0, _react.useCallback)(function (_ref2) {
        var children = _ref2.children,
            items = _ref2.items;

        // Pre-initialization of nested collections to mount the layout
        // structure.
        // TODO: Mount a structure with the children's information and cache it
        // to use when rendering the component.
        var callNestedChild = function callNestedChild(child) {
          if (child.type.displayName && SECTION_NAMES.includes(child.type.displayName)) {
            var _child$props = child.props,
                _children = _child$props.children,
                _items = _child$props.items;
            performCollection({
              children: _children,
              items: _items
            });
          }
        };

        if (children instanceof Function && items) {
          return items.map(function (item, index) {
            var _item$id;

            var publicItem = exclude ? (0, _utils.excludeProps)(item, exclude) : item;
            var child = Array.isArray(publicApi) ? children.apply(void 0, [publicItem].concat(_toConsumableArray(publicApi))) : children(publicItem);
            callNestedChild(child);
            return performItemRender(child, (0, _utils.getKey)(index, (_item$id = item.id) !== null && _item$id !== void 0 ? _item$id : child.key, parentKey), index, item);
          });
        }

        return _react.default.Children.map(children, function (child, index) {
          if (! /*#__PURE__*/_react.default.isValidElement(child)) {
            return null;
          }

          callNestedChild(child);
          return performItemRender(child, (0, _utils.getKey)(index, child.key, parentKey), index);
        });
      }, [performItemRender, publicApi]);
      var getItem = (0, _react.useCallback)(function (key) {
        return layout.current.get(key);
      }, []);
      var getFirstItem = (0, _react.useCallback)(function () {
        var key = layout.current.keys().next().value;
        return {
          key: key,
          value: layout.current.get(key)
        };
      }, []);
      var collection = (0, _react.useMemo)(function () {
        return performCollection({
          children: children,
          items: items
        });
      }, [children, performCollection, items]);
      return {
        collection: /*#__PURE__*/_react.default.createElement(CollectionContext.Provider, {
          value: {
            layout: layout
          }
        }, collection),
        getFirstItem: getFirstItem,
        getItem: getItem
      };
    }

    function getTextValue(key, child, suppressTextValueWarning) {
      if (typeof child.props.children === 'string') {
        return child.props.children;
      }

      if (child.props.textValue) {
        return child.props.textValue;
      }

      if (!suppressTextValueWarning) {
        console.warn("Clay: <Item key=\"".concat(key, "\" /> with non-plain text content is not compatible with the type being selected. Please add a `textValue` prop."));
      }

      return '';
    }
  }
});
//# sourceMappingURL=useCollection.js.map