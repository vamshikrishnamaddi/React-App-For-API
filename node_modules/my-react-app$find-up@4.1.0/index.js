'use strict';

Liferay.Loader.define('my-react-app$find-up@4.1.0/index', ['module', 'exports', 'require', 'my-react-app$path', 'my-react-app$locate-path', 'my-react-app$path-exists'], function (module, exports, require) {
	var define = undefined;
	var global = window;
	{
		var _extends = Object.assign || function (target) {
			for (var i = 1; i < arguments.length; i++) {
				var source = arguments[i];

				for (var key in source) {
					if (Object.prototype.hasOwnProperty.call(source, key)) {
						target[key] = source[key];
					}
				}
			}

			return target;
		};

		const path = require('my-react-app$path');
		const locatePath = require('my-react-app$locate-path');
		const pathExists = require('my-react-app$path-exists');

		const stop = Symbol('findUp.stop');

		module.exports = async (name, options = {}) => {
			let directory = path.resolve(options.cwd || '');
			const { root } = path.parse(directory);
			const paths = [].concat(name);

			const runMatcher = async locateOptions => {
				if (typeof name !== 'function') {
					return locatePath(paths, locateOptions);
				}

				const foundPath = await name(locateOptions.cwd);
				if (typeof foundPath === 'string') {
					return locatePath([foundPath], locateOptions);
				}

				return foundPath;
			};

			// eslint-disable-next-line no-constant-condition
			while (true) {
				// eslint-disable-next-line no-await-in-loop
				const foundPath = await runMatcher(_extends({}, options, { cwd: directory }));

				if (foundPath === stop) {
					return;
				}

				if (foundPath) {
					return path.resolve(directory, foundPath);
				}

				if (directory === root) {
					return;
				}

				directory = path.dirname(directory);
			}
		};

		module.exports.sync = (name, options = {}) => {
			let directory = path.resolve(options.cwd || '');
			const { root } = path.parse(directory);
			const paths = [].concat(name);

			const runMatcher = locateOptions => {
				if (typeof name !== 'function') {
					return locatePath.sync(paths, locateOptions);
				}

				const foundPath = name(locateOptions.cwd);
				if (typeof foundPath === 'string') {
					return locatePath.sync([foundPath], locateOptions);
				}

				return foundPath;
			};

			// eslint-disable-next-line no-constant-condition
			while (true) {
				const foundPath = runMatcher(_extends({}, options, { cwd: directory }));

				if (foundPath === stop) {
					return;
				}

				if (foundPath) {
					return path.resolve(directory, foundPath);
				}

				if (directory === root) {
					return;
				}

				directory = path.dirname(directory);
			}
		};

		module.exports.exists = pathExists;

		module.exports.sync.exists = pathExists.sync;

		module.exports.stop = stop;
	}
});
//# sourceMappingURL=index.js.map