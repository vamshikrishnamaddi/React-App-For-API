{"version":3,"sources":["combineReducers.js"],"names":["ActionTypes","warning","isPlainObject","kindOf","getUnexpectedStateShapeWarningMessage","inputState","reducers","action","unexpectedKeyCache","reducerKeys","Object","keys","argumentName","type","INIT","length","join","unexpectedKeys","filter","key","hasOwnProperty","forEach","REPLACE","assertReducerShape","reducer","initialState","undefined","Error","PROBE_UNKNOWN_ACTION","combineReducers","finalReducers","i","finalReducerKeys","shapeAssertionError","e","combination","state","warningMessage","hasChanged","nextState","previousStateForKey","nextStateForKey","actionType","String"],"mappings":"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","file":"combineReducers.js","sourcesContent":["import ActionTypes from './utils/actionTypes'\nimport warning from './utils/warning'\nimport isPlainObject from './utils/isPlainObject'\nimport { kindOf } from './utils/kindOf'\n\nfunction getUnexpectedStateShapeWarningMessage(\n  inputState,\n  reducers,\n  action,\n  unexpectedKeyCache\n) {\n  const reducerKeys = Object.keys(reducers)\n  const argumentName =\n    action && action.type === ActionTypes.INIT\n      ? 'preloadedState argument passed to createStore'\n      : 'previous state received by the reducer'\n\n  if (reducerKeys.length === 0) {\n    return (\n      'Store does not have a valid reducer. Make sure the argument passed ' +\n      'to combineReducers is an object whose values are reducers.'\n    )\n  }\n\n  if (!isPlainObject(inputState)) {\n    return (\n      `The ${argumentName} has unexpected type of \"${kindOf(\n        inputState\n      )}\". Expected argument to be an object with the following ` +\n      `keys: \"${reducerKeys.join('\", \"')}\"`\n    )\n  }\n\n  const unexpectedKeys = Object.keys(inputState).filter(\n    (key) => !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key]\n  )\n\n  unexpectedKeys.forEach((key) => {\n    unexpectedKeyCache[key] = true\n  })\n\n  if (action && action.type === ActionTypes.REPLACE) return\n\n  if (unexpectedKeys.length > 0) {\n    return (\n      `Unexpected ${unexpectedKeys.length > 1 ? 'keys' : 'key'} ` +\n      `\"${unexpectedKeys.join('\", \"')}\" found in ${argumentName}. ` +\n      `Expected to find one of the known reducer keys instead: ` +\n      `\"${reducerKeys.join('\", \"')}\". Unexpected keys will be ignored.`\n    )\n  }\n}\n\nfunction assertReducerShape(reducers) {\n  Object.keys(reducers).forEach((key) => {\n    const reducer = reducers[key]\n    const initialState = reducer(undefined, { type: ActionTypes.INIT })\n\n    if (typeof initialState === 'undefined') {\n      throw new Error(\n        `The slice reducer for key \"${key}\" returned undefined during initialization. ` +\n          `If the state passed to the reducer is undefined, you must ` +\n          `explicitly return the initial state. The initial state may ` +\n          `not be undefined. If you don't want to set a value for this reducer, ` +\n          `you can use null instead of undefined.`\n      )\n    }\n\n    if (\n      typeof reducer(undefined, {\n        type: ActionTypes.PROBE_UNKNOWN_ACTION(),\n      }) === 'undefined'\n    ) {\n      throw new Error(\n        `The slice reducer for key \"${key}\" returned undefined when probed with a random type. ` +\n          `Don't try to handle '${ActionTypes.INIT}' or other actions in \"redux/*\" ` +\n          `namespace. They are considered private. Instead, you must return the ` +\n          `current state for any unknown actions, unless it is undefined, ` +\n          `in which case you must return the initial state, regardless of the ` +\n          `action type. The initial state may not be undefined, but can be null.`\n      )\n    }\n  })\n}\n\n/**\n * Turns an object whose values are different reducer functions, into a single\n * reducer function. It will call every child reducer, and gather their results\n * into a single state object, whose keys correspond to the keys of the passed\n * reducer functions.\n *\n * @param {Object} reducers An object whose values correspond to different\n * reducer functions that need to be combined into one. One handy way to obtain\n * it is to use ES6 `import * as reducers` syntax. The reducers may never return\n * undefined for any action. Instead, they should return their initial state\n * if the state passed to them was undefined, and the current state for any\n * unrecognized action.\n *\n * @returns {Function} A reducer function that invokes every reducer inside the\n * passed object, and builds a state object with the same shape.\n */\nexport default function combineReducers(reducers) {\n  const reducerKeys = Object.keys(reducers)\n  const finalReducers = {}\n  for (let i = 0; i < reducerKeys.length; i++) {\n    const key = reducerKeys[i]\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof reducers[key] === 'undefined') {\n        warning(`No reducer provided for key \"${key}\"`)\n      }\n    }\n\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key]\n    }\n  }\n  const finalReducerKeys = Object.keys(finalReducers)\n\n  // This is used to make sure we don't warn about the same\n  // keys multiple times.\n  let unexpectedKeyCache\n  if (process.env.NODE_ENV !== 'production') {\n    unexpectedKeyCache = {}\n  }\n\n  let shapeAssertionError\n  try {\n    assertReducerShape(finalReducers)\n  } catch (e) {\n    shapeAssertionError = e\n  }\n\n  return function combination(state = {}, action) {\n    if (shapeAssertionError) {\n      throw shapeAssertionError\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      const warningMessage = getUnexpectedStateShapeWarningMessage(\n        state,\n        finalReducers,\n        action,\n        unexpectedKeyCache\n      )\n      if (warningMessage) {\n        warning(warningMessage)\n      }\n    }\n\n    let hasChanged = false\n    const nextState = {}\n    for (let i = 0; i < finalReducerKeys.length; i++) {\n      const key = finalReducerKeys[i]\n      const reducer = finalReducers[key]\n      const previousStateForKey = state[key]\n      const nextStateForKey = reducer(previousStateForKey, action)\n      if (typeof nextStateForKey === 'undefined') {\n        const actionType = action && action.type\n        throw new Error(\n          `When called with an action of type ${\n            actionType ? `\"${String(actionType)}\"` : '(unknown type)'\n          }, the slice reducer for key \"${key}\" returned undefined. ` +\n            `To ignore an action, you must explicitly return the previous state. ` +\n            `If you want this reducer to hold no value, you can return null instead of undefined.`\n        )\n      }\n      nextState[key] = nextStateForKey\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey\n    }\n    hasChanged =\n      hasChanged || finalReducerKeys.length !== Object.keys(state).length\n    return hasChanged ? nextState : state\n  }\n}\n"]}