{"version":3,"sources":["../../src/makeRequestCall.ts"],"names":["scope","global","self","BrowserMutationObserver","MutationObserver","WebKitMutationObserver","makeRequestCallFromTimer","callback","requestCall","timeoutHandle","setTimeout","handleTimer","intervalHandle","setInterval","clearTimeout","clearInterval","makeRequestCallFromMutationObserver","toggle","observer","node","document","createTextNode","observe","characterData","data","makeRequestCall"],"mappings":";;;;;;;;;gBAUgBM,wB,GAAAA,wB;gBAwBAU,mC,GAAAA,mC;;AAlChB;AACA;AACA;AACA;AAEA,0BACA,MAAMhB,QAAQ,OAAOC,MAAP,KAAkB,WAAlB,GAAgCA,MAAhC,GAAyCC,IAAvD;AACA,cAAMC,0BACJH,MAAcI,gBAAdJ,IAAmCA,MAAcK,sBADnD;AAGO,iBAASC,wBAAT,CAAkCC,QAAlC,EAAwD;AAC9D,mBAAO,SAASC,WAAT,GAAuB;AAC7B;AACA;AACA;AACA;AACA,sBAAMC,gBAAgBC,WAAWC,WAAXD,EAAwB,CAAxBA,CAAtB;AACA;AACA;AACA;AACA,sBAAME,iBAAiBC,YAAYF,WAAZE,EAAyB,EAAzBA,CAAvB;AAEA,yBAASF,WAAT,GAAuB;AACtB;AACA;AACAG,iCAAaL,aAAbK;AACAC,kCAAcH,cAAdG;AACAR;AACA;AACD,aAlBD;AAmBA;AAIM,iBAASS,mCAAT,CAA6CT,QAA7C,EAAmE;AACzE,gBAAIU,SAAS,CAAb;AACA,kBAAMC,WAAW,IAAIf,uBAAJ,CAA4BI,QAA5B,CAAjB;AACA,kBAAMY,OAAOC,SAASC,cAATD,CAAwB,EAAxBA,CAAb;AACAF,qBAASI,OAATJ,CAAiBC,IAAjBD,EAAuB;AAAEK,+BAAe;AAAjB,aAAvBL;AACA,mBAAO,SAASV,WAAT,GAAuB;AAC7BS,yBAAS,CAACA,MAAVA;AACEE,qBAAaK,IAAbL,GAAoBF,MAApBE;AACF,aAHD;AAIA;AAEM,cAAMM,kBACZ,OAAOtB,uBAAP,KAAmC,UAAnC,GAEG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAa,2CAZH,GAcG;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAV,gCAzCG;gBAAMmB,e,GAAAA,e","sourcesContent":["// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that\n// have WebKitMutationObserver but not un-prefixed MutationObserver.\n// Must use `global` or `self` instead of `window` to work in both frames and web\n// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.\n\n/* globals self */\nconst scope = typeof global !== 'undefined' ? global : self\nconst BrowserMutationObserver =\n\t(scope as any).MutationObserver || (scope as any).WebKitMutationObserver\n\nexport function makeRequestCallFromTimer(callback: () => void) {\n\treturn function requestCall() {\n\t\t// We dispatch a timeout with a specified delay of 0 for engines that\n\t\t// can reliably accommodate that request. This will usually be snapped\n\t\t// to a 4 milisecond delay, but once we're flushing, there's no delay\n\t\t// between events.\n\t\tconst timeoutHandle = setTimeout(handleTimer, 0)\n\t\t// However, since this timer gets frequently dropped in Firefox\n\t\t// workers, we enlist an interval handle that will try to fire\n\t\t// an event 20 times per second until it succeeds.\n\t\tconst intervalHandle = setInterval(handleTimer, 50)\n\n\t\tfunction handleTimer() {\n\t\t\t// Whichever timer succeeds will cancel both timers and\n\t\t\t// execute the callback.\n\t\t\tclearTimeout(timeoutHandle)\n\t\t\tclearInterval(intervalHandle)\n\t\t\tcallback()\n\t\t}\n\t}\n}\n\n// To request a high priority event, we induce a mutation observer by toggling\n// the text of a text node between \"1\" and \"-1\".\nexport function makeRequestCallFromMutationObserver(callback: () => void) {\n\tlet toggle = 1\n\tconst observer = new BrowserMutationObserver(callback)\n\tconst node = document.createTextNode('')\n\tobserver.observe(node, { characterData: true })\n\treturn function requestCall() {\n\t\ttoggle = -toggle\n\t\t;(node as any).data = toggle\n\t}\n}\n\nexport const makeRequestCall =\n\ttypeof BrowserMutationObserver === 'function'\n\t\t? // MutationObservers are desirable because they have high priority and work\n\t\t  // reliably everywhere they are implemented.\n\t\t  // They are implemented in all modern browsers.\n\t\t  //\n\t\t  // - Android 4-4.3\n\t\t  // - Chrome 26-34\n\t\t  // - Firefox 14-29\n\t\t  // - Internet Explorer 11\n\t\t  // - iPad Safari 6-7.1\n\t\t  // - iPhone Safari 7-7.1\n\t\t  // - Safari 6-7\n\t\t  makeRequestCallFromMutationObserver\n\t\t: // MessageChannels are desirable because they give direct access to the HTML\n\t\t  // task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera\n\t\t  // 11-12, and in web workers in many engines.\n\t\t  // Although message channels yield to any queued rendering and IO tasks, they\n\t\t  // would be better than imposing the 4ms delay of timers.\n\t\t  // However, they do not work reliably in Internet Explorer or Safari.\n\n\t\t  // Internet Explorer 10 is the only browser that has setImmediate but does\n\t\t  // not have MutationObservers.\n\t\t  // Although setImmediate yields to the browser's renderer, it would be\n\t\t  // preferrable to falling back to setTimeout since it does not have\n\t\t  // the minimum 4ms penalty.\n\t\t  // Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and\n\t\t  // Desktop to a lesser extent) that renders both setImmediate and\n\t\t  // MessageChannel useless for the purposes of ASAP.\n\t\t  // https://github.com/kriskowal/q/issues/396\n\n\t\t  // Timers are implemented universally.\n\t\t  // We fall back to timers in workers in most engines, and in foreground\n\t\t  // contexts in the following browsers.\n\t\t  // However, note that even this simple case requires nuances to operate in a\n\t\t  // broad spectrum of browsers.\n\t\t  //\n\t\t  // - Firefox 3-13\n\t\t  // - Internet Explorer 6-9\n\t\t  // - iPad Safari 4.3\n\t\t  // - Lynx 2.8.7\n\t\t  makeRequestCallFromTimer\n"]}